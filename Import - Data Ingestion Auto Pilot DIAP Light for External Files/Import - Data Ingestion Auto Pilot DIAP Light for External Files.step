{"creationTimeStamp":"2023-05-03T03:10:40.223Z","modifiedTimeStamp":"2023-07-20T19:41:49.812Z","createdBy":"Stephan.Weigandt@sas.com","modifiedBy":"Stephan.Weigandt@sas.com","name":"Import - Data Ingestion Auto Pilot DIAP Light for External Files.step","displayName":"Import - Data Ingestion Auto Pilot DIAP Light for External Files.step","localDisplayName":"Import - Data Ingestion Auto Pilot DIAP Light for External Files.step","properties":{},"links":[{"method":"GET","rel":"self","href":"/dataFlows/steps/14afb059-fb51-4dc7-8980-9b1d95fbcbe8","uri":"/dataFlows/steps/14afb059-fb51-4dc7-8980-9b1d95fbcbe8","type":"application/vnd.sas.data.flow.step"},{"method":"GET","rel":"alternate","href":"/dataFlows/steps/14afb059-fb51-4dc7-8980-9b1d95fbcbe8","uri":"/dataFlows/steps/14afb059-fb51-4dc7-8980-9b1d95fbcbe8","type":"application/vnd.sas.data.flow.step.summary"},{"method":"GET","rel":"up","href":"/dataFlows/steps","uri":"/dataFlows/steps","type":"application/vnd.sas.collection","itemType":"application/vnd.sas.data.flow.step.summary"},{"method":"PUT","rel":"update","href":"/dataFlows/steps/14afb059-fb51-4dc7-8980-9b1d95fbcbe8","uri":"/dataFlows/steps/14afb059-fb51-4dc7-8980-9b1d95fbcbe8","type":"application/vnd.sas.data.flow.step","responseType":"application/vnd.sas.data.flow.step"},{"method":"DELETE","rel":"delete","href":"/dataFlows/steps/14afb059-fb51-4dc7-8980-9b1d95fbcbe8","uri":"/dataFlows/steps/14afb059-fb51-4dc7-8980-9b1d95fbcbe8"},{"method":"GET","rel":"transferExport","href":"/dataFlows/steps/14afb059-fb51-4dc7-8980-9b1d95fbcbe8","uri":"/dataFlows/steps/14afb059-fb51-4dc7-8980-9b1d95fbcbe8","responseType":"application/vnd.sas.transfer.object"},{"method":"PUT","rel":"transferImportUpdate","href":"/dataFlows/steps/14afb059-fb51-4dc7-8980-9b1d95fbcbe8","uri":"/dataFlows/steps/14afb059-fb51-4dc7-8980-9b1d95fbcbe8","type":"application/vnd.sas.transfer.object","responseType":"application/vnd.sas.summary"}],"metadataVersion":0.0,"version":2,"type":"code","flowMetadata":{"inputPorts":[],"outputPorts":[]},"ui":"{\n\t\"showPageContentOnly\": true,\n\t\"pages\": [\n\t\t{\n\t\t\t\"id\": \"Essentials\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"Essentials\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"diap_guided_auto_fl_loc_ui\",\n\t\t\t\t\t\"type\": \"path\",\n\t\t\t\t\t\"label\": \"Provide CSV File that contains detailed DIAP execution instructions (create a template by choosing \\\"3 - Create Guided Automation Control File Template\\\"):\",\n\t\t\t\t\t\"pathtype\": \"file\",\n\t\t\t\t\t\"placeholder\": \"Select CSV file that describes execution (create a template by choosing \\\"3 - Create Guided Automation Control File Template\\\")\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"visible\": [\n\t\t\t\t\t\t\"$DIAP_mode_selection_ui\",\n\t\t\t\t\t\t\"=\",\n\t\t\t\t\t\t\"2\"\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"root_directory_ui\",\n\t\t\t\t\t\"type\": \"path\",\n\t\t\t\t\t\"label\": \"Provide Root Directory (can be from within SAS Server or SAS Content):\",\n\t\t\t\t\t\"pathtype\": \"folder\",\n\t\t\t\t\t\"placeholder\": \"Select Root Directory\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"visible\": [\n\t\t\t\t\t\t\"$DIAP_mode_selection_ui\",\n\t\t\t\t\t\t\"=\",\n\t\t\t\t\t\t\"1\"\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"controlfile_target_location_ui\",\n\t\t\t\t\t\"type\": \"path\",\n\t\t\t\t\t\"label\": \"Target Path for Template Creation (Option 3 or 4):\",\n\t\t\t\t\t\"pathtype\": \"folder\",\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"visible\": [\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\"$DIAP_mode_selection_ui\",\n\t\t\t\t\t\t\t\"=\",\n\t\t\t\t\t\t\t\"4\"\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"|\",\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\"$DIAP_mode_selection_ui\",\n\t\t\t\t\t\t\t\"=\",\n\t\t\t\t\t\t\t\"3\"\n\t\t\t\t\t\t]\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"DIAP_mode_selection_ui\",\n\t\t\t\t\t\"type\": \"radiogroup\",\n\t\t\t\t\t\"label\": \"Select DIAP Execution Mode:\",\n\t\t\t\t\t\"items\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"1\",\n\t\t\t\t\t\t\t\"label\": \"1 - Fully Automated\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"2\",\n\t\t\t\t\t\t\t\"label\": \"2 - Guided Automated Execution via Explicit File List\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"3\",\n\t\t\t\t\t\t\t\"label\": \"3 - Create Guided Automation Control File Template\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"4\",\n\t\t\t\t\t\t\t\"label\": \"4 - Create Fixed Width Control File Template\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"Extension_ui\",\n\t\t\t\t\t\"type\": \"dropdown\",\n\t\t\t\t\t\"label\": \"Extension:\",\n\t\t\t\t\t\"items\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"*\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"XLSX\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"XLSM\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"JMP\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"CSV\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"TXT\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"JSON\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"SHP\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"NEF\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"CUSTOM\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"target_libname_ui\",\n\t\t\t\t\t\"type\": \"textfield\",\n\t\t\t\t\t\"label\": \"Target Libname (CAS or Compute, needs to exist):\",\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"id\": \"General\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"General\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"root_directory_overwrite_ui\",\n\t\t\t\t\t\"type\": \"textfield\",\n\t\t\t\t\t\"label\": \"Provide Root Directory Manually (must be a physical file storage):\",\n\t\t\t\t\t\"placeholder\": \"If provided, this will overwrite Root Directory from Essentials\",\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"diap_traverse_directories_ui\",\n\t\t\t\t\t\"type\": \"radiogroup\",\n\t\t\t\t\t\"label\": \"Traverse Subdirectories?\",\n\t\t\t\t\t\"items\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"1\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"0\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"make_imported_data_persistent_ui\",\n\t\t\t\t\t\"type\": \"radiogroup\",\n\t\t\t\t\t\"label\": \"Make Ingested data persistent?\",\n\t\t\t\t\t\"items\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"1\",\n\t\t\t\t\t\t\t\"label\": \"Yes\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"0\",\n\t\t\t\t\t\t\t\"label\": \"No\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"force_upload_of_all_files_ui\",\n\t\t\t\t\t\"type\": \"radiogroup\",\n\t\t\t\t\t\"label\": \"Force upload of all files, even if already uploaded?\",\n\t\t\t\t\t\"items\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"1\",\n\t\t\t\t\t\t\t\"label\": \"Yes\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"0\",\n\t\t\t\t\t\t\t\"label\": \"No\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"chck_4_spcl_char_in_vars_ui\",\n\t\t\t\t\t\"type\": \"radiogroup\",\n\t\t\t\t\t\"label\": \"Clean up variable name from weird characters (like #, $, !, blanks, etc, ...)?\",\n\t\t\t\t\t\"items\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"1\",\n\t\t\t\t\t\t\t\"label\": \"Yes\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"0\",\n\t\t\t\t\t\t\t\"label\": \"No\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"prefix_4_suspicious_src_fl_ui\",\n\t\t\t\t\t\"type\": \"textfield\",\n\t\t\t\t\t\"label\": \"Provide Filename Prefix added if source file shows flaws:\",\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"id\": \"Source_specific\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"Source Specific\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"skip_files_starting_with_seq_ui\",\n\t\t\t\t\t\"type\": \"textfield\",\n\t\t\t\t\t\"label\": \"Provide list of filename beginnings that should be excluded from ingesting (separated by #):\",\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"skip_files_ending_with_seq_ui\",\n\t\t\t\t\t\"type\": \"textfield\",\n\t\t\t\t\t\"label\": \"Provide list of filename endings that should be excluded from ingesting (separated by #):\",\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"csv_big_data_mode_ui\",\n\t\t\t\t\t\"type\": \"radiogroup\",\n\t\t\t\t\t\"label\": \"Anticipate more than 2k vars for CSV?\",\n\t\t\t\t\t\"items\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"1\",\n\t\t\t\t\t\t\t\"label\": \"Yes\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"0\",\n\t\t\t\t\t\t\t\"label\": \"No\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"check_csv_4_num_ui\",\n\t\t\t\t\t\"type\": \"radiogroup\",\n\t\t\t\t\t\"label\": \"Check character fields in CSV Files for numeric?\",\n\t\t\t\t\t\"items\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"1\",\n\t\t\t\t\t\t\t\"label\": \"Yes\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"0\",\n\t\t\t\t\t\t\t\"label\": \"No\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"check_txt_file_4_special_chrctui\",\n\t\t\t\t\t\"type\": \"radiogroup\",\n\t\t\t\t\t\"label\": \"Check for special characters in text files and replace? (Provide values below)\",\n\t\t\t\t\t\"items\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"1\",\n\t\t\t\t\t\t\t\"label\": \"Yes\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"0\",\n\t\t\t\t\t\t\t\"label\": \"No\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"special_chrctr_seq_2_chck_inhex2\",\n\t\t\t\t\t\"type\": \"textfield\",\n\t\t\t\t\t\"label\": \"Provide list of characters in hex format to check in text files (sep by #):\",\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"visible\": [\n\t\t\t\t\t\t\"$check_txt_file_4_special_chrctui\",\n\t\t\t\t\t\t\"=\",\n\t\t\t\t\t\t\"1\"\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"spcl_chrctr_check_rplcmnt_inhex2\",\n\t\t\t\t\t\"type\": \"textfield\",\n\t\t\t\t\t\"label\": \"Provide characters in hex format to replace with:\",\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"visible\": [\n\t\t\t\t\t\t\"$check_txt_file_4_special_chrctui\",\n\t\t\t\t\t\t\"=\",\n\t\t\t\t\t\t\"1\"\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"id\": \"Target_Specific\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"Target Specific\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"substitute_string_seq_ui\",\n\t\t\t\t\t\"type\": \"textfield\",\n\t\t\t\t\t\"label\": \"Provide Characters to be Omitted in Target Names if too long:\",\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"max_table_length_ui\",\n\t\t\t\t\t\"type\": \"numberfield\",\n\t\t\t\t\t\"label\": \"Max Tablename Length:\",\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"max\": 32,\n\t\t\t\t\t\"min\": 15,\n\t\t\t\t\t\"excludemin\": false,\n\t\t\t\t\t\"excludemax\": false,\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"drop_missing_vars_ui\",\n\t\t\t\t\t\"type\": \"radiogroup\",\n\t\t\t\t\t\"label\": \"Drop Missing Variables?\",\n\t\t\t\t\t\"items\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"0\",\n\t\t\t\t\t\t\t\"label\": \"(0) Keep All\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"1\",\n\t\t\t\t\t\t\t\"label\": \"(1) Drop All\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"2\",\n\t\t\t\t\t\t\t\"label\": \"(2) Drop only vars with missing varnames AND all miss. values\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"3\",\n\t\t\t\t\t\t\t\"label\": \"(3) Same as (1) w/o Upload, Execute Only on Already Uploaded Data\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"4\",\n\t\t\t\t\t\t\t\"label\": \"(4) Same as (2) w/o Upload, Execute Only on Already Uploaded Data.\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"stringseq_2_cutout_from_fn_ui\",\n\t\t\t\t\t\"type\": \"textfield\",\n\t\t\t\t\t\"label\": \"Target Filename: Provide String that Should be Cut Out (sep by #):\",\n\t\t\t\t\t\"placeholder\": \"string1#string2\",\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"stringseq_2_cutout_from_vn_ui\",\n\t\t\t\t\t\"type\": \"textfield\",\n\t\t\t\t\t\"label\": \"Target Variablename: Provide String that Should be Cut Out (sep by #):\",\n\t\t\t\t\t\"placeholder\": \"string1#string2\",\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"diap_create_unique_target_tblnm2\",\n\t\t\t\t\t\"type\": \"radiogroup\",\n\t\t\t\t\t\"label\": \"Create unique final dataset name for different source files/sheets with the same name (in different locations)?\",\n\t\t\t\t\t\"items\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"1\",\n\t\t\t\t\t\t\t\"label\": \"Yes\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"0\",\n\t\t\t\t\t\t\t\"label\": \"No\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"fnl_ds_name_4_all_extfiles_ui\",\n\t\t\t\t\t\"type\": \"textfield\",\n\t\t\t\t\t\"label\": \"If string provided, all external files will be read into ONE table with the name of this string:\",\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"diap_fnl_tblname_from_sheetonly2\",\n\t\t\t\t\t\"type\": \"radiogroup\",\n\t\t\t\t\t\"label\": \"For Multi Table Files (e.g. XLSX, XML, JSON), derive final dataset name from sheet only?\",\n\t\t\t\t\t\"items\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"1\",\n\t\t\t\t\t\t\t\"label\": \"Yes\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"0\",\n\t\t\t\t\t\t\t\"label\": \"No\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"id\": \"Admin\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"Admin\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"meta_centralized_ui\",\n\t\t\t\t\t\"type\": \"radiogroup\",\n\t\t\t\t\t\"label\": \"Store Metadata Centralized?\",\n\t\t\t\t\t\"items\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"1\",\n\t\t\t\t\t\t\t\"label\": \"Yes\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"0\",\n\t\t\t\t\t\t\t\"label\": \"No\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"libname_meta_centralized_ui\",\n\t\t\t\t\t\"type\": \"textfield\",\n\t\t\t\t\t\"label\": \"Libname for Centralized DIAP Metadata:\",\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"visible\": [\n\t\t\t\t\t\t\"$meta_centralized_ui\",\n\t\t\t\t\t\t\"=\",\n\t\t\t\t\t\t\"1\"\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"debug_mode_ui\",\n\t\t\t\t\t\"type\": \"radiogroup\",\n\t\t\t\t\t\"label\": \"Debug Mode?\",\n\t\t\t\t\t\"items\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"1\",\n\t\t\t\t\t\t\t\"label\": \"Yes\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"0\",\n\t\t\t\t\t\t\t\"label\": \"No\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"write_log_into_file_ui\",\n\t\t\t\t\t\"type\": \"radiogroup\",\n\t\t\t\t\t\"label\": \"Write Log into File? (\\\"Yes\\\" will open input field below for path selection)\",\n\t\t\t\t\t\"items\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"1\",\n\t\t\t\t\t\t\t\"label\": \"Yes\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"0\",\n\t\t\t\t\t\t\t\"label\": \"No\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"log_file_path_ui\",\n\t\t\t\t\t\"type\": \"path\",\n\t\t\t\t\t\"label\": \"Path for logfile creation:\",\n\t\t\t\t\t\"pathtype\": \"folder\",\n\t\t\t\t\t\"placeholder\": \"Select directory in SAS Server or SAS Content\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"visible\": [\n\t\t\t\t\t\t\"$write_log_into_file_ui\",\n\t\t\t\t\t\t\"=\",\n\t\t\t\t\t\t\"1\"\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"max_lgth_of_suspicious_str_ui\",\n\t\t\t\t\t\"type\": \"numberfield\",\n\t\t\t\t\t\"label\": \"Max allowed length for Prefix in Filename for suspicious filenames:\",\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"max\": 8,\n\t\t\t\t\t\"min\": 2,\n\t\t\t\t\t\"excludemin\": false,\n\t\t\t\t\t\"excludemax\": false,\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"options_seq_ui\",\n\t\t\t\t\t\"type\": \"textfield\",\n\t\t\t\t\t\"label\": \"Provide options to be applied for this run (only single options allowed like mprint, nosource, etc):\",\n\t\t\t\t\t\"placeholder\": \"mprint source notes\",\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"id\": \"About\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"About\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"text1\",\n\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\"text\": \"DIAP: Data Ingestion Auto Pilot:\\nVersion: 4.1.2\\n\\nIf you have any questions, suggestions, ideas or any unexpected behavior, please contact:\\nstephan.weigandt@sas.com.\\n\\nDIAP allows to ingest (LOTS) of external data into the SAS ecosystem QUICKLY by only setting a few parameters and pushing a button while increasing the quality and confidence into data insights by handlilng many potential data inconistencies automatically. \\n\\nHINTS:\\nONLY set mandatory options in \\\"Essentials\\\" and everything else can be left at default.\\n\\nHere is an overview of the available parameters:\\n\\n### root_directory (In Custom Step Version: \\\"Select DIAP Execution Mode -> (1)\\\")\\n\\nsuggested default value: if there is a default landing area, this could be provided here.\\n\\nprovide the top level directory that DIAP should use to start looking for files. DIAP will then traverse through the whole directory structure and find all the files below this top level directory. \\n\\nIf the root directory is in the SAS Server area, this has to start out with: sasserver: (e.g. example value for root_directory: sasserver:/mnt/desired/path/for/files_to_be_readin/from/SASServer/).\\n\\nIf the root directory is in the SAS Content area, this has to start out with: sascontent: (e.g. example value for root_directory: sascontent:/Public/desired_path_for/files/in/SASContent/).\\n\\n### diap_traverse_directories (In Custom Step Version: \\\"Traverse Subdirectories?\\\")\\n\\nsuggested default value: 1\\n\\nIf set to 1, DIAP traverses through all subdirectories recursively that can be found under root_directory.\\n\\nIf set to 0, DIAP only checks for files in the provided root_directory.\\n\\n### extension (In Custom Step Version: \\\"Extension\\\")\\n\\nsuggested default value: \\\\*\\n\\nThis parameter determines which files are considered to be imported. Use the wildcard “*” (without quotes) for any files that can be ingested by DIAP, or any extension. The following extensions are supported as of now:\\n•\\tXLSX\\n•\\tXLSM\\n•\\tCSV\\n•\\tJMP\\n•\\tSHP\\n•\\tTXT\\n•\\tNEF\\n•\\tJSON\\n•\\tCustom (Fixed Width/XML)\\n\\n### Target_libname (In Custom Step Version: \\\"Target Libname\\\")\\n\\nsuggested default value: any libname, that is used for testing, e.g. WORK.\\n\\nProvide the SAS or CAS libname, where the imported files are stored at. It needs to be preassigned or assigned within the session.\\n\\n\\n### provide_default_log_path (In Custom Step Version: \\\"Path for logfile creation\\\")\\n\\nsuggested default value: empty/missing.\\n\\nThis parameter is only relevant when the parameter “write_log_into_file” is set to 1. \\n\\nProvide a default path for all runs: as soon as a path is provided, this path is being used for ALL runs.\\n\\nIf the log directory is in the SAS Server area, this has to start out with: sasserver: (e.g. example value for provide_default_log_path: sasserver:/mnt/desired/path/for/log_files_to_be_saved/on/SASServer/).\\n\\nIf the log directory is in the SAS Content area, this has to start out with: sascontent: (e.g. example value for provide_default_log_path: sascontent:/Public/desired_path_for/logfiles/in/SASContent/).\\n\\n\\n### write_log_into_file (In Custom Step Version: \\\"Write Log into File\\\") \\n\\nsuggested default value: 1\\n\\nIf set to 0, log is written into default SAS log location.\\n\\nIf set to 1, log is written to location as provided under the parameter “provide_default_log_path”.\\n\\n### max_table_name_length (In Custom Step Version: \\\"Max Tablename Length\\\")\\n\\nsuggested default value: 27\\n\\nThis determines the maximum allowed table name length.  E.g. in the case of uploading XLSX files to SAS94, the final table name is built by concatenating Excel-filename and Sheetname. \\n\\nSo this can easily lead to a datasetname that is too long.\\n\\nAlso take into consideration that the concatenated name for multiple tables could potentially the same in the abbreviated form. \\n\\nThe system checks for that and adds a counter to the table name. \\n\\nSo, leave at least 2 characters for a counter.\\n\\n### check_txt_file_4_special_chrct (In Custom Step Version: \\\"Check for special characters in text files and replace?\\\")\\n\\nsuggested default value: 0\\n\\nIf set to 0, the text file is read in as-is.\\n\\nIf set to 1, then text files is examined before reading for the characthers as outlined in parameter \\\"special_chrctr_seq_2_chck_in_hex\\\", and replaced with the character as outlined in parameter \\\"spcl_chrctr_check_rplcmnt_in_hex\\\".\\nThis might need to be required, especially if files have NOTES or DESCRIPTION columns, that could contain carriage returns. Those carriage returns would then cause the file to be read in with a few errors, wherever those carriage returns occur.\\n\\n### special_chrctr_seq_2_chck_in_hex (In Custom Step Version: \\\"Provide list of characters in hex format to check in text files (sep by #)\\\")\\n\\nsuggested default value: 0A#0D\\n\\nThis parameter has to be set to one or a sequence of # separated hex formats of a character. \\n\\n0A#0D: checks for new line feed (0A) and carriage return (0D)\\n\\nsee asciitable.com for an overview of all characters in hex format.\\n\\n### spcl_chrctr_check_rplcmnt_in_hex (In Custom Step Version: \\\"Provide characters in hex format to replace with\\\")\\n\\nsuggested default value: 00\\n\\nPlease provide the characters that should be used to replace the special characters as defined in special_chrctr_seq_2_chck_in_hex\\nThe characters value is provided in hex format.\\n\\nsee asciitable.com for an overview of all characters in hex format.\\n\\n### substitute_string_seq (In Custom Step Version: \\\"Provide Characters to be Omitted in Target Names if too long!\\\")\\n\\nsuggested default value: aeiouAEIOU\\n\\nIf the target table name is too long, this string determines which characters are taken out from the target name to shorten the name further, before the truncation process kicks in.\\n\\nE.g. when substitute_string_seq = aeAEoO, then a table name of \\\"ThisIsAVeryLongTableNameThatIsTooLong\\\" and a max_table_name_length = 29\\nwould be first changed to the following: \\\"ThisIsVryLngTblNmThtIsTLng\\\" which would be short enough without any further action needed by DIAP.\\n\\n### skip_files_starting_with_seq (In Custom Step Version: \\\"Provide list of filename beginnings that should be excluded from ingesting (separated by #)\\\")\\n\\ndefault value: _DIAP_Special_File_Definition.csv\\nIf not missing, DIAP will skip all the files that start out with the sequence of string snippets separated by #.\\nE.g. if set to:\\n_DIAP_Special_File_Definition.csv#filebe ginning1#filebeginning2\\nAll files that start out with either _DIAP_Special_File_Definition.csv filebeginning1 or filebeginning2 will NOT be ingested.\\n_DIAP_Special_File_Definition.csv is the default value used by DIAP to describe fixed width or XML definitions and wouldn't be needed to be read into the target libname.\\n\\n### skip_files_ending_with_seq (In Custom Step Version: \\\"Provide list of filename endings that should be excluded from ingesting (separated by #)\\\")\\n\\ndefault value: empty/missing\\nIf not missing, DIAP will skip all the files that end with the sequence of string snippets separated by #.\\nE.g. if set to:\\nfile_ending1#file_ending2#csv\\nAll files that end with either file_ending1 or file_ending2 or csv will NOT be ingested.\\nE.g. in this example all csv files would be skipped.\\n\\n### meta_centralized (In Custom Step Version: \\\"Store Metadata Centralized?\\\")\\n\\nsuggested default value: 1\\n\\nThis value goes closely with the next parameter “libname_meta_centralized”. \\n\\nIf set to 1, all meta information generated by DIAP (e.g. data around upload activity, variable name, table names, etc) will be stored in predetermined tables (_UPLOAD_LOG, _VARIABLE_DICTIONARY) under the libname that is provided under “libname_meta_centralized”.  \\n\\nIf set to 0, all meta information generated by DIAP (e.g. data around upload activity, variable name, table names, etc) will be stored in predetermined tables (_UPLOAD_LOG, _VARIABLE_DICTIONARY) under the libname that is provided under “target_libname”.\\n### libname_meta_centralized (In Custom Step Version: \\\"Libname for Centralized DIAP Metadata\\\")\\n\\nPlease provide a libname (SAS or CAS), that can be used as a central storage for the metainformation that is generated for all DIAP activities, when the “meta_centralized” parameter is set to 1.\\n\\nIMPORTANT:\\n\\nIf the Data Quality Monitoring Solution is installed as well and being used with DIAP, then please here the same libname as being used there for the dictionary location.\\n\\n### debug_mode (In Custom Step Version: \\\"Debug Mode\\\")\\n\\nSuggested default value: 1\\n\\nIf set to 1, DIAP writes out more information out to the log, that might be helpful for further investigations.\\n\\nIf set to 0, DIAP just writes out the default SAS log output, depending on the settings of the options mprint, source and notes.\\n\\n### csv_big_data_mode (In Custom Step Version: \\\"Anticipate more than 2k vars for CSV?\\\")\\n\\nsuggested default value: 0.\\n\\nIf set to 0, csv files are read in with default mode (e.g. normal proc import stuff with guessing the format and such).\\n\\nIf set to 1, csv files are read in with the “big data mode”. It can happen that files are provided that contain more than 2000 variables. So when the anticipated number of variables is over 2000, then it is suggested to set this to 1. This will allow to read in the file completely, but the formats might not be in the desired state. DIAP will try to identify numeric columns and change the format for those from character to numeric.\\n\\n### drop_missing_vars (In Custom Step Version: \\\"Drop Missing Variables?\\\")\\n\\nsuggested default value: 0\\n\\nThe following values are possible:\\n\\nIf set to 0, missing variables are NOT dropped.\\n\\nIf set to 1, all variables that have ALL missing variables are dropped.\\n\\nIf set to 2, only variables with missing variables names AND all missing values will be dropped.\\n\\nIf set to 3, the same as setting to (1), but no data is being uploaded. So, when it is set to 3, the already uploaded files are treated accordingly.\\n\\nIf set to 4, the same as setting to (2), but no data is being uploaded. So, when it is set to 3, the already uploaded files are treated accordingly.\\n\\n### stringseq_2_cutout_from_fn (In Custom Step Version: \\\"Target Filename: Provide String that Should be Cut Out (sep by #)\\\")\\n\\nsuggested default value: empty/missing.\\n\\nProvide a sequence of characters strings that should be omitted in the target filename.This prevents the target table name of getting too long.\\n\\nThe sequence is separated by #\\n\\n### stringseq_2_cutout_from_vn (In Custom Step Version: \\\"Target Variablename: Provide String that Should be Cut Out (sep by #)\\\")\\n\\nsuggested default value: empty/missing.\\n\\nProvide a sequence of characters strings that should be omitted in the target variable name. This  prevents the variable table name of getting too long.\\n\\nThe sequence is separated by #.\\n\\n### prefix_4_suspicious_src_fl (In Custom Step Version: \\\"Provide Filename Prefix if source file is suspicious.\\\")\\n\\nsuggested default value: empty/missing.\\n\\nA string can be provided (max of length LEN as provided in parameter “wof2l_max_lgth_of_suspicious_str”), that will be added and replace the first LEN characters of the table name, if the content seems suspicious.\\n\\nThis would then suggest to check on the source file to understand what is going on.\\n\\nPossible causes for suspicion:\\n-\\tMissing variable names\\n-\\tDuplicate variable names\\n-\\tIf variables are completely missing.\\n\\n### max_lgth_of_suspicious_str (In Custom Step Version: \\\"Max allowed length for Prefix in Filename for suspicious filenames.\\\")\\n\\nsuggested default value: 4\\n\\nThis parameter determines the maximum length of an allowed prefix for suspicious files.\\n\\n### check_csv_4_num (In Custom Step Version: \\\"Check character fields in CSV Files for numeric?\\\")\\n\\nsuggested default value: 0\\n\\n0 (default): this means csv file is read in as-is \\n1: in cases when it is a \\\"quoted\\\" csv files (e.g. happens when come of the content contains the separator), then when this is turned on, the process will perform an additional check on the data that was read in to check of some of the variables that were read in as character actually should be numeric.\\n\\n### force_upload_of_all_files (In Custom Step Version: \\\"Force upload of all files, even if already uploaded?\\\")\\n\\nsuggested default value: 0\\n\\n0 (default): Files are only uploaded if they were updated since last upload\\n1: All files are uploaded no matter if they were uploaded before or not. No date check happening with this option.\\n\\n### diap_fnl_tblname_from_sheetonly (In Custom Step Version: \\\"For Multi Table Files (e.g. XLSX, XML, JSON), derive final dataset name from sheet only?\\\")\\n\\nsuggested default value: 0\\n\\n0 (default): The final dataset name is determined using the filename AND the sheetname (same principles are applied for XLSX, JSON and XML files).\\n1: The final dataset name is determined using ONLY the sheetname (same principles are applied for XLSX, JSON and XML files), ignoring the filename.\\n\\n### diap_create_unique_target_tblnm (In Custom Step Version: \\\"Create unique final dataset name for different source files/sheets with the same name (in different locations)?\\\")\\n\\nsuggested default value: 1\\n\\n0 : when creating the final dataset name, and the final dataset name ends up being the same for 2 or more source files, then DIAP will try to append all those different source files into one target dataset.\\n1 (default): when creating the final dataset name, and the final dataset name ends up being the same for 2 or more source files, then DIAP will add a unique counter to the final dataset name, so that the content of each source file is written in its own final dataset.\\n\\n### chck_4_spcl_char_in_vars (In Custom Step Version: \\\"Clean up variable name from weird characters?\\\")\\n\\nsuggested default value: 1\\n\\n0 : variable names are only checked for minimal \\\"weird\\\" characters (like: &, ', \\\", %, #, ','). With this, option validvarname =any has to be set when wanting to work/see dataset from SAS Studio.\\n1 (default): all weird characters are replace with underscore (_) to create a clean variable name.\\n\\n### fnl_ds_name_4_all_extfiles (In Custom Step Version: \\\"If string provided, all external files will be read into ONE table with the name of this string.\\\")\\n\\nsuggested default value: blank(keep empty)\\n\\nif this field is non blank, then the string provided with this macrovariables is used as the target table name and DIAP will try to combine all external files that are read in, into this one table. \\n\\nThis table will be created (or if existent already, all the new data appended) in the provided target libname. \\n\\nMaximum characters allowed are 32.\\n\\nIf a string/tablename is set here, the setting of diap_create_unique_target_tblnm is ignored.\\n\\n### ONLY AVAILABLE IN CUSTOM STEP: \\\"Select DIAP Execution Mode\\\"\\n\\nThere are 4 execution modes available:\\n- (1) Fully Automated\\n- (2) Guided Automated Execution via Explicit File List (using specific structured CSV file)\\n- (3) Create Guided Automation Control File Template\\n- (4) Create Fixed Width Control File Template\\n\\nIf (3) is selected: The name of the file created in the selected directory is: \\\"_DIAP_guided_execution.csv\\\".\\nIf (4) is selected: The name of the file created in the selected directory is: \\\"_DIAP_Special_File_Definition.csv\\\".\\n\\nWhen (3) or (4) is selected, as a next step please download the template csv files on your local machine for customized settings of the fields.\\n\\nThe provided content that is created in the template is merely an example and SHOULD be deleted and replaced with the settings needed to read in fixed with files or xml files (with defintion files).\\n\\nThen upload the customized CSV files to the server, so that DIAP can process them accordingly.\\n\\n### diap_guided_automation_fl_loc (In Custom Step Version: \\\"Select DIAP Execution Mode -> (2)\\\")\\n\\nsuggested default value: blank (keep empty)\\n\\nIf this parameter is NOT empty, DIAP will try to read instructions from this file and will ignore any settings in root_directory. \\n\\nThis path can point to a file under SAS Server or under SAS Content.\\nDepending on where it is located, the provided path has to look like the following:\\n - if located under SAS SERVER: sasserver:/specific/path/to/file/under/sasserver/guided_execution_instructions.csv\\n - if located under SAS CONTENT: sascontent:/specific/path/to/file/under/sascontent/guided_execution_instructions.csv\\n\\nThe specific structure of the CSV file is described here (or select (3) as execution mode to create a template dynamically): \\n[Structure of Guided Automated Execution CSV File](#testfile-overview---specifics). \\n\\n## Control Files Overview\\n### The Guided Execution: _DIAP_guided_execution.csv\\n\\nThis template file can be created by choosing the execution mode #3.\\nIt is a file that could be used to send ingesting instructions to DIAP on which files to read in how.\\n\\nAll files listed in here will be worked through by DIAP. This allows for a controlled automated ingestion process of external files.\\n\\nThis mode also allows to read in external files that are located in the \\\"SAS Content\\\" area(only delimited text files and XLSX files).\\n\\nPlease fill in the information for each column as follows:\\n\\n#### Column: full_file_name\\n\\nPlease provide the full pathname and filename here.\\nExample:\\nunder SAS Server: /mnt/myuserid/excel_files/my_excel_file.xlsx\\nunder SAS Content: /Public/My_Project/csv_files/my_csv_file_in_SAS_Content.csv\\n\\n#### Column: sheet_xml_json_tablename\\n\\nThis only applies Excel, XML or JSON files. Provide the explicit sheet name to read in.\\nE.g. in an Excel file, there could be many sheets to be available. Each sheet that needs to be ingested needs to be explicitly named, e.g. if there are 5 sheets to be read in from one Excel file, there needs to be one row for each sheet, e.g. a total of 5 rows with the same full_file_name.\\n\\n#### Column: is_in_SAS_Content_flag\\n\\nThis binary flag indicates if the path that is provided under the column full_file_name is located in the \\\"SAS Server\\\" area or the \\\"SAS Content\\\" area. \\n\\nIt is a binary indicator, hence 2 values are allowed: 1 or 0.\\n\\nSet this column to:\\n- 1: Setting this column to 1 means DIAP will look for the file provided in full_file_name in the \\\"SAS Content\\\" area of the VIYA installation.\\n- 0: Setting this column to 0 means DIAP will look for the file provided in full_file_name in the \\\"SAS Server\\\" area of the VIYA installation. (This is also the default value assumed if missing)\\n\\n#### Column: column_names_in_first_row\\n\\nThis binary indicator tells DIAP if the first row of a text file provides the column names. \\n\\nIt is recommended to set this value to 1 for all the entries in this file, and only set it to 0 for those entries where the data provided in text files starts in the first row.\\n\\nIf missing, DIAP assumes a value of 1.\\n\\n#### Column: delimiter_for_text_files\\n\\nThis column can be left empty if DIAP should determine the delimiter of a text file automatically. \\nAt this point DIAP determines one of the following delimiter automatically:\\n- comma\\n- semicolon\\n- tab\\n- pipe\\n- exclamation mark\\n- hash\\n- blank\\n\\nIf there are other delimiters it is recommended to provide the delimiter explicitly in this column.\\nThe following values are used as follows:\\n- blank: This sets the delimiter to be a space/blank: \\\" \\\"\\n- comma: This sets the delimiter to be a comma: \\\",\\\"\\n- semicolon: This sets the delimiter to be a semicolon: \\\";\\\"\\n- exclamation: This sets the delimiter to be a semicolon: \\\"!\\\"\\n- hash: This sets the delimiter to be a semicolon: \\\"#\\\"\\n- tab: This sets the delimiter to be a tab: '09'x\\n- pipe: This sets the delimiter to be a pipe: \\\"|\\\"\\nAny other entries than the 5 keywords above will be taken as the delimiter.\\n\\n#### Column: target_table_name\\n\\nThis column can be left empty. If empty, DIAP will automatically determine the table name according to the filename and sheetname if applicable.\\nOther conditions set in the other parameters (e.g. maximum table name length and substitute_string_seq) will be applied also to table names provided in this column.\\n\\n### Control File to Read In Fixed Width Files:_DIAP_Special_File_Definition.csv\\n\\nThis is a specific file that is used and looked for by DIAP as the first course of action.\\nIf this file \\\"_DIAP_Special_File_Definition.csv\\\" is found anywhere under the selected root directory, all the files in there are processed first according to the specific instructions as outlined in that file.\\n\\nThis file is used to specify specific external files like \\\"fixed width\\\" files or \\\"XML\\\" files. \\nAt this point it is not possible to discover the file definition automatically for those kind of files, but need to be provided via this file.\\n\\nThere are a few shortcuts that will be outlined in the following column definition. \\n\\nFor the fixed-width files, the specific definitions have to be manually provided as described in the following column descriptions.\\n\\nHence for a successful execution, this file needs to be adjusted before first usage. \\n\\n#### Column: directory\\n\\nPlease provide the directory information according to your installation where the test files were copied to.\\n \\nDIAP will choose the entries depending on the selected root directory.\\n\\n#### Column: filename\\n\\nProvide the full filename, or part of the filename.\\nIf only part of the filename is provided (e.g. if the directory contains the files \\\"fixed_file1.txt\\\" and \\\"fixed_file2.txt\\\", and only \\\"fixed\\\" (without the quotes) is put into that field), then all files that start out with \\\"fixed\\\" would be read in accordingly, so in the provided example, both files are read in the same way. \\n\\n#### Column: include_fn_in_table_output\\n\\nIf this is set to 1, there will be an additional variable created in the target table named \\\"_diap_gen_source_file_name\\\" that contains the original filename.\\nIf this is set to 0, no additional variable is created.\\n\\n#### Column: file_type\\n\\nAt this point there are 2 options:\\n\\n(1) fix: This tells DIAP that this entry is a fixed width file definition.\\n(2) xml: This tells DIAP that this entry is a xml file definition.\\n\\n#### Column: variable_name\\n\\nIf the file_type is fix, this can be any variable name for that specific entry.\\nIf the file_type is xml, this needs to match one of the entries in the corresponding xml file. \\n\\n#### Column: variable_label\\n\\nPlease provide any variable label for that entry.\\n\\n#### Column: variable_type\\n\\nPlease provide the variable type for that entry. \\nAllowed values are:\\n(1) char\\n(2) num \\n\\n#### Column: variable_length\\n\\nPlease provide the variable length for that specific entry.\\n\\n#### Column: variable_format\\n\\nPlease provide the SAS Format that should be used for that specific entry.\\n\\n#### Column: variable_informat\\n\\nPlease provide the SAS Informat that should be used for that specific entry.\\n\\n#### Column: variable_start_position\\n\\n(1) For the variable type \\\"fix\\\": This is the exact start position of that entry where DIAP will start reading in the value.\\n(2) For the variable type \\\"xml\\\": This is the order in how the variable occurs in the file. Most important is that the last variable that is defined within each block MUST have the highest order number.  \\n\\n#### Column: variable_end_position\\n\\n(1) For the variable type \\\"fix\\\": This is the exact end position of that entry where DIAP will start reading in the value.\\n(2) For the variable type \\\"xml\\\": This is the order in how the variable occurs in the file. Most important is that the last variable that is defined within each block MUST have the highest order number. This matches the entry of the column \\\"variable_start_position\\\".\\n\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t],\n\t\"syntaxversion\": \"1.3.0\",\n\t\"values\": {\n\t\t\"diap_guided_auto_fl_loc_ui\": \"\",\n\t\t\"root_directory_ui\": \"\",\n\t\t\"controlfile_target_location_ui\": \"\",\n\t\t\"DIAP_mode_selection_ui\": {\n\t\t\t\"value\": \"1\",\n\t\t\t\"label\": \"1 - Fully Automated\"\n\t\t},\n\t\t\"Extension_ui\": {\n\t\t\t\"value\": \"*\"\n\t\t},\n\t\t\"target_libname_ui\": \"work\",\n\t\t\"root_directory_overwrite_ui\": \"\",\n\t\t\"diap_traverse_directories_ui\": {\n\t\t\t\"value\": \"1\"\n\t\t},\n\t\t\"make_imported_data_persistent_ui\": {\n\t\t\t\"value\": \"1\",\n\t\t\t\"label\": \"Yes\"\n\t\t},\n\t\t\"force_upload_of_all_files_ui\": {\n\t\t\t\"value\": \"0\",\n\t\t\t\"label\": \"No\"\n\t\t},\n\t\t\"chck_4_spcl_char_in_vars_ui\": {\n\t\t\t\"value\": \"1\",\n\t\t\t\"label\": \"Yes\"\n\t\t},\n\t\t\"prefix_4_suspicious_src_fl_ui\": \"\",\n\t\t\"skip_files_starting_with_seq_ui\": \"\",\n\t\t\"skip_files_ending_with_seq_ui\": \"\",\n\t\t\"csv_big_data_mode_ui\": {\n\t\t\t\"value\": \"0\",\n\t\t\t\"label\": \"No\"\n\t\t},\n\t\t\"check_csv_4_num_ui\": {\n\t\t\t\"value\": \"0\",\n\t\t\t\"label\": \"No\"\n\t\t},\n\t\t\"check_txt_file_4_special_chrctui\": {\n\t\t\t\"value\": \"0\",\n\t\t\t\"label\": \"No\"\n\t\t},\n\t\t\"special_chrctr_seq_2_chck_inhex2\": \"0A#0D\",\n\t\t\"spcl_chrctr_check_rplcmnt_inhex2\": \"00\",\n\t\t\"substitute_string_seq_ui\": \"aeioAEOI\",\n\t\t\"max_table_length_ui\": 27,\n\t\t\"drop_missing_vars_ui\": {\n\t\t\t\"value\": \"0\",\n\t\t\t\"label\": \"(0) Keep All\"\n\t\t},\n\t\t\"stringseq_2_cutout_from_fn_ui\": \"\",\n\t\t\"stringseq_2_cutout_from_vn_ui\": \"\",\n\t\t\"diap_create_unique_target_tblnm2\": {\n\t\t\t\"value\": \"1\",\n\t\t\t\"label\": \"Yes\"\n\t\t},\n\t\t\"fnl_ds_name_4_all_extfiles_ui\": \"\",\n\t\t\"diap_fnl_tblname_from_sheetonly2\": {\n\t\t\t\"value\": \"0\",\n\t\t\t\"label\": \"No\"\n\t\t},\n\t\t\"meta_centralized_ui\": {\n\t\t\t\"value\": \"0\",\n\t\t\t\"label\": \"No\"\n\t\t},\n\t\t\"libname_meta_centralized_ui\": \"Public\",\n\t\t\"debug_mode_ui\": {\n\t\t\t\"value\": \"0\",\n\t\t\t\"label\": \"No\"\n\t\t},\n\t\t\"write_log_into_file_ui\": {\n\t\t\t\"value\": \"0\",\n\t\t\t\"label\": \"No\"\n\t\t},\n\t\t\"log_file_path_ui\": \"\",\n\t\t\"max_lgth_of_suspicious_str_ui\": 3,\n\t\t\"options_seq_ui\": \"\"\n\t},\n\t\"promptHierarchies\": []\n}","templates":{"SAS":"/******************************************************************************\n                                        %adjust_option_setings_controlled\n                                        ________\nHelps to maintain option changes in a program flow.\n______________________________________________________________________________\n\nUSAGE:                         %adjust_option_setings_controlled(aosc_option_seq = ,\n                                                        aosc_temp_option_storage_ds = ,\n                                                        aosc_running_mode = ,\n                                                        aosc_validvarname_setting =\n                                                        )\n______________________________________________________________________________\n\nDESCRIPTION:\n\nWhen option changes occur (only single word options allowed), then this macro\nhelps to maintain the original option setting, so at the end, the system can\nrevert back to the original settings.\n______________________________________________________________________________\n\nINPUT PARAMETERS AND KEYWORDS:\n\n    aosc_option_seq                    This can be a blank separated list of single word\n                                    SAS options (e.g. like: source, notes, etc...).\n                                    If empty nothing happens in CHANGE mode.\n    aosc_temp_option_storage_ds     provide the full dataset name (e.g. work._aosc_setting_storage)\n                                    where the original option values (of the ones that are\n                                    provided in AOSC_OPTION_SEQ) are stored.\n    aosc_running_mode                2 modes available:\n                                    CHANGE: takes settings from AOSC_OPTION_SEQ and applies\n                                            those\n                                    RESET: if AOSC_TEMP_OPTION_STORAGE_DS exists, this mode\n                                            will set options back according to content of\n                                            this dataset.\n    aosc_validvarname_setting         if not blank, validvarname will be set to the value\n                                    as provided with this parameter\n_________________________________________________________________________\n\nCALLS: none.\n______________________________________________________________________________\n\nNOTES: (Initials, date, summary)\n\nStephan Weigandt    20220922  First officially Released Version\n______________________________________________________________________________\n\n*******************************************************************************/\n\n%macro adjust_option_setings_controlled(\n    aosc_option_seq = ,\n    aosc_temp_option_storage_ds = work._aosc_temp_option_storage_ds,\n    aosc_running_mode = ,\n    aosc_validvarname_setting =\n    );\n\n\n    %if %upcase(\"&aosc_running_mode\") = \"CHANGE\" %then\n    %do;\n        data &aosc_temp_option_storage_ds;\n            length\n                new_setting $24.\n                original_setting $24.\n                new_single_setting_seq $256.\n                ;\n            new_setting = \"\";\n            original_setting = \"\";\n            new_single_setting_seq = \"\";\n            numberofsettings = 0;\n            additional_option_setting = 0;\n            if 0;\n        run;\n\n        %if \"&aosc_option_seq\" ne \"\" or\n            \"&aosc_validvarname_setting\" ne \"\" %then\n        %do;\n            data &aosc_temp_option_storage_ds;\n                length\n                    new_setting $24.\n                    original_setting $24.\n                    new_single_setting_seq $256.\n                    ;\n                new_single_setting_seq = strip(\"&aosc_option_seq\");\n                %if \"&aosc_validvarname_setting\" ne \"\" %then\n                %do;\n                    original_setting = getoption(\"validvarname\");\n                    additional_option_setting = 1;\n                    new_setting = \"&aosc_validvarname_setting\";\n                    output;\n                    call execute(\"option validvarname = \"||new_Setting||\";\");\n                %end;\n                %if \"&aosc_option_seq\" ne \"\" %then\n                %do;\n                    numberofsettings = kcountc(new_single_setting_seq, \" \") + 1;\n                    additional_option_setting = 0;\n                    do i = 1 to numberofsettings;\n                        new_setting = \"\";\n                        new_setting = kscan(new_single_setting_seq, i, \" \");\n                        if not missing(new_setting) then\n                        do;\n                            original_setting = getoption(new_setting);\n                            output;\n                            call execute(\"option \"||new_Setting||\";\");\n                        end;\n                    end;\n                %end;\n            run;\n        %end;\n    %end;\n\n    %if %upcase(\"&aosc_running_mode\") = \"RESET\" %then\n    %do;\n        %if %sysfunc(exist(&aosc_temp_option_storage_ds)) %then\n        %do;\n            data _null_;\n                set &aosc_temp_option_storage_ds;\n                if additional_option_setting = 1 then\n                do;\n                    call execute(\"option validvarname = \"||original_setting||\";\");\n                end; else\n                do;\n                    call execute(\"option \"||original_setting||\";\");\n                end;\n            run;\n        %end;\n    %end;\n%mend adjust_option_setings_controlled;\n\n/** FOR TESTING ***\noption nomprint nosource notes ;\n%let option_seq = mprint notes source;\n%let running_mode = CHANGE;\n%let validvarname_setting = any;\n\n%put PRECHANGE;\n%put VALIDVARNAME: %sysfunc(getoption(validvarname));\n%put SOURCE: %sysfunc(getoption(source));\n%put NOTES: %sysfunc(getoption(notes));\n%put MPRINT: %sysfunc(getoption(mprint));\n\n%adjust_option_setings_controlled(\n    aosc_option_seq = &option_seq,\n    aosc_running_mode = &running_mode,\n    aosc_validvarname_setting = &validvarname_setting\n    );\n\n%put POSTCHANGE;\n%put VALIDVARNAME: %sysfunc(getoption(validvarname));\n%put SOURCE: %sysfunc(getoption(source));\n%put NOTES: %sysfunc(getoption(notes));\n%put MPRINT: %sysfunc(getoption(mprint));\n\n\n%let running_mode = RESET;\n\n%adjust_option_setings_controlled(\n    aosc_running_mode = &running_mode\n    );\n\n%put POSTRESET;\n%put VALIDVARNAME: %sysfunc(getoption(validvarname));\n%put SOURCE: %sysfunc(getoption(source));\n%put NOTES: %sysfunc(getoption(notes));\n%put MPRINT: %sysfunc(getoption(mprint));\n\n\n\n*********************/\n\n/**\nstore current SAS options settings, so they can be reset\nat the end of processing\n**/\n\n%adjust_option_setings_controlled(\n    aosc_option_seq = &options_seq_ui,\n    aosc_running_mode = CHANGE,\n    aosc_validvarname_setting = any\n    );\n\n%let diap_delimiter = ;\n%macro set_os_dependent_values(\n    sodv_delimiter = diap_delimiter\n    );\n    %if %upcase(&SYSSCP) = WIN %then\n    %do;\n        %let &sodv_delimiter = \\;\n    %end; %else\n    %do;\n        %let &sodv_delimiter = /;\n    %end;\n%mend set_os_dependent_values;\n%set_os_dependent_values(\n    sodv_delimiter = diap_delimiter\n    );\n/******************************************************************************\n\t\t\t\t01_default_setting_wrapper_import_files_into_viya.sas\n                          Default settings for \n                        wrapper_import_files_into_viya.sas \n                                       ________\n\n\n This is part of DIAP.\n\n\n ______________________________________________________________________________\n\n\n USAGE:       Please follow DIAP usage guide.\n\n ______________________________________________________________________________\n\n DESCRIPTION:\n\n   This contains all the default settings for DIAP.\n\n ______________________________________________________________________________\n\n\n INPUT PARAMETERS AND KEYWORDS:\n\n root_directory: \n\t\tprovide the root directory to start checking for\n extension: \n\t\tuse wildcard for any files (*) or a specific one as outlined above\n target_libname: \n\t\tprovide SAS or CAS libname, needs to be preassigned, or assigned \n\t\twithin the session\n\n \n\n ______________________________________________________________________________\n\n NOTES: (Initials, date, summary)\n\n Stephan Weigandt     \t20200406\tFirst officially Released Version \n Stephan Weigandt     \t20200420\tadded functionality and fixes \n Stephan Weigandt\t\t20210326\tcreate dynamic include statement depending on install location\n ______________________________________________________________________________\n\n*******************************************************************************/\n/* option validvarname = any; */\n%let root_directory = /mnt/downloads/ZZ_Testing/top_folder/fixed_width/;\n%let extension = *;\n%let target_libname = ZZ_Tstng;\n%let target_libname = work;\n%let diap_traverse_directories = 1;\n/**\nwifiv_write_log_into_file: \n\tset to 1 if the log should be written out into a file.\n\tset to 0 if the log should go to the default output (e.g. log windows).\nwifiv_provide_default_log_path:\n\tleave empty, then the log is written to a file which is created in the provided top level directory.\n\tprovide a default path for all runs: as soon as a path is provided, this path is being used for ALL runs.\n**/\n\n%let provide_default_log_path = /mnt/downloads/production_code/Logs_of_Runs/;\n%let write_log_into_file = 1;\n\n/*****\nprofiling_execution_option:\nSelect between the following 3 options:\nNO: this is the default, in case the AUTOPROFILING component is not installed, or it is not desired \n\tto execute anything into the AUTOPROFILING section.\nDICT_ONLY:\n\tin this mode, all the uploaded table are only loaded into the profiling dictionary, ready to be p\n\tprofiled, but no profliling is executed.\nPROFILE:\n\tthis option creates some default dictionary entries and also creates the corresponding profiles.\n\nprfl_dict_lctn_in_content_area:\n\tIMPORTANT: LEAVE EMPTY IF CDQM(Data Quality Management System) IS NOT INSTALLED. Then DIAP will\n\t\t\tignore \"profiling_execution_option\" parameter.\n\tIf installed: provide path to dictionary area (must be in SAS CONTENT area, otherwise please\n\tcontact DIAP developement team)\nprfl_cd_lctn_in_content_area\n\tIf CDQM is installed, provide path to code/program area (must be in SAS CONTENT area, otherwise please \n\tcontact DIAP developement team) \n*****/\n\n%let profiling_execution_option = No;\n%let prfl_cd_lctn_in_content_area = /Public/DM_Assets/SAS_DQ_AUTOPROFILE/Programs;\n%let prfl_dict_lctn_in_content_area = /Public/DM_Assets/SAS_DQ_AUTOPROFILE/Imports;\n%let prfl_cd_lctn_in_content_area = ;\n%let prfl_dict_lctn_in_content_area = ;\n\n/******\npath_2_python_shape_script\n\t\tif missing, the app uses the SAS way to read in SHAPE files, otherwise this\n\t\tis the full file path to the python script (which would also include setting up the \n\t\tpython environment).\n******/\n\n%let path_2_python_shape_script = /mnt/viyashare/tools/run_shapeshift.sh;\n%let path_2_python_shape_script = ;\n\n/****\nmax_table_name_length:\nthis determines the maximum allowed table name length. \nE.g. in the case of uploading XLSX files to SAS94, the final table name\nis built by concatenating Excel-filename and Sheetname. \nSo this can easily lead to a datasetname that is too long.\nAlso take into consideration that the concatenated name for multiple tables could \npotentially the same in the abbreviated form. \nThe system checks for that and adds a counter to the table name. \nSo leave at least 2 characters for a counter.\n****/\n\n%let max_table_name_length = 27;\n\n\n/****\ncheck_txt_file_4_special_chrct\ndefault value: 0\n\t0: read text files in as-is\n\t1: before reading in, check text files for special characters within quotes as provided in special_chrctr_seq_2_chck_in_hex and replace\n\t\twith character as provided in spcl_chrctr_check_rplcmnt_in_hex\n\nspecial_chrctr_seq_2_chck_in_hex\ndefault value: 0A#0D\nthis is only used when parameter check_txt_file_4_special_chrct is set to 1\nPlease provide special character in a #-delimited sequence in hex format.\nExample:\n0A#0D: checks for new line feed (0A) and carriage return (0D)\nsee asciitable.com\n\nspcl_chrctr_check_rplcmnt_in_hex\ndefault value: 00\nPlease provide the characters that should be used to replace the special characters as defined in special_chrctr_seq_2_chck_in_hex\nThe characters value is provided in hex format.\n****/\n\n%let check_txt_file_4_special_chrct = 0;\n%let special_chrctr_seq_2_chck_in_hex = 0A#0D;\n%let spcl_chrctr_check_rplcmnt_in_hex = 00;\n\n\n/****\nskip_files_starting_with_seq\ndefault value: \n\tif not missing, DIAP will skip all the files that start out with the sequence of string snippets\n\tseparated by #. \nE.g. if set to:\nfilebeginning1#filebeginning2\nAll files that start out with either filebeginning1 or filebeginning2 will NOT be ingested.\n\nskip_files_ending_with_seq\n\tif not missing, DIAP will skip all the files that end out with the sequence of string snippets\n\tseparated by #. \nE.g. if set to:\nfile_ending1#file_ending2#csv\nAll files that end with either file_ending1 or file_ending2 or csv will NOT be ingested.\nE.g. in this example all csv files will be skipped.\n\n****/\n\n%let skip_files_starting_with_seq = _DIAP_Special_File_Definition.csv;\n%let skip_files_ending_with_seq = ;\n\n/****\nsubstitute_string_seq:\nIf the target table name is too long, this string determines which \ncharacters are taken out from the targeet name to shorten the name further, \nbefore the truncation process kicks in.\nE.g. when substitute_string_seq = aeAEoO\nthen a table name of \n\"ThisIsAVeryLongTableNameThatIsTooLong\" and a \nmax_table_name_length = 29\nwould be first changed to the following:\n\"ThisIsVryLngTblNmThtIsTLng\" which would be short enough\n****/\n\n%let substitute_string_seq = aeiouAEIOU;\n\n%let meta_centralized = 1;\n%let libname_meta_centralized = DM_DtMrt;\n%let libname_meta_centralized = Public;\n\n%let debug_mode = 1;\n\n/**************\nPlease change all parameters above this section as needed.\nSee the meaning of the keywords in the headersection.\nDon't change anything below this section!!\nSet below values to missing if DIAP is executed in 94 environment\n***************/\n\n%let shp_enrich_with_zip = 0;\n\n%let _DIAP_CASHOST_ = controller.viya.sas;\n%let _DIAP_CASPORT_ = 5570;\n%let DIAP_viyaversion = 35;\n%let _DIAP_CASPORT_ = ;\n%let _DIAP_CASHOST_ = ;\n%let DIAP_viyaversion = ;\n\n\n/*****\ncsv_big_data_mode\n\t0: read in with default mode (normal proc import stuff)\n\t1: in big data mode, for anticipated number of variables greater than 2000+, depending of the vector gets bigger than 32k\n*****/\n\n%let csv_big_data_mode = 0;\n\n\n/*****\nmake_imported_data_persistent\n\t0: imported data is only written to memory (promoted)\n\t1: imported data is written to memory (promoted) and also written to disk (persistent)\n*****/\n\n%let make_imported_data_persistent = 1;\n\n/****\ndrop_missing_vars:\n\t0: Don't Drop Missing Variables.\n\t1: Drop ALL Variables with ALL missing values.\n\t2: Drop only vars with miss. varnames AND all miss. values.\n\t3: Same as (1), without uploading data.\n\t4: Same as (2), without uploading data.\n*****/\n\n%let drop_missing_vars = 0;\n\n/****\nstringseq_2_cutout_from_fn\nstringseq_2_cutout_from_vn\n\tfor both parameters: provide a sequence of characters strings that should be either \n\tomitted in the target filename, or the target variable name.\n\tThe sequence is separated by #\n*****/\n\n%let stringseq_2_cutout_from_fn = ;\n%let stringseq_2_cutout_from_vn = ;\n\n/********\n\tprefix_4_suspicious_src_fl\n\t\there a string can be provided (max of length LEN as provided in parameter wof2l_max_lgth_of_suspicious_str), that will be added and replace\n\t\tthe first LEN characters of the table name, is the content seems suspicious and suggests to check on the source file\n\tmax_lgth_of_suspicious_str\n\t\tthe max length is set to 4 by default\n \n*********/\n\n%let prefix_4_suspicious_src_fl=;\n%let max_lgth_of_suspicious_str=4;\n\n/******\n\tcheck_csv_4_num\n\t\t0 (default): this means csv file is read in as-is\n\t\t1: in cases when it is a \"quoted\" csv files (e.g. happens when come of the content contains the separator), then when this is \n\t\t\tturned on, the process will perform an andditional check on the data that was read in to check of some of the variables that\n\t\t\twere read in as character actually should be numeric.\n*****/\n\n%let check_csv_4_num = 0;\n\n/******\n\tforce_upload_of_all_files\n\t\t0 (default): Files are only uploaded if they were updated since last upload\n\t\t1: All files are uploaded independent if they were uploaded before or not. No date check happening with this option.\n*****/\n\n%let force_upload_of_all_files = 0;\n\n/******\n\tdiap_fnl_tblname_from_sheetonly\n\t\t0 (default): The final dataset name is determined using the filename AND the sheetname (same principles are applied for\n\t\t\t\t\tXLSX, JSON and XML files).\n\t\t1: The final dataset name is determined using ONLY the sheetname (same principles are applied for\n\t\t\t\t\tXLSX, JSON and XML files), ignoring the filename.\n*****/\n\n%let diap_fnl_tblname_from_sheetonly = 0;\n\n/******\n\tdiap_create_unique_target_tblnm\n\t\t0 : when creating the final dataset name, and the final dataset name ends up being the same for 2 or more source files, \n\t\t\tthen DIAP will try to append all those different source files into one target dataset.\n\t\t1 (default): when creating the final dataset name, and the final dataset name ends up being the same for 2 or more source files, \n\t\t\tthen DIAP will add a unique counter to the final dataset name, so that the content of each source file is written in its\n\t\t\town final dataset.\n*****/\n\n%let diap_create_unique_target_tblnm = 1;\n\n/******\n\tchck_4_spcl_char_in_vars\n\t\t0 : variable names are only checked for minimal \"weird\" characters (like: &, ', \", %, #, ','). With this, option validvarname =any has to be set\n\t\t\twhen wanting to work/see dataset from SAS Studio. \n\t\t1 (default): all weird characters are replace with underscore (_) to create a clean variable name.\n*****/\n\n%let chck_4_spcl_char_in_vars = 1;\n\n/******\n\tfnl_ds_name_4_all_extfiles\n\t\tif this field is non blank, then the string provided with this macrovariables is used as the target table name and DIAP will try to \n\t\tcombine all external files that are read in, into this one table. \n\t\tThis table will be created (or if existent already, all the new data appended) in the provided target libname.\n\t\tMaximum characters allowed are 32.\n\t\n\t\tIf a string/tablename is set here, the setting of diap_create_unique_target_tblnm is ignored.\n*****/\n\n%let fnl_ds_name_4_all_extfiles = ;\n\n\n/******\n\tdiap_guided_automation_fl_loc\n\t\tif this field is blank files that need to be uploaded are discovered automatically by traversing through all the directories\n\t\tthat can be found under the root directory.\n\t\n\t\tOtherwise please provide the full path starting out either with \"SASSERVER:\" if the file is located on the sasserver, or with \n\t\t\"SASCONTENT:\" if the file is located in SAS Content.\n*****/\n\n%let diap_guided_automation_fl_loc = ;\n/******************************************************************************\n\n                                    %list_all_files\n                                        ________\n\n\ncreates a list of files, based on the provided extensions, that are available\nwithin a root directory. It automatically also checks all subdirectories.\n\n______________________________________________________________________________\n\n\nUSAGE:                         see testing section on the bottom of this code\n\n______________________________________________________________________________\n\nDESCRIPTION:\n\nThis macro creates a SAS dataset that lists all files that can be found within a\nroot directory and all subdirectories under the provided root directory.\nThis can be applied to all available files (by choosing \"*\" as extension),\nor for specific extensions.\n______________________________________________________________________________\n\n\nINPUT PARAMETERS AND KEYWORDS:\n\nlaf_root_dir                provide the top level directory from\n                            where to search for files.\nlaf_extenstion_to_check     can be the wildcard \"*\" or\n                            any extension, e.g. \"CSV\", \"XLM\" etc\n                            (provide without quotes)\nlaf_output_ds_file_overview       provide SAS datasets providing\n                                LIBNAME and SAS Dataset name\n______________________________________________________________________________\n\nNOTES: (Initials, date, summary)\n\nStephan Weigandt    20200406  First officially Released Version\nStephan Weigandt    20220610  expanded functionality to also cover\n                              SAS Content objects\n______________________________________________________________________________\n\n*******************************************************************************/\n\n%macro list_all_files(\n    laf_root_dir,\n    laf_extenstion_to_check,\n    laf_output_ds_file_overview,\n    laf_debug_mode = 0,\n    laf_directory_separator = /,\n    laf_traverse_directories = 1,\n    laf_is_sas_content_directory = 0,\n    laf_iteration_number = 0_0,\n    laf_include_directories = 0\n    );\n    %local\n        filrf\n        rc\n        did\n        memcnt\n        name\n        lal_append_flag\n        lal_length\n        tot_obs\n        table_append_seq\n        laf_full_file_name\n        i\n        laf_debug_text_\n        ;\n\n    %let laf_debug_text_skipping = INFORMATION: Skipping due to extension:;\n    %let laf_debug_text_scanning = INFORMATION: Scanning next directory:;\n    %let lal_length = %length(&laf_root_dir);\n    %if \"%substr(%trim(%left(&laf_root_dir)), &lal_length, 1)\" ne\n            \"%trim(%left(&laf_directory_separator))\" %then\n    %do;\n        %let laf_root_dir = %trim(%left(&laf_root_dir))&laf_directory_separator;\n    %end;\n    %if &laf_iteration_number = 0_0 %then\n    %do;\n        proc datasets lib= work;\n            delete _LAF_spcl_list_files_:;\n        quit;\n    %end;\n    %let laf_do_processing = 1;\n    %if &laf_is_sas_content_directory = 0 %then\n    %do;\n        filename f&laf_iteration_number \"&laf_root_dir\";\n    %end; %else\n    %do;\n        %let laf_rc = 1;\n        data _null_;\n            length fref $ 8 folderPath $ 1024;\n            folderPath = \"&laf_root_dir\";\n            fref=\"__isdir\";\n            rcf = filename(fref, ,\n                            \"filesrvc\",\n                            cats('folderpath=',quote(strip(folderPath)))\n                            );\n            put rcf;\n            call symput (\"laf_rc\", strip(rcf));\n        run;\n\n          %if &laf_rc = 0 %then\n        %do;\n            filename f&laf_iteration_number filesrvc folderpath=\"&laf_root_dir\";\n        %end; %else\n        %do;\n            %let laf_do_processing = 0;\n        %end;\n    %end;\n    %let laf_next_iteration = %eval(%scan(&laf_iteration_number, 1, '_') + 1);\n    %let lal_append_flag = 0;\n    %if %sysfunc(exist(work._LAF_spcl_list_files_&laf_iteration_number)) %then\n    %do;\n        data work._LAF_spcl_list_files_&laf_iteration_number._inter;\n            set work._LAF_spcl_list_files_&laf_iteration_number\n            %if %sysfunc(exist(\n                        work._LAF_spcl_list_files_&laf_iteration_number._inter\n                        )) %then\n            %do;\n                work._LAF_spcl_list_files_&laf_iteration_number._inter\n            %end;\n            ;\n        run;\n        %let lal_append_flag = 1;\n    %end;\n    data work._LAF_spcl_list_files_&laf_iteration_number ;\n        keep\n            directory_path\n            full_file_name\n            file_name\n            is_in_SAS_Content_flag\n            %if &laf_include_directories = 1 %then\n            %do;\n                object_type\n            %end;\n            ;\n        length\n            directory_path $768\n            file_name $256\n            full_file_name $1024\n            %if &laf_include_directories = 1 %then\n            %do;\n                object_type $12\n            %end;\n            ;\n        is_in_SAS_Content_flag = &laf_is_sas_content_directory;\n        directory_path = symget(\"laf_root_dir\");\n    %if &laf_do_processing = 1 %then\n    %do;\n        did = dopen(\"f&laf_iteration_number\");\n        mcount = dnum(did);\n        /**\n        check if directory exists or the correct area is chosen.\n        if not set to 0 to prevent error message\n        **/\n        if missing(mcount) then\n            mcount = 0;\n        do i=1 to mcount;\n            file_name = dread(did, i);\n            fid = mopen(did, file_name);\n            fileext = kfind(file_name,'.');\n            extension = kscan(file_name, -1, '.');\n            /* fid=0 means directory in most cases */\n            full_file_name = STRIP(directory_path)||STRIP(file_name);\n            if fid > 0 or fileext then\n            do;\n                if \"&laf_extenstion_to_check\" = \"*\" or\n                kupcase(extension) = %upcase(\"&laf_extenstion_to_check\") then\n                do;\n                    %if &laf_debug_mode %then\n                    %do;\n                        put \"INFORMATION: Found following file:\" full_file_name;\n                    %end;\n                    %if &laf_include_directories = 1 %then\n                    %do;\n                        object_type = \"file\";\n                    %end;\n                    output;\n                end;\n                %if &laf_debug_mode %then\n                %do;\n                    else\n                    do;\n                        put \"&laf_debug_text_skipping\" full_file_name;\n                    end;\n                %end;\n            end;\n            %if &laf_traverse_directories = 1 %then\n            %do;\n                else\n                do;\n                    %if &laf_debug_mode %then\n                    %do;\n                        put \"&laf_debug_text_scanning\" full_file_name;\n                    %end;\n                    %if &laf_include_directories = 1 %then\n                    %do;\n                        object_type = \"folder\";\n                        output;\n                    %end;\n                    arg1 = cats('%nrstr(%list_all_files(',\n                                full_file_name,\n                                \", &laf_extenstion_to_check,\"\n                                );\n                    arg2 = cats(\"&laf_output_ds_file_overview,\n                                laf_debug_mode = &laf_debug_mode,\"\n                                );\n                    arg3 = cats(\"laf_directory_separator =\n                                    &laf_directory_separator,\n                                laf_traverse_directories =\n                                    &laf_traverse_directories,\"\n                                );\n                    arg3b = cats(\"laf_include_directories =\n                                    &laf_include_directories, \"\n                                );\n                    arg4 = cats(\"laf_is_sas_content_directory =\n                                    &laf_is_sas_content_directory,\n                                laf_iteration_number =\n                                    &laf_next_iteration._\",i,\"))\"\n                                );\n                    call execute(strip(arg1)||\n                                strip(arg2)||\n                                strip(arg3)||\n                                strip(arg3b)||\n                                strip(arg4)\n                                );\n                end;\n            %end;\n        end;\n        rc = dclose(did);\n    %end;\n%else\n    %do;\n        full_file_name = STRIP(ksubstr(directory_path,\n                                        1,\n                                        klength(directory_path)-1)\n                                );\n        %if &laf_include_directories = 1 %then\n        %do;\n            object_type = \"file\";\n        %end;\n\n        output;\n    %end;\n    run;\n\n\n    %let tot_obs = 0;\n    proc sql noprint;\n        select nobs into :tot_obs\n        from dictionary.tables\n        where kupcase(libname)='WORK' and\n                kupcase(memname)=\"_LAF_SPCL_LIST_FILES_&laf_iteration_number\";\n    quit;\n    %put total records = &tot_obs.;\n    %if &tot_obs = 0 %then\n    %do;\n        proc datasets lib= work;\n            delete _LAF_SPCL_LIST_FILES_&laf_iteration_number;\n        quit;\n        %if lal_append_flag = 1 %then\n        %do;\n            data work._LAF_spcl_list_files_&laf_iteration_number.;\n                set work._LAF_spcl_list_files_&laf_iteration_number._inter;\n            run;\n            proc datasets lib= work;\n                delete _LAF_spcl_list_files_&laf_iteration_number._inter;\n            quit;\n        %end;\n    %end; %else\n    %do;\n        %if lal_append_flag = 1 %then\n        %do;\n            data work._LAF_spcl_list_files_&laf_iteration_number.;\n                set work._LAF_spcl_list_files_&laf_iteration_number.\n                    work._LAF_spcl_list_files_&laf_iteration_number._inter;\n            run;\n            proc datasets lib= work;\n                delete _LAF_spcl_list_files_&laf_iteration_number._inter;\n            quit;\n        %end;\n    %end;\n\n    %if &laf_iteration_number = 0_0 %then\n    %do;\n        %let table_append_seq = ;\n        proc sql noprint;\n            select memname into :table_append_seq separated by \" \"\n            from dictionary.tables\n            where kupcase(libname)='WORK' and\n                    kupcase(memname)contains\"_LAF_SPCL_LIST_FILES_\";\n        quit;\n        %if \"&table_append_seq\" ne \"\" %then\n        %do;\n            data work._laf_file_overview_sort;\n                set &table_append_seq;\n            run;\n            proc sort data =work._laf_file_overview_sort;\n                by full_file_name\n                %if &laf_include_directories = 1 %then\n                %do;\n                    descending object_type\n                %end;\n                ;\n            quit;\n\n            data &laf_output_ds_file_overview;\n                set work._laf_file_overview_sort;\n                by full_file_name;\n                %if &laf_include_directories = 1 %then\n                %do;\n                    if first.full_file_name ne last.full_file_name  then\n                    do;\n                    object_type = \"file\";\n                    end;\n                %end;\n                if first.full_file_name;\n            run;\n        %end;\n\n\n    %end;\n\n    %if &laf_do_processing = 1 %then\n    %do;\n        filename f&laf_iteration_number clear;\n    %end;\n%mend list_all_files;\n/** FOR TESTING ***\n\n\noption mprint source notes;\n%let root_directory = /Users/<<MYUSERID>>/My Folder/SAS Videos;\n%let is_content_dir = 0;\n%let delimiter = /;\n%let delimiter = \\;\n%let include_directories = 1;\n%let extension = *;\n%let overview_ds = work.file_overview;\n%let traverse_directories = 1;\n%list_all_files(\n    &root_directory,\n    &extension,\n    &overview_ds,\n    laf_traverse_directories = &traverse_directories,\n    laf_debug_mode = 1,\n    laf_directory_separator = /,\n    laf_is_sas_content_directory = &is_content_dir,\n    laf_include_directories = &include_directories\n    );\n\n*********************/\n/******************************************************************************\n\n                                    %write_out_files_2_libname\n                                            ________\n\n\nuploads a list of files that are listed in a\n\"#\"-separated sequence (without quotes).\n\n______________________________________________________________________________\n\n\nUSAGE:                         see testing section on the bottom of this code\n\n______________________________________________________________________________\n\nDESCRIPTION:\n\nThis macro uploads all files that are listed in a #-separated\nmacro sequence into CAS.\nIt takes care of the following formats:\n- CSV\n- JMP\n- XLSX.\n______________________________________________________________________________\n\n\nINPUT PARAMETERS AND KEYWORDS:\n\n    wof2l_full_filename_path_seq:\n        This is a # separated sequence of filenames with full path information.\n        So the sequence is like: path1/filename1 # path2/filename2 # and so on.\n    wof2l_cas_target_libname:\n        provide a SAS or CAS libname where the files that are found\n        in the directory should be uploaded to.\n        The system can handle SAS or CAS libnames.\n    wof2l_fn_as_in_fxd_wdth_def_seq:\n        It is either blank, or a sequence of filenames separated by # as found\n        in the special definition file\n    wof2l_directory_path_seq:\n        This is a # separated sequence of path that corresponds\n        to wof2l_full_filename_path_seq parameter.\n        So the sequence is like: path1 # path2 # and so on...\n    wof2l_guessing_row:\n        default set to 5000,\n        this number is used to determine how many rows are used\n        for the text files to determine the type of the columns\n        that need to be read in.\n    wof2l_target_environment:\n        default set to  AUTO,\n        it is recommended to let it set to AUTO, otherwise it\n        has to correspond to the type of the provided target library\n    wof2l_upload_activation:\n        default set to 1,\n        This parameter should only be changed when the program\n        is used to test certain functionality that would not need\n        to trigger the actual upload process.\n        Set to 0 otherwise.\n    wof2l_max_name_length:\n        max allowed length of the table name, default value set to 29.\n        In case table name are the same because of truncation,\n        and automated counter is inserted.\n    wof2l_debug_mode:\n        default: 0\n        1: writes out additional detail information about\n            the process to the log window.\n        0: no additional information is written out.\n    wof2l_upload_log_ds:\n        default is set to work._Upload_log\n        This determines the dataset (full dataset name including\n        the library) where the metadata of the process is being\n        stored with regards to uploaded files.\n    wof2l_shp_enrich_with_zip:\n        default: 0\n        0: Shape files are read in as is.\n        1: additional zip information is merged into the SHAPE files\n            assuming that they contain lattitude and longitude information.\n            It also needs a specific lookup table\n            for the process to be available.\n    wof2l_variable_dict_dataset:\n        default is set to work._Variable_Dictionary\n        This determines the dataset (full dataset name\n        including the library) where the metadata of the process is being\n        stored with regards to specifically variable names.\n    wof2l_substitute_string_seq:\n        default: aeiouAEIOU\n        This sequence of characters determine which characters will be\n        omitted if the target file name or variable name needs to be truncated.\n    wof2l_fixed_file_definition_ds:\n        contains the full dataset name, that reflects the special file\n        definitions as outlined in the csv file(s) within the subdirectory(s).\n    wof2l_do_profiling:\n        default: NO\n        NO: no additional processing is done for profiling purposes. This is\n            automatically chosen if the underlying parameters are not set that\n            are needed for the processing of profiling.\n        DICT_ONLY:  only fills in the default dictionary entries needed for the\n            AUTOPROFILING app. The actual profiling needs to be\n            triggered separatedly.\n        PROFILE:    This option fills in the default dictionary entries AND also\n            triggers the execution of creating the actual profiles.\n        PROFILE_ONLY_NO_UPLOAD:    This option fills in the default dictionary\n            entries AND also triggers the execution of creating\n            the actual profiles.\n            And it will skip the upload process, it will only profile the tables\n            that it can find in the provided libname.\n        The last 2 options require the \"Autoprofiling\" application to be\n        included with DIAP.    For details check the installation instructions.\n    wof2l_profile_dict_location:\n        This parameter is NOT used at this point.\n    wof2l_path_2_gis2zip_dataset4shp\n        default: /mnt/downloads/production_data/metadata\n        this is the path that points to the dataset containing GIS to ZIP data.\n        The name of that dataset has to be: GIS_2_ZCTA\n        and contains the following 3 columns:\n            x: longitude\n            y: latitude\n            zip_zcta: zipcode\n    wof2l_path_2_python_shape_script\n        if missing, the app uses the SAS way to read in SHAPE files,\n        otherwise this is the full file path to the python script\n        (which would also include setting up the python environment).\n    wof2l_drop_missing_vars\n        0 (default): don't drop missing variables based on missing values\n        1: drop all the variables that contain only missing values\n        2: drop only the variables that have only missing values AND\n            contain \"ZZ_MISSING_VARNAME_\" in their variable name\n    wof2l_stringseq_2_cutout_from_fn\n        here a sequence of strings can be provided (separated by #),\n        that will be cut out when the target TABLE name is created.\n    wof2l_stringseq_2_cutout_from_vn\n        here a sequence of strings can be provided (separated by #),\n        that will be cut out when the target VARIABLE name is created.\n    wof2l_prefix_4_suspicious_src_fl\n        here a string can be provided (max of length LEN as provided in\n        parameter wof2l_max_lgth_of_suspicious_str), that will be added and\n        replace the first LEN characters of the table name, is the content\n        seems suspicious and suggests to check on the source file\n    wof2l_max_lgth_of_suspicious_str\n        the max length is set to 4 by default\n    wof2l_check_csv_4_num\n        0 (default): this means csv file is read in as-is\n        1: in cases when it is a \"quoted\" csv files (e.g. happens when come\n            of the content contains the separator), then when this is turned on,\n            the process will perform an andditional check on the data that was\n            read in to check of some of the variables that\n            were read in as character actually should be numeric.\n______________________________________________________________________________\n\nNOTES: (Initials, date, summary)\n\nStephan Weigandt    20200406  First officially Released Version\n______________________________________________________________________________\n\n*******************************************************************************/\n\n%macro write_out_files_2_libname(\n    wof2l_full_filename_path_seq,\n    wof2l_cas_target_libname,\n    wof2l_fn_as_in_fxd_wdth_def_seq,\n    wof2l_directory_path_seq = ,\n    wof2l_guessing_row = 50000,\n    wof2l_target_environment = AUTO,\n    wof2l_upload_activation = 1,\n    wof2l_max_name_length = 29,\n    wof2l_debug_mode = 0,\n    wof2l_upload_log_ds = work._Upload_log,\n    wof2l_shp_enrich_with_zip = 1,\n    wof2l_variable_dict_dataset = work._VARIABLE_DICTIONARY,\n    wof2l_substitute_string_seq = aeiouAEIOU,\n    wof2l_fixed_file_definition_ds = ,\n    wof2l_do_profiling = NO,\n    wof2l_profile_dict_location = ,\n    wof2l_path_2_gis2zip_dataset4shp = /mnt/downloads/production_data/metadata,\n    wof2l_path_2_python_shape_script = ,\n    wof2l_csv_big_data_mode = 0,\n    wof2l_drop_missing_vars = 0,\n    wof2l_stringseq_2_cutout_from_fn = ,\n    wof2l_stringseq_2_cutout_from_vn = ,\n    wof2l_prefix_4_suspicious_src_fl = CHK,\n    wof2l_max_lgth_of_suspicious_str = 4,\n    wof2l_check_csv_4_num = 0,\n    wof2l_viyaversion = 35,\n    wof2l_chck_txt_fl_4_spcl_chrct = 0,\n    wof2l_spcl_chrctr_sq2chck_in_hex = 0A#0D,\n    wof2l_spcl_chrct_chck_rplcmnt_hx = 00,\n    wof2l_make_imported_data_prsstnt = 1,\n    wof2l_force_upload_of_all_files = 0,\n    wof2l_skip_files_start_with_seq =  ,\n    wof2l_skip_files_end_with_seq = ,\n    wof2l_fnl_tblname_from_sheetonly = 1,\n    wof2l_create_unique_target_tblnm = 0,\n    wof2l_delimiter = /,\n    wof2l_chck_4_spcl_char_in_vars = 1,\n    wof2l_fnl_ds_name_4_all_extfiles = ,\n    wof2l_diap_guided_automation = 0,\n    wof2l_gddauto_upd_fls_del_seq = ,\n    wof2l_gddauto_upd_fls_sht_seq = ,\n    wof2l_gddauto_upd_fls_cntt_flg =,\n    wof2l_gddauto_upd_fls_hdr_seq = ,\n    wof2l_gddauto_upd_fls_tgt_seq =\n    );\n\n\n\n\n%local\n    wo2c_full_file_name\n    wo2c_file_extension\n    wof2l_filename\n    wof2l_table_name\n    wof2l_excel_table_seq\n    wof2l_xlsx_table_count\n    wof2l_full_table_name\n    wof2l_first_char\n    wof2l_full_fname_path_2_load_seq\n    wof2l_extension_2_load_seq\n    wof2l_target_table_name_seq\n    wof2l_sheet_name_seq\n    wof2l_table_to_process_check\n    wof2l_xlsx_varname_seq\n    wof2l_file_delimiter\n    wof2l_has_header\n    wof2l_delimiter_seq\n    wof2l_has_header_seq\n    wof2l_lrec_length\n    variable_count\n    variable_counter\n    wof2l_special_file_type\n    fwf_directory_seq\n    fwf_filename_seq\n    fwf_incl_fn_in_table_out_seq\n    fwf_file_type_seq\n    fwf_variable_name_seq\n    fwf_variable_label_seq\n    fwf_variable_type_seq\n    fwf_variable_length_seq\n    fwf_variable_format_seq\n    fwf_variable_informat_seq\n    fwf_variable_start_position_seq\n    fwf_variable_end_position_seq\n    wof2l_skip_mssng_vrnm_in_xls\n    wof2l_ds_2_profile_seq\n    wof2l_caslib_temp\n    wof2l_castable_temp\n    wof2l_final_ds_name\n    wof2l_chk_strng_in_var_4_missing\n    wof2l_output_dataset_name\n    wof2l_string_seq_cut_count\n    wof2l_string_seq_cut_counter\n    wof2l_path_for_sas_content_seq\n    wof2l_file_header_flag_seq\n    wof2l_header_flag_guided\n    wof2l_filepath_for_sas_content\n    wof2l_file_delimiter_guided\n    wof2l_file_delimiter_seq\n    ;\n/*********\nFirst determining if the libname points to a Viya or 94 environment.\nthis determines how the tables are uploaded in detail.\n*********/\n\n%let wof2l_string_seq_cut_count = 0;\n%let wof2l_string_seq_cut_count = %wordcnt(&wof2l_stringseq_2_cutout_from_vn,\n                                            \"#\");\n\n%let wof2l_lrec_length = 32760;\n%let wof2l_max_var_name_length_target = 28;\n%if %upcase(&wof2l_target_environment) = AUTO %then\n%do;\n    proc sql noprint;\n        select distinct(engine)\n        into :wof2l_target_environment\n        from dictionary.libnames\n        where kupcase(libname) = \"%upcase(&wof2l_cas_target_libname)\"\n        ;\n    quit;\n%end;\n\n/*****\nCheck here if only profiling is desired withouth any upload activity,\nif so we jump to the end.\n******/\n\n%let wof2l_ds_2_profile_seq = ;\n%let wof2l_chk_strng_in_var_4_missing = ZZ_MISSING_VARNAME_;\n%if \"%upcase(&wof2l_do_profiling)\" = \"PROFILE_ONLY_NO_UPLOAD\" or\n    &wof2l_drop_missing_vars gt 2 %then\n%do;\n    proc sql;\n        select\n            cat(trim(left(library)),\".\",trim(left(adjusted_table_name)))\n        into\n            :wof2l_ds_2_profile_seq    separated by \" #\"\n        from\n            &wof2l_upload_log_ds\n        where\n            kupcase(library) =  \"%upcase(&wof2l_cas_target_libname)\" and\n            not missing(load_date);\n    quit;\n    %let wof2l_table_count_4_profiling = %wordcnt(&wof2l_ds_2_profile_seq, '#');\n    %if &wof2l_debug_mode %then\n    %do;\n        %put INFORMATION: There are &wof2l_table_count_4_profiling tables that will be profiled only:.;\n        %put INFORMATION: &=wof2l_ds_2_profile_seq ;\n    %end;\n    %if \"%upcase(&wof2l_do_profiling)\" = \"PROFILE_ONLY_NO_UPLOAD\" %then\n        %let wof2l_do_profiling = PROFILE;\n\n    %if &wof2l_drop_missing_vars gt 2 %then\n    %do;\n        %if &wof2l_drop_missing_vars eq 3 %then\n            %let wof2l_drop_missing_vars = 1; %else\n        %if &wof2l_drop_missing_vars eq 4 %then\n            %let wof2l_drop_missing_vars = 2;\n    %end;\n\n    %if &wof2l_drop_missing_vars ne 0 %then\n    %do;\n        %let wof2l_ds2_prfl_seq_count = %wordcnt(&wof2l_ds_2_profile_seq, '#');\n        %do wof2l_ds2_prfl_seq_counter = 1 %to &wof2l_ds2_prfl_seq_count;\n            %let wof2l_ds_to_process = %scan(&wof2l_ds_2_profile_seq,\n                                                &wof2l_ds2_prfl_seq_counter,\n                                                '#'\n                                                );\n            %let wof2l_final_table_name = %scan(&wof2l_ds_to_process,\n                                                2,\n                                                '.'\n                                                );\n            %let wof2l_cas_target_libname = %scan(&wof2l_ds_to_process,\n                                                1,\n                                                '.'\n                                                );\n            data work.&wof2l_final_table_name;\n                set &wof2l_ds_to_process;\n            run;\n            %if &wof2l_target_environment eq CAS %then\n            %do;\n                proc casutil;\n                    droptable casdata = \"&wof2l_final_table_name\"\n                        incaslib = \"&wof2l_cas_target_libname\" quiet;\n                    droptable casdata = \"&wof2l_final_table_name\"\n                        incaslib = \"&wof2l_cas_target_libname\" quiet;\n                quit;\n            %end;\n            %DIAP_handling_missings_vars(\n                dhm_missing_handling_option = &wof2l_drop_missing_vars,\n                dhm_dataset_2_check = work.&wof2l_final_table_name,\n                dhm_dataset_2_check_output = &wof2l_ds_to_process,\n                dhm_dataset_2_write_out_results =\n                    _DIAP_only_missing_analysis_&wof2l_ds2_prfl_seq_counter,\n                dhm_stg_2_chk_var_b4_drop = &wof2l_chk_strng_in_var_4_missing\n                );\n            %if &wof2l_target_environment eq CAS %then\n            %do;\n                proc casutil;\n                    promote casdata=\"&wof2l_final_table_name\"\n                    incaslib=\"&wof2l_cas_target_libname\"\n                    outcaslib=\"&wof2l_cas_target_libname\"\n                    casout=\"&wof2l_final_table_name\";\n                    %if &wof2l_make_imported_data_prsstnt = 1 %then\n                    %do;\n                        save casdata=\"&wof2l_final_table_name\"\n                        incaslib=\"&wof2l_cas_target_libname\"\n                        outcaslib=\"&wof2l_cas_target_libname\"\n                        casout=\"&wof2l_final_table_name\" replace;\n                    %end;\n                quit;\n            %end;\n        %end;\n    %end;\n\n\n\n    %if \"%upcase(&wof2l_do_profiling)\" ne \"NO\" %then\n    %do;\n        %automated_profiling_4_DIAP(\n            ap4d_table_2_prep_4_prof_seq = &wof2l_ds_2_profile_seq,\n            ap4d_dict_source_file_path = &wof2l_profile_dict_location,\n            ap4d_prof_execution_option = &wof2l_do_profiling,\n            ap4d_libname_4_dictionaries = %scan(&wof2l_upload_log_ds, 1, '.'),\n            ap4d_viyaversion = &wof2l_viyaversion\n            );\n    %end;\n%end; %else\n%do;\n\n    %if &wof2l_shp_enrich_with_zip = 1 %then\n    %do;\n        libname _meta_94 \"&wof2l_path_2_gis2zip_dataset4shp\";\n    %end;\n    /*********\n    Now go through all the files that need to be read in.\n    one by one going through the list...\n    *********/\n\n    %let wof2l_variable_length_max = 256;\n    /***\n    wof2l_skip_mssng_vrnm_in_xls\n        if set to 1, columns with missing varnames\n        in EXCEL files will be dropped in the target table\n    ***/\n    %let wof2l_skip_mssng_vrnm_in_xls = 1;\n    %let wp2c_file_count = %wordcnt(&wof2l_full_filename_path_seq, '#');\n    %put INFORMATION: There are &wp2c_file_count files to be examined to be read in!;\n    /*********************************************\n    **********************************************\n\n    Now at first prepare the upload log dataset and determine\n    which files need to be uploaded.\n\n    **********************************************\n    *********************************************/\n\n    %let wof2l_full_fname_path_2_load_seq = ;\n    %let wof2l_extension_2_load_seq = ;\n    %let wof2l_target_table_name_seq = ;\n    %let wof2l_sheet_name_seq = ;\n    %let wof2l_original_filename_seq = ;\n\n    %if &wof2l_debug_mode %then\n    %do;\n        %put INFORMATION: Just before log_dataset_4_upload_maintenance() macro with following inflow:;\n        %put INFORMATION: &=wof2l_upload_log_ds;\n        %put INFORMATION: &=wof2l_full_filename_path_seq;\n        %put INFORMATION: &=wof2l_directory_path_seq;\n        %put INFORMATION: &=wof2l_fnl_ds_name_4_all_extfiles;\n        %put INFORMATION: &=wof2l_diap_guided_automation;\n        %put INFORMATION: &=wof2l_gddauto_upd_fls_del_seq;\n        %put INFORMATION: &=wof2l_gddauto_upd_fls_sht_seq;\n        %put INFORMATION: &=wof2l_gddauto_upd_fls_cntt_flg;\n        %put INFORMATION: &=wof2l_gddauto_upd_fls_tgt_seq;\n        %put INFORMATION: &=wof2l_gddauto_upd_fls_hdr_seq;\n    %end;\n\n\n\n    %log_dataset_4_upload_maintenance(\n        &wof2l_upload_log_ds,\n        &wof2l_full_filename_path_seq,\n        ld4um_directory_path_seq = &wof2l_directory_path_seq,\n        ld4um_debug_mode = &wof2l_debug_mode,\n        ld4um_fn_in_fxd_wdth_def_fl_seq = &wof2l_fn_as_in_fxd_wdth_def_seq,\n        ld4um_substitute_string_seq = &wof2l_substitute_string_seq,\n        ld4um_max_name_length = &wof2l_max_name_length,\n        ld4um_stringseq_2_cutout_from_fn = &wof2l_stringseq_2_cutout_from_fn,\n        ld4um_force_upload_of_all_files = &wof2l_force_upload_of_all_files,\n        ld4um_fnl_tblname_from_sheetonly = &wof2l_fnl_tblname_from_sheetonly,\n        ld4um_create_unique_target_tblnm = &wof2l_create_unique_target_tblnm,\n        ld4um_delimiter = &wof2l_delimiter,\n        ld4um_fnl_ds_name_4_all_extfiles = &wof2l_fnl_ds_name_4_all_extfiles,\n        ld4um_diap_guided_automation = &wof2l_diap_guided_automation,\n        ld4um_gddauto_upd_fls_del_seq = &wof2l_gddauto_upd_fls_del_seq,\n        ld4um_gddauto_upd_fls_sht_seq = &wof2l_gddauto_upd_fls_sht_seq,\n        ld4um_gddauto_upd_fls_cntt_flg = &wof2l_gddauto_upd_fls_cntt_flg,\n        ld4um_gddauto_upd_fls_hdr_seq = &wof2l_gddauto_upd_fls_hdr_seq,\n        ld4um_gddauto_upd_fls_tgt_seq = &wof2l_gddauto_upd_fls_tgt_seq\n        );\n\n    /*****************\n    sort descending by sheetname to have them loaded first\n    and to prevent to have missing sheentname in the sequence first\n    *****************/\n    data work._DIAP_working_upload_log_ds;\n        set &wof2l_upload_log_ds.;\n    run;\n\n    %if \"&wof2l_skip_files_start_with_seq\" ne \"\" or\n        \"&wof2l_skip_files_end_with_seq\" ne \"\" %then\n    %do;\n        %let wof2l_skip_files_start_count =\n                %wordcnt(&wof2l_skip_files_start_with_seq, \"#\");\n        %let wof2l_skip_files_end_count =\n                %wordcnt(&wof2l_skip_files_end_with_seq, \"#\");\n\n        data work._DIAP_working_upload_log_ds;\n            set work._DIAP_working_upload_log_ds;\n            length_name = klength(original_sheetname);\n            drop length_name;\n            %do wof2l_skip_counter = 1 %to &wof2l_skip_files_start_count;\n                %let wof2l_skip_files_start_with = %scan(&wof2l_skip_files_start_with_seq,\n                                                            &wof2l_skip_counter,\n                                                            \"#\"\n                                                            );\n                %let wof2l_skip_files_start_length =\n                        %length(&wof2l_skip_files_start_with);\n                if length_name >= &wof2l_skip_files_start_length then\n                do;\n                    if kupcase(ksubstr(original_sheetname,\n                                    1,\n                                    &wof2l_skip_files_start_length)) =\n                        %upcase(\"&wof2l_skip_files_start_with\") then delete;\n                end;\n            %end;\n            %do wof2l_skip_counter = 1 %to &wof2l_skip_files_end_count;\n                %let wof2l_skip_files_end_with = %scan(&wof2l_skip_files_end_with_seq,\n                                                        &wof2l_skip_counter,\n                                                        \"#\"\n                                                        );\n                %let wof2l_skip_files_end_length =\n                        %length(&wof2l_skip_files_end_with);\n                if length_name >= &wof2l_skip_files_end_length then\n                do;\n                    if kupcase(ksubstr(original_sheetname,\n                                    length_name - &wof2l_skip_files_end_length + 1,\n                                    &wof2l_skip_files_end_length)) =\n                        %upcase(\"&wof2l_skip_files_end_with\") then delete;\n                end;\n            %end;\n        run;\n    %end;\n    proc sort\n        data=work._DIAP_working_upload_log_ds;\n        by load_date descending original_sheetname;\n    quit;\n\n    /*********************************************\n    All the files where the load date is missing\n    need to be read in.\n    *********************************************/\n\n\n    proc sql noprint;\n        select\n            file_path_full_name,\n            adjusted_table_name,\n            directory_path,\n            %if \"&wof2l_fixed_file_definition_ds\" ne \"\" %then\n            %do;\n                filename_asin_fxd_wdth_def_fl,\n                original_filename,\n            %end;\n            original_sheetname,\n            file_delimiter,\n            filepath_is_for_sas_content,\n            variable_name_is_in_header,\n            extension\n        into\n            :wof2l_full_fname_path_2_load_seq separated by \" #\",\n            :wof2l_target_table_name_seq separated by \" #\",\n            :wof2l_directory_path_seq separated by \" #\",\n            %if \"&wof2l_fixed_file_definition_ds\" ne \"\" %then\n            %do;\n                :wof2l_fn_as_in_fxd_wdth_def_seq separated by \" #\",\n                :wof2l_original_filename_seq separated by \" #\",\n            %end;\n            :wof2l_sheet_name_seq separated by \" #\",\n            :wof2l_file_delimiter_seq separated by \" #\",\n            :wof2l_path_for_sas_content_seq separated by \" #\",\n            :wof2l_file_header_flag_seq separated by \" #\",\n            :wof2l_extension_2_load_seq separated by \" #\"\n        from\n            work._DIAP_working_upload_log_ds\n        where\n            missing(load_date);\n    quit;\n\n    %if &wof2l_debug_mode %then\n    %do;\n        %put INFORMATION: This is the original files to be uploaded:;\n        %put &=wof2l_full_fname_path_2_load_seq;\n        %put INFORMATION: This is the corresponding target table sequence to be uploaded: ;\n        %put &=wof2l_target_table_name_seq;\n        %put INFORMATION: This is the corresponding sheet name sequence to be uploaded:;\n        %put &=wof2l_sheet_name_seq;\n        %put INFORMATION: This is the corresponding extension sequence to be uploaded:;\n        %put &=wof2l_extension_2_load_seq;\n        %put INFORMATION: This is the special file definition sequence if existent to be uploaded:;\n        %put &=wof2l_fn_as_in_fxd_wdth_def_seq;\n        %put INFORMATION: This is the directory path sequence belonging to special defined files sequence if existent to be uploaded:;\n        %put &=wof2l_directory_path_seq;\n        %put INFORMATION: This is the provided delimiter sequence showing the suggested delimiter for file to be uploaded:;\n        %put &=wof2l_file_delimiter_seq;\n        %put INFORMATION: This is the sas content flag indicator sequence showing if file to be uploaded is located in SAS Content area:;\n        %put &=wof2l_path_for_sas_content_seq;\n        %put INFORMATION: This is the original filename sequence sequence if existent to be uploaded:;\n        %put &=wof2l_original_filename_seq;\n        %put INFORMATION: This is the flag sequence to indicate if variable name is in header if existent to be uploaded:;\n        %put &=wof2l_file_header_flag_seq;\n    %end;\n\n    %let wp2c_file_count = %wordcnt(&wof2l_full_fname_path_2_load_seq, '#');\n    %put INFORMATION: There are &wp2c_file_count files to be examined to be read in!;\n    %if &wp2c_file_count = 0 %then\n    %do;\n        %put INFORMATION GENERAL: No data uploaded since either no updates to the existing uploaded data;\n        %put INFORMATION GENERAL: or no files in directory structure;\n        %put INFORMATION GENERAL: Check Load Dates in Upload log and compare with modified date of files to be uploaded;\n    %end; %else\n    %do;\n    %do wo2c_file_counter = 1 %to &wp2c_file_count;\n\n    /*********\n    First check the length of the filename and such,\n    since that will become the table name.\n    Excel will be treated separately, since one XLS file\n    can contain multiple sheets.\n    *********/\n\n        %let wof2l_directory_path = %scan(&wof2l_directory_path_seq,\n                                            &wo2c_file_counter,\n                                            '#'\n                                            );\n        %let wo2c_full_file_name = %scan(&wof2l_full_fname_path_2_load_seq,\n                                            &wo2c_file_counter,\n                                            '#'\n                                            );\n        %let wo2c_file_extension = %scan(&wof2l_extension_2_load_seq,\n                                            &wo2c_file_counter,\n                                            '#'\n                                            );\n        %let wof2l_sheet_name = %scan(&wof2l_sheet_name_seq,\n                                            &wo2c_file_counter,\n                                            '#'\n                                            );\n        %let wof2l_final_table_name = %scan(&wof2l_target_table_name_seq,\n                                            &wo2c_file_counter,\n                                            '#'\n                                            );\n        %let wof2l_filepath_for_sas_content = %scan(&wof2l_path_for_sas_content_seq,\n                                                    &wo2c_file_counter,\n                                                    '#'\n                                                    );\n        %let wof2l_file_delimiter_guided = %scan(&wof2l_file_delimiter_seq,\n                                                    &wo2c_file_counter,\n                                                    '#'\n                                                    );\n        %let wof2l_header_flag_guided = %scan(&wof2l_file_header_flag_seq,\n                                                &wo2c_file_counter,\n                                                '#'\n                                                );\n\n        %if &wof2l_filepath_for_sas_content = 0 %then\n        %do;\n            filename inf&wo2c_file_counter \"&wo2c_full_file_name\";\n        %end; %else\n        %do;\n            %let wof2l_temp_filename_only = %scan(&wo2c_full_file_name,\n                                                    -1,\n                                                    \"&wof2l_delimiter\"\n                                                    );\n            filename inf&wo2c_file_counter\n                    filesrvc\n                    folderpath     = \"&wof2l_directory_path\"\n                    filename    = \"&wof2l_temp_filename_only\";\n        %end;\n\n        %local wof2l_check_source_fl_flag_&wo2c_file_counter;\n        %let wof2l_check_source_fl_flag_&wo2c_file_counter = 0;\n\n    /*********************************************\n    we are double checking the load time which is needed\n    in case we have special definitions that are processed first.\n    after they are processed, they don't need to be processed again\n    when reading in the \"normal\" files.\n    *********************************************/\n\n\n        %let wof2l_table_to_process_check = .;\n\n        proc sql;\n            select load_date\n            into :wof2l_table_to_process_check\n            from work._DIAP_working_upload_log_ds\n            where\n                kupcase(file_path_full_name)=\"%upcase(&wo2c_full_file_name)\" and\n                kupcase(adjusted_table_name)=\"%upcase(&wof2l_final_table_name)\"\n            ;\n        quit;\n\n\n\n        %if &wof2l_table_to_process_check = . %then\n        %do;\n/*            filename REFFILE DISK \"&wo2c_full_file_name.\";*/\n\n        /******\n        *******\n        In the following section the variable names\n        are checked and made SAS compliant.\n        *******\n        *******/\n\n            %let wof2l_max_varnumber_&wo2c_file_counter = ;\n            %if &wof2l_debug_mode %then\n                %put INFORMATION: Using &wof2l_guessing_row rows to guess column details.;\n\n    /*********************************************\n    First check if this is the run to read in the files\n    that are defined via the special definition file.\n    *********************************************/\n\n\n            %if \"&wof2l_fixed_file_definition_ds\" ne \"\" %then\n            %do;\n                %let wof2l_fm_from_def_ds = %scan(&wof2l_fn_as_in_fxd_wdth_def_seq,\n                                                    &wo2c_file_counter,\n                                                    '#'\n                                                    );\n                %let wof2l_orig_fn = %scan(&wof2l_original_filename_seq,\n                                            &wo2c_file_counter,\n                                            '#'\n                                            );\n                %let fwf_directory_seq = ;\n                %let fwf_filename_seq = ;\n                %let fwf_incl_fn_in_table_out_seq = ;\n                %let fwf_file_type_seq = ;\n                %let fwf_variable_name_seq = ;\n                %let fwf_variable_label_seq = ;\n                %let fwf_variable_type_seq = ;\n                %let fwf_variable_length_seq = ;\n                %let fwf_variable_format_seq = ;\n                %let fwf_variable_informat_seq = ;\n                %let fwf_variable_start_position_seq = ;\n                %let fwf_variable_end_position_seq = ;\n                %let wof2l_max_start_pos_value = ;\n    /*********************************************\n    reading in the definition from the special definition file\n\n    *********************************************/\n\n                proc sql;\n                    select\n                        directory,\n                        filename,\n                        include_fn_in_table_output,\n                        file_type,\n                        variable_name,\n                        variable_label,\n                        variable_type,\n                        variable_length,\n                        variable_format,\n                        variable_informat,\n                        variable_start_position,\n                        variable_end_position,\n                        max(variable_start_position)\n                    into\n                        :fwf_directory_seq separated by ' #',\n                        :fwf_filename_seq separated by ' #',\n                        :fwf_incl_fn_in_table_out_seq separated by ' #',\n                        :fwf_file_type_seq separated by ' #',\n                        :fwf_variable_name_seq separated by ' #',\n                        :fwf_variable_label_seq separated by ' #',\n                        :fwf_variable_type_seq separated by ' #',\n                        :fwf_variable_length_seq separated by ' #',\n                        :fwf_variable_format_seq separated by ' #',\n                        :fwf_variable_informat_seq separated by ' #',\n                        :fwf_variable_start_position_seq separated by ' #',\n                        :fwf_variable_end_position_seq separated by ' #',\n                        :wof2l_max_start_pos_value\n                    from\n                        &wof2l_fixed_file_definition_ds\n                    where\n                        filename = \"&wof2l_fm_from_def_ds\" and\n                        directory = \"&wof2l_directory_path\"\n                    ;\n                quit;\n\n                %put &=fwf_directory_seq;\n                %put &=fwf_filename_seq;\n                %put &=fwf_incl_fn_in_table_out_seq;\n                %put &=fwf_file_type_seq;\n                %put &=fwf_variable_name_seq;\n                %put &=fwf_variable_label_seq;\n                %put &=fwf_variable_type_seq;\n                %put &=fwf_variable_length_seq;\n                %put &=fwf_variable_format_seq;\n                %put &=fwf_variable_informat_seq;\n                %put &=fwf_variable_start_position_seq;\n                %put &=fwf_variable_end_position_seq;\n                %put &=wof2l_max_start_pos_value;\n\n    /*********************************************\n    depending on the type the information is read in.\n    See the different cases, e.g. FIX or XML...\n    here the variable names are provided via the definition file.\n    *********************************************/\n\n                %let wof2l_input_file_&wo2c_file_counter=inf&wo2c_file_counter;\n                %if &wof2l_chck_txt_fl_4_spcl_chrct = 1 %then\n                %do;\n                    filename cf&wo2c_file_counter temp;\n                    %let wof2l_count_of_chrct_2_chk =\n                            %wordcnt(&wof2l_spcl_chrctr_sq2chck_in_hex, '#');\n                    %let wof2l_hex_chrct_2_chck =\n                            %trim(%left(%scan(&wof2l_spcl_chrctr_sq2chck_in_hex,\n                                                1,\n                                                '#'\n                                                )));\n                    /* MAGIC preprocessing step */\n                    data _null_;\n                        infile &&wof2l_input_file_&wo2c_file_counter recfm=n;\n                        file cf&wo2c_file_counter recfm=n;\n                        input a $char1.;\n                        retain open 0;\n                        if a='\"' then\n                            open = not open;\n                        if (\n                            a=\"&wof2l_hex_chrct_2_chck\"x\n                            %do wof2l_counter_of_chrct_2_chk =\n                                            2 %to &wof2l_count_of_chrct_2_chk;\n                                %let wof2l_hex_chrct_2_chck =\n                                    %trim(%left(\n                                        %scan(&wof2l_spcl_chrctr_sq2chck_in_hex,\n                                                &wof2l_counter_of_chrct_2_chk,\n                                                '#'\n                                                )));\n                                or a=\"&wof2l_hex_chrct_2_chck\"x\n                            %end;\n                            )\n                            and open then\n                            put \"%trim(%left(&wof2l_spcl_chrct_chck_rplcmnt_hx))\"x @;\n                        else\n                            put a $char1. @;\n                    run;\n                    %let wof2l_input_file_&wo2c_file_counter =\n                            cf&wo2c_file_counter;\n                %end;\n                %let variable_count =\n                        %wordcnt(&fwf_variable_name_seq, '#');\n                %let wof2l_special_file_type =\n                        %scan(&fwf_file_type_seq, 1, '#');\n    /***\n    file_type variable is also used to determine from which row the data\n    information starts (e.g. if first row is variable name, then data\n    would start with row 2.\n    so in this case, file_type would contain fix-2 as a value.\n    Default is starting from row 1. (e.g. if this information is missing.)\n    ****/\n                %let wof2l_special_file_data_strt =\n                        %scan(&wof2l_special_file_type, 2, '-');\n                %let wof2l_special_file_type =\n                        %scan(&wof2l_special_file_type, 1, '-');\n\n                %if %upcase(%trim(%left(&wof2l_special_file_type))) = FIX %then\n                %do;\n                    data get_table_info_&wo2c_file_counter;\n                        infile &&wof2l_input_file_&wo2c_file_counter\n                            truncover\n                            DSD\n                            lrecl=&wof2l_lrec_length;\n                        input @1\n                        %let fwf_fn_include_indicator = 0;\n                        %do variable_counter = 1 %to &variable_count;\n                            %let variable_name =\n                                %scan(&fwf_variable_name_seq,\n                                        &variable_counter,\n                                        '#'\n                                        );\n                            %let fwf_include_fn_in_output =\n                                %scan(&fwf_incl_fn_in_table_out_seq,\n                                        &variable_counter,\n                                        '#'\n                                        );\n                            %let variable_type =\n                                %scan(&fwf_variable_type_seq,\n                                        &variable_counter,\n                                        '#');\n                            %if \"&fwf_include_fn_in_output\" = \"1\" %then\n                                %let fwf_fn_include_indicator =  1;\n                            %put &=variable_type;\n                            %let variable_start_pos =\n                                    %scan(&fwf_variable_start_position_seq,\n                                            &variable_counter,\n                                            '#'\n                                            );\n                            %let variable_end_pos =\n                                    %scan(&fwf_variable_end_position_seq,\n                                            &variable_counter,\n                                            '#'\n                                            );\n                            var_&wo2c_file_counter._&variable_counter\n                                %if \"%upcase(&variable_type)\" = \"CHAR\" %then\n                                %do;\n                                    $\n                                %end;\n                            &variable_start_pos. - &variable_end_pos.\n                        %end;\n                        ;\n                        %if &fwf_fn_include_indicator = 1 %then\n                        %do;\n                            %let variable_counter = %eval(&variable_count + 1);\n                            length var_&wo2c_file_counter._&variable_counter\n                                    $100.;\n                            var_&wo2c_file_counter._&variable_counter =\n                                    \"&wof2l_orig_fn\";\n                        %end;\n                        %if \"&wof2l_special_file_data_strt\" ne \"\" %then\n                        %do;\n                            if _n_ >= &wof2l_special_file_data_strt;\n                        %end;\n                    run;\n                %end;\n                %if %upcase(%trim(%left(&wof2l_special_file_type))) = XML %then\n                %do;\n                    data get_table_info_&wo2c_file_counter;\n                        retain\n                        %do variable_counter = 1 %to &variable_count;\n                            var_&wo2c_file_counter._&variable_counter\n                        %end;\n                        ;\n                        length\n                            whole_line $ 32000\n                        %do variable_counter = 1 %to &variable_count;\n                            %let variable_length =\n                                    %scan(&fwf_variable_length_seq,\n                                            &variable_counter,\n                                            '#'\n                                            );\n                            %let fwf_include_fn_in_output =\n                                    %scan(&fwf_incl_fn_in_table_out_seq,\n                                            &variable_counter,\n                                            '#'\n                                            );\n                            %let variable_type =\n                                    %scan(&fwf_variable_type_seq,\n                                            &variable_counter,\n                                            '#'\n                                            );\n                            %if \"&fwf_include_fn_in_output\" = \"1\" %then\n                                %let fwf_fn_include_indicator =  1;\n                            %let variable_start_pos =\n                                    %scan(&fwf_variable_start_position_seq,\n                                            &variable_counter,\n                                            '#'\n                                            );\n                            %let variable_end_pos =\n                                    %scan(&fwf_variable_end_position_seq,\n                                    &variable_counter,\n                                    '#'\n                                    );\n                            var_&wo2c_file_counter._&variable_counter\n                                %if \"%upcase(&variable_type)\" = \"CHAR\" %then\n                                %do;\n                                    $\n                                %end;\n                            &variable_length\n                        %end;\n                        ;\n                        infile &&wof2l_input_file_&wo2c_file_counter\n                                truncover\n                                DSD\n                                lrecl=&wof2l_lrec_length;\n                        input @1 whole_line;\n                        output_ok = 0;\n                        drop\n                            whole_line\n                            exist\n                            position_start\n                            position_end\n                            difference\n                            output_ok\n                            ;\n                        %let fwf_fn_include_indicator = 0;\n                        %do variable_counter = 1 %to &variable_count;\n                            %let variable_name =\n                                    %scan(&fwf_variable_name_seq,\n                                            &variable_counter,\n                                            '#'\n                                            );\n                            %let fwf_include_fn_in_output =\n                                    %scan(&fwf_incl_fn_in_table_out_seq,\n                                            &variable_counter,\n                                            '#'\n                                            );\n                            %let variable_type =\n                                    %scan(&fwf_variable_type_seq,\n                                            &variable_counter,\n                                            '#'\n                                            );\n                            %if \"&fwf_include_fn_in_output\" = \"1\" %then\n                                %let fwf_fn_include_indicator =  1;\n                            %put &=variable_type;\n                            %let variable_start_pos =\n                                    %scan(&fwf_variable_start_position_seq,\n                                            &variable_counter,\n                                            '#'\n                                            );\n                            %let variable_end_pos =\n                                    %scan(&fwf_variable_end_position_seq,\n                                            &variable_counter,\n                                            '#'\n                                            );\n                            exist = kindex(kupcase(whole_line),\n                                            \"%upcase(&variable_name)\");\n                            if exist then\n                            do;\n                                position_start = kindex(whole_line, \">\");\n                                position_end = kindex(whole_line, \"</\");\n                                difference = position_end - position_start - 1;\n                                var_&wo2c_file_counter._&variable_counter =\n                                    ksubstr(whole_line,\n                                            position_start+1,\n                                            difference\n                                            );\n                                %if &variable_start_pos =\n                                    &wof2l_max_start_pos_value %then\n                                %do;\n                                    output_ok = 1;\n                                %end;\n                            end;\n                        %end;\n                        %if &fwf_fn_include_indicator = 1 %then\n                        %do;\n                            %let variable_counter = %eval(&variable_count + 1);\n                            length var_&wo2c_file_counter._&variable_counter\n                                $100.;\n                            var_&wo2c_file_counter._&variable_counter =\n                                \"&wof2l_orig_fn\";\n                        %end;\n                        if output_ok then\n                            output;\n                    run;\n                %end;\n\n                %if &wof2l_debug_mode %then\n                %do;\n                    data get_table_info_fwf_&wo2c_file_counter;\n                        set get_table_info_&wo2c_file_counter;\n                    run;\n                %end;\n\n            %end;\n            %else\n            %do;\n    /*********************************************\n    otherwise read in the \"normal\" cases..\n    *********************************************/\n\n                %if \"&wo2c_file_extension\" eq \"CSV\" or\n                    \"&wo2c_file_extension\" eq \"TXT\" or\n                    ((\"&wof2l_file_delimiter_guided\" ne \"\" and\n                    %upcase(\"&wof2l_file_delimiter_guided\") ne \"_DIAP_NA_\") and\n                    &wof2l_diap_guided_automation = 1) %then\n                %do;\n                    options obs = &wof2l_guessing_row;\n                    %let wof2l_file_delimiter = ;\n                    %let wof2l_has_header = 1;\n    /*********************************************\n    based on the first row, the delimiter is determined.\n    Maximum occurence wins.\n\n    For the blank separator there is a separate rule applied:\n    if there is any other separator present than blank, then that\n    separator \"wins\", otherwise blank becomes the separator.\n\n    Another test is performed for the header row.\n    if the very first character is a number, then it is assumed\n    that there is no header row.\n    *********************************************/\n                    %let wof2l_input_file_&wo2c_file_counter =\n                            inf&wo2c_file_counter;\n                    %if &wof2l_chck_txt_fl_4_spcl_chrct = 1 %then\n                    %do;\n                        filename cf&wo2c_file_counter temp;\n                        %let wof2l_count_of_chrct_2_chk =\n                                %wordcnt(&wof2l_spcl_chrctr_sq2chck_in_hex,\n                                        '#'\n                                        );\n                        %let wof2l_hex_chrct_2_chck =\n                                %trim(%left(\n                                    %scan(&wof2l_spcl_chrctr_sq2chck_in_hex,\n                                            1,\n                                            '#'\n                                            )));\n                        /* MAGIC preprocessing step */\n                        data _null_;\n                            infile &&wof2l_input_file_&wo2c_file_counter\n                                recfm=n;\n                            file cf&wo2c_file_counter recfm=n;\n                            input a $char1.;\n                            retain open 0;\n                            if a='\"' then\n                                open = not open;\n                            if (\n                                a=\"&wof2l_hex_chrct_2_chck\"x\n                                %do wof2l_counter_of_chrct_2_chk =\n                                    2 %to &wof2l_count_of_chrct_2_chk;\n                                    %let wof2l_hex_chrct_2_chck =\n                                        %trim(%left(\n                                        %scan(&wof2l_spcl_chrctr_sq2chck_in_hex,\n                                                &wof2l_counter_of_chrct_2_chk,\n                                                '#'\n                                                )));\n                                    or a=\"&wof2l_hex_chrct_2_chck\"x\n                                %end;\n                                )\n                                and open then\n                                put \"%trim(%left(&wof2l_spcl_chrct_chck_rplcmnt_hx))\"x @;\n                            else\n                                put a $char1. @;\n                        run;\n                        %let wof2l_input_file_&wo2c_file_counter =\n                                cf&wo2c_file_counter;\n                    %end;\n\n                    data _null_;\n                        infile &&wof2l_input_file_&wo2c_file_counter\n                                dsd\n                                truncover\n                                LRECL=&wof2l_lrec_length\n                                obs = 1;\n                        input line $&wof2l_lrec_length..;\n                        if _n_ = 1;\n                        count_comma = kcountc(line,',');\n                        count_exclamation = kcountc(line,'!');\n                        count_hash = kcountc(line,'#');\n                        count_semikolon = kcountc(line, ';');\n                        count_blank = kcountc(strip(line),' ');\n                        count_tab = kcountc(line, '09'X);\n                        count_pipe = kcountc(line, '|');\n                        has_no_headerrow = anydigit(ksubstr(line, 1,1));\n                        if has_no_headerrow then\n                            call symput('wof2l_has_header', 0);\n                        max_count = max(count_comma,\n                                        count_semikolon,\n                                        count_tab,\n                                        count_hash,\n                                        count_exclamation,\n                                        count_pipe,\n                                        count_blank\n                                        );\n                        max_count_wo_blank = max(count_comma,\n                                        count_semikolon,\n                                        count_tab,\n                                        count_hash,\n                                        count_exclamation,\n                                        count_pipe\n                                        );\n                        if max_count = count_comma then\n                            call symput('wof2l_file_delimiter', ','); else\n                        if max_count = count_semikolon then\n                            call symput('wof2l_file_delimiter', ';'); else\n                        if max_count = count_tab then\n                            call symput('wof2l_file_delimiter', \"TAB\"); else\n                        if max_count = count_pipe then\n                            call symput('wof2l_file_delimiter', '|');  else\n                        if max_count = count_hash then\n                            call symput('wof2l_file_delimiter', '#'); else\n                        if max_count = count_exclamation then\n                            call symput('wof2l_file_delimiter', '!'); else\n                        if max_count = count_blank and\n                            max_count_wo_blank > 0 then\n                        do;\n                            if max_count_wo_blank = count_comma then\n                                call symput('wof2l_file_delimiter', ','); else\n                            if max_count_wo_blank = count_hash then\n                                call symput('wof2l_file_delimiter', '#'); else\n                            if max_count_wo_blank = count_exclamation then\n                                call symput('wof2l_file_delimiter', '!'); else\n                            if max_count_wo_blank = count_semikolon then\n                                call symput('wof2l_file_delimiter', ';'); else\n                            if max_count_wo_blank = count_tab then\n                                call symput('wof2l_file_delimiter', \"TAB\"); else\n                            if max_count_wo_blank = count_pipe then\n                                call symput('wof2l_file_delimiter', '|');\n                        end; else\n                        if max_count = count_blank then\n                            call symput('wof2l_file_delimiter', 'BLANK');\n                    run;\n                    %let wof2l_source_fl_nmbr_rows_&wo2c_file_counter = 0;\n                    data _null_;\n                      infile &&wof2l_input_file_&wo2c_file_counter end=eof;\n                      input;\n                      if eof then\n                          call symput(\n                                \"wof2l_source_fl_nmbr_rows_&wo2c_file_counter\",\n                                _n_\n                                );\n                    run;\n\n                    %let wof2l_source_fl_nmbr_rows_&wo2c_file_counter =\n                            %trim(\n                            %left(\n                                &&wof2l_source_fl_nmbr_rows_&wo2c_file_counter\n                                )\n                            );\n\n                    %local\n                        wof2l_delimiter_file_no_&wo2c_file_counter\n                        wof2l_has_header_file_no_&wo2c_file_counter\n                        ;\n                    %if \"&wof2l_file_delimiter_guided\" ne \"\" and\n                        \"&wof2l_file_delimiter_guided\" ne \"_DIAP_NA_\" %then\n                    %do;\n                        %let wof2l_file_delimiter =\n                            &wof2l_file_delimiter_guided;\n                    %end;\n                    %let wof2l_delimiter_file_no_&wo2c_file_counter =\n                        &wof2l_file_delimiter;\n                    %if \"&wof2l_header_flag_guided\" ne \"\" %then\n                    %do;\n                        %let wof2l_has_header = &wof2l_header_flag_guided;\n                    %end;\n                    %let wof2l_has_header_file_no_&wo2c_file_counter =\n                            &wof2l_has_header;\n                    %put INFORMATION GENERAL: For file &wo2c_full_file_name the delimiter is: \"&wof2l_file_delimiter\";\n                    %put INFORMATION GENERAL: There are &&wof2l_source_fl_nmbr_rows_&wo2c_file_counter rows to read in.;\n\n                    %if &wof2l_csv_big_data_mode = 0 %then\n                    %do;\n                        proc import\n                            datafile=&&wof2l_input_file_&wo2c_file_counter\n                            out=get_table_info_&wo2c_file_counter\n                            dbms=dlm replace;\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"TAB\" %then\n                                %do;\n                                    delimiter = '09'x ;\n                                %end; %else\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"HASH\" %then\n                                %do;\n                                    delimiter = '#' ;\n                                %end; %else\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"EXCLAMATION\" %then\n                                %do;\n                                    delimiter = '!' ;\n                                %end; %else\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"BLANK\" %then\n                                %do;\n                                    delimiter = ' ' ;\n                                %end; %else\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"COMMA\" %then\n                                %do;\n                                    delimiter = ',' ;\n                                %end; %else\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"SEMICOLON\" %then\n                                %do;\n                                    delimiter = ';' ;\n                                %end; %else\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"PIPE\" %then\n                                %do;\n                                    delimiter = '|' ;\n                                %end; %else\n                                %do;\n                                    delimiter = \"&&wof2l_delimiter_file_no_&wo2c_file_counter\" ;\n                                %end;\n                            %if &&wof2l_has_header_file_no_&wo2c_file_counter\n                                    and\n                                &&wof2l_source_fl_nmbr_rows_&wo2c_file_counter gt 1 %then\n                            %do;\n                                datarow = 2;\n                            %end;\n                            %else\n                            %do;\n                                datarow = 1;\n                            %end;\n                            guessingrows = &wof2l_guessing_row;\n                            getnames=no;\n                        run;\n\n\n                        %let wof2l_char_seq = ;\n                        %let wof2l_char_seq_total = ;\n                        %if &wof2l_check_csv_4_num = 1 %then\n                        %do;\n                            proc sql;\n                                select\n                                    name\n                                into\n                                    :wof2l_char_seq separated by \" \"\n                                from\n                                    dictionary.columns\n                                where\n                                    kupcase(libname) = \"WORK\" and\n                                    kupcase(memname) = \"%upcase(get_table_info_&wo2c_file_counter)\" and\n                                    kupcase(type) contains \"CHAR\"\n                                    ;\n                                select\n                                    name\n                                into\n                                    :wof2l_char_seq_total separated by \" \"\n                                from\n                                    dictionary.columns\n                                where\n                                    kupcase(libname) = \"WORK\" and\n                                    kupcase(memname) = \"%upcase(get_table_info_&wo2c_file_counter)\"\n                                    ;\n                            quit;\n\n                            %let wof2l_var_count_temp = %wordcnt(&wof2l_char_seq, ' ');\n                            %let wof2l_var_count_total_temp = %wordcnt(&wof2l_char_seq_total, ' ');\n                            %do wof2l_var_counter_temp = 1 %to &wof2l_var_count_temp;\n                                %let wof2l_num_flag_varnumber_&wof2l_var_counter_temp = 1;\n                            %end;\n                            data get_table_info_&wo2c_file_counter ;\n                                set get_table_info_&wo2c_file_counter ;\n                                drop\n                                    DIAP_temp_val\n                                    DIAP_temp_dotcount\n                                    DIAP_temp_dashcount\n                                    DIAP_temp_dash_position\n                                    ;\n                                %do wof2l_var_counter_temp = 1 %to &wof2l_var_count_temp;\n                                    %let varname = %scan(&wof2l_char_seq, &wof2l_var_counter_temp, ' ');\n                                    DIAP_temp_val = kcompress(&varname, \".-\", 'd');\n                                    DIAP_temp_dotcount = kcountc(&varname, \".\");\n                                    DIAP_temp_dashcount = kcountc(&varname, \"-\");\n                                    DIAP_temp_dash_position = kindex(&varname, \"-\");\n                                    if lengthn(DIAP_temp_val) ne 0 or\n                                        DIAP_temp_dotcount > 1 or\n                                        DIAP_temp_dashcount > 1 or\n                                        DIAP_temp_dash_position > 1 then\n                                    do;\n                                        call symput(\"wof2l_num_flag_varnumber_&wof2l_var_counter_temp\",  0);\n                                    end;\n                                %end;\n                            run;\n\n                            %let wof2l_temp_varnum_counter = 0;\n                            data get_table_info_&wo2c_file_counter ;\n                                set get_table_info_&wo2c_file_counter;\n                                %do wof2l_var_counter_temp = 1 %to &wof2l_var_count_temp;\n                                    %let varname = %scan(&wof2l_char_seq, &wof2l_var_counter_temp, ' ');\n                                        %if &&wof2l_num_flag_varnumber_&wof2l_var_counter_temp = 1 %then\n                                    %do;\n                                        _&varname = &varname * 1;\n                                        drop &varname;\n                                        %let wof2l_temp_varnum_counter = 1;\n                                    %end;\n                                %end;\n                            run;\n                            %if &wof2l_temp_varnum_counter = 1 %then\n                            %do;\n                                proc datasets library=work nolist;\n                                    modify get_table_info_&wo2c_file_counter;\n                                    rename\n                                        %do wof2l_var_counter_temp = 1 %to &wof2l_var_count_temp;\n                                            %let varname = %scan(&wof2l_char_seq, &wof2l_var_counter_temp, ' ');\n                                            %if &&wof2l_num_flag_varnumber_&wof2l_var_counter_temp = 1 %then\n                                            %do;\n                                                _&varname = &varname\n                                            %end;\n                                        %end;\n                                    ;\n                                quit;\n\n                                data get_table_info_&wo2c_file_counter;\n                                    retain\n                                        %do wof2l_var_counter_temp = 1 %to &wof2l_var_count_total_temp;\n                                            %let varname = %scan(&wof2l_char_seq_total, &wof2l_var_counter_temp, ' ');\n                                            &varname\n                                        %end;\n                                        ;\n                                    set get_table_info_&wo2c_file_counter;\n                                run;\n                            %end;\n                        %end;\n                    %end;\n\n                    options obs = max;\n                    %if &wof2l_csv_big_data_mode = 1 %then\n                    %do;\n\n\n                        data _DIAP_csv_big_data_names_&wo2c_file_counter ;\n                            infile  &&wof2l_input_file_&wo2c_file_counter lrecl=5000000  dsd\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"TAB\" %then\n                                %do;\n                                    delimiter = '09'x\n                                %end; %else\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"HASH\" %then\n                                %do;\n                                    delimiter = '#' ;\n                                %end; %else\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"EXCLAMATION\" %then\n                                %do;\n                                    delimiter = '!' ;\n                                %end; %else\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"BLANK\" %then\n                                %do;\n                                    delimiter = ' '\n                                %end; %else\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"COMMA\" %then\n                                %do;\n                                    delimiter = ','\n                                %end; %else\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"SEMICOLON\" %then\n                                %do;\n                                    delimiter = ';'\n                                %end; %else\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"PIPE\" %then\n                                %do;\n                                    delimiter = '|'\n                                %end; %else\n                                %do;\n                                    delimiter = \"&&wof2l_delimiter_file_no_&wo2c_file_counter\"\n                                %end;\n\n                                obs=1 ;\n                                drop varnum;\n                                do varnum=1 by 1 ;\n                                    length name $32 ;\n                                    input name @;\n                                    output;\n                                end;\n                        run;\n                        %let wof2l_max_varnumber_&wo2c_file_counter = ;\n                        proc sql noprint;\n                            select\n                                nobs into :wof2l_max_varnumber_&wo2c_file_counter\n                            from dictionary.tables\n                            where\n                                kupcase(libname) = 'WORK' and\n                                kupcase(memname) = \"%upcase(_DIAP_csv_big_data_names_&wo2c_file_counter)\";\n                        quit;\n                        %let wof2l_max_varnumber_&wo2c_file_counter = %trim(%left(&&wof2l_max_varnumber_&wo2c_file_counter));\n\n                        %do wof2l_var_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                            %let wof2l_num_flag_varnumber_&wof2l_var_counter = 1;\n                            %local wof2l_num_flag_varnumber_&wof2l_var_counter ;\n                        %end;\n\n                        data get_table_info_&wo2c_file_counter ;\n                            infile  &&wof2l_input_file_&wo2c_file_counter lrecl=5000000  dsd\n                            %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"TAB\" %then\n                            %do;\n                                delimiter = '09'x\n                            %end; %else\n                            %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"HASH\" %then\n                            %do;\n                                delimiter = '#' ;\n                            %end; %else\n                            %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"EXCLAMATION\" %then\n                            %do;\n                                delimiter = '!' ;\n                            %end; %else\n                            %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"BLANK\" %then\n                            %do;\n                                delimiter = ' '\n                            %end; %else\n                            %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"COMMA\" %then\n                            %do;\n                                delimiter = ','\n                            %end; %else\n                            %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"SEMICOLON\" %then\n                            %do;\n                                delimiter = ';'\n                            %end; %else\n                            %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"PIPE\" %then\n                            %do;\n                                delimiter = '|'\n                            %end; %else\n                            %do;\n                                delimiter = \"&&wof2l_delimiter_file_no_&wo2c_file_counter\"\n                            %end;\n\n                            %if &&wof2l_has_header_file_no_&wo2c_file_counter and\n                                &&wof2l_source_fl_nmbr_rows_&wo2c_file_counter gt 1 %then\n                            %do;\n                                firstobs = 2;\n                            %end;\n                            %else\n                            %do;\n                                firstobs = 1;\n                            %end;\n\n                            format\n                            %do wof2l_var_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                var&wof2l_var_counter $64.\n                            %end;\n                            ;\n                            informat\n                            %do wof2l_var_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                var&wof2l_var_counter $64.\n                            %end;\n                            ;\n                            array varplaceholder{&&wof2l_max_varnumber_&wo2c_file_counter} $ &wof2l_variable_length_max var1-var&&wof2l_max_varnumber_&wo2c_file_counter;\n                            length name  $ &wof2l_variable_length_max ;\n                            drop\n                                name\n                                row_counter\n                                varnum\n                                temp_val\n                                temp_dotcount\n                                ;\n                            do varnum=1 by 1 ;\n                                input name @;\n                                row_counter = mod(varnum, &&wof2l_max_varnumber_&wo2c_file_counter);\n                                if row_counter = 0 then\n                                do;\n                                    row_counter = &&wof2l_max_varnumber_&wo2c_file_counter;\n                                end;\n                                varplaceholder{row_counter}= name;\n                                temp_val = kcompress(name, \"-.\", 'd');\n                                temp_dotcount = kcountc(name, \".\");\n                                if lengthn(temp_val) ne 0 or\n                                    temp_dotcount > 1 then\n                                do;\n                                    call symput(cats(\"wof2l_num_flag_varnumber_\", row_counter), 0);\n                                end;\n                                if row_counter = &&wof2l_max_varnumber_&wo2c_file_counter then\n                                do;\n                                    output;\n                                end;\n                            end;\n                        run;\n                        %let wof2l_temp_varnum_counter = 0;\n                        data get_table_info_&wo2c_file_counter ;\n                            set get_table_info_&wo2c_file_counter;\n                            %do wof2l_var_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                %if &&wof2l_num_flag_varnumber_&wof2l_var_counter = 1 %then\n                                %do;\n                                    _var&wof2l_var_counter = var&wof2l_var_counter * 1;\n                                    drop var&wof2l_var_counter;\n                                    %let wof2l_temp_varnum_counter = 1;\n                                %end;\n                            %end;\n                        run;\n                        %if &wof2l_temp_varnum_counter = 1 %then\n                        %do;\n                            proc datasets library=work nolist;\n                                modify get_table_info_&wo2c_file_counter;\n                                    rename\n                                    %do wof2l_var_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                        %if &&wof2l_num_flag_varnumber_&wof2l_var_counter = 1 %then\n                                        %do;\n                                            _var&wof2l_var_counter = var&wof2l_var_counter\n                                        %end;\n                                    %end;\n                                    ;\n                            quit;\n                        %end;\n                    %end;\n                    %if &&wof2l_source_fl_nmbr_rows_&wo2c_file_counter = 1 and\n                        &&wof2l_has_header_file_no_&wo2c_file_counter %then\n                    %do;\n                        data get_table_info_&wo2c_file_counter;\n                            set get_table_info_&wo2c_file_counter;\n                            if 0;\n                        run;\n                    %end;\n                %end; %else\n                %if \"&wo2c_file_extension\" eq \"XLSX\" or\n                    (\"&wo2c_file_extension\" eq \"XLS\" and &wof2l_diap_guided_automation = 1) %then\n                %do;\n                    proc import\n                        datafile=inf&wo2c_file_counter\n                        out=get_table_info_&wo2c_file_counter\n                        dbms=&wo2c_file_extension replace;\n                        datarow = 2;\n                        sheet = \"&wof2l_sheet_name\";\n                        getnames=no;\n                    run;\n                %end;%else\n                %if \"&wo2c_file_extension\" eq \"XML\" %then\n                %do;\n                    filename  tpxmllib \"&wo2c_full_file_name.\";\n                    filename  tpxmlmap \"%substr(&wo2c_full_file_name, 1, %eval(%length(&wo2c_full_file_name) - 3))map\";\n                    libname tpxmllib xmlv2 xmlmap=tpxmlmap access=READONLY;\n                    %let wo2c_temp_filename_only = %scan(%scan(&wo2c_full_file_name, -1, \"&wof2l_delimiter\"), 1, '.');\n                    data get_table_info_&wo2c_file_counter;\n                        set tpxmllib.&wof2l_sheet_name;\n                        length _diap_generated_filename_id $64.;\n                        _diap_generated_filename_id = \"&wo2c_temp_filename_only\";\n                    run;\n\n                %end;%else\n                %if \"&wo2c_file_extension\" eq \"JMP\" %then\n                %do;\n                    proc import\n                        datafile=inf&wo2c_file_counter\n                        out= get_table_info_&wo2c_file_counter\n                        dbms=JMP replace;\n                    run;\n                %end;%else\n                %if \"&wo2c_file_extension\" eq \"JSON\" %then\n                %do;\n                    libname _json json \"&wo2c_full_file_name\";\n                    data get_table_info_&wo2c_file_counter;\n                        set _json.&wof2l_sheet_name;\n                    run;\n                %end; %else\n                %if \"&wo2c_file_extension\" eq \"SHP\" %then\n                %do;\n                    %if &wof2l_viyaversion = 41 %then\n                    %do;\n\n                    %end; %else\n                    %if \"&wof2l_path_2_python_shape_script\" ne \"\" %then\n                    %do;\n                        %let wof2l_length_dir = %length(&wof2l_directory_path);\n                        %let wof2l_adjusted_dir_name = %substr(&wof2l_directory_path, 1, %eval(&wof2l_length_dir - 1));\n                        %put INFORMATION GENERAL: Processing Shape file # &wo2c_file_counter &wo2c_full_file_name with Python script;\n                        x %unquote(%bquote(')&wof2l_path_2_python_shape_script -g\n                            -i \"&wo2c_full_file_name\"\n                            -C \"&wof2l_adjusted_dir_name\"\n                            -l \"&wof2l_directory_path._wof2l_temp_shapeshift.log\"%bquote('));\n                        %let wof2l_temp_log_filename = ;\n\n                        data work.wof2l_temp_storage_logname;\n                            length\n                                filename_target $512\n                                filename_source $512;\n                                infile \"&wof2l_directory_path._wof2l_temp_shapeshift.log\"\n                                delimiter = \",\" MISSOVER firstobs=1 dsd lrecl=32000;\n                                input\n                                    filename_source $\n                                    filename_target $;\n                                call symput(\"wof2l_temp_log_filename\", filename_target);\n                        run;\n                        %let wof2l_temp_log_filename = %trim(%left(&wof2l_temp_log_filename));\n                        proc import\n                            datafile=\"&wof2l_temp_log_filename\"\n                            out=get_table_info_&wo2c_file_counter\n                            dbms=dlm replace;\n                            delimiter = \",\" ;\n                                datarow = 2;\n                            guessingrows = &wof2l_guessing_row;\n                            getnames=yes;\n                        run;\n\n                        x %unquote(%bquote(')rm \"&wof2l_directory_path._wof2l_temp_shapeshift.log\"%bquote('));\n                        x %unquote(%bquote(')rm \"&wof2l_temp_log_filename\"%bquote('));\n                    %end; %else\n                    %do;\n                        %put INFORMATION GENERAL: Processing Shape file # &wo2c_file_counter &wo2c_full_file_name with SAS procedure script;\n                        proc mapimport\n                            datafile=inf&wo2c_file_counter\n                            out=get_table_info_&wo2c_file_counter;\n                        run;\n                        proc datasets lib=work nolist;\n                            modify get_table_info_&wo2c_file_counter;\n                                rename segment = segment_org;\n                        quit;\n                    %end;\n                    %if &wof2l_shp_enrich_with_zip = 1 %then\n                    %do;\n                        proc ginside\n                            data = get_table_info_&wo2c_file_counter\n                            map=_meta_94.gis_2_zcta out = get_table_info_&wo2c_file_counter;\n                            id zip_zcta;\n                        quit;\n                    %end;\n                %end;\n            %end;\n        /**********\n        writing that meta information out into macro variables for processing down the road.\n        here the variable names are captured\n        **********/\n            %let wof2l_max_varnumber_&wo2c_file_counter = 0;\n            %if %sysfunc(exist(get_table_info_&wo2c_file_counter)) %then\n            %do;\n                proc sql noprint;\n                    create table columns_&wo2c_file_counter as\n                    select\n                        libname,\n                        memname,\n                        name,\n                        length,\n                        type,\n                        varnum,\n                        format,\n                        informat\n                    from\n                        dictionary.columns\n                    where\n                        kupcase(libname) = \"WORK\" and\n                        kupcase(memname) = \"GET_TABLE_INFO_&wo2c_file_counter\"\n                    ;\n                quit;\n\n                data columns_&wo2c_file_counter;\n                    set columns_&wo2c_file_counter;\n                    if missing(format) and\n                        missing(informat) then\n                    do;\n                        if trim(left(kupcase(type))) = \"NUM\" then\n                        do;\n                            informat = \"best12.\";\n                            format = \"best12.\";\n                        end; else\n                        do;\n                            informat = \"$32.\";\n                            format = \"$32.\";\n                        end;\n                    end; else\n                    do;\n                        if missing(format) then format = informat;\n                        if missing(informat) then informat = format;\n                    end;\n                run;\n\n                %let wof2l_max_varnumber_&wo2c_file_counter = ;\n                proc sql noprint;\n                    select\n                        nobs into :wof2l_max_varnumber_&wo2c_file_counter\n                    from dictionary.tables\n                    where\n                        libname = 'WORK' and\n                        memname = \"COLUMNS_&wo2c_file_counter\";\n                quit;\n                %let wof2l_max_varnumber_&wo2c_file_counter = %trim(%left(&&wof2l_max_varnumber_&wo2c_file_counter));\n\n    /*****\n    Doing the next step to align the manual chosen variable names by DIAP\n    with the automatic provided ones.\n    *****/\n                %if \"&wo2c_file_extension\" eq \"CSV\" or\n                    \"&wo2c_file_extension\" eq \"TXT\" or\n                    ((\"&wof2l_file_delimiter_guided\" ne \"\" and %upcase(\"&wof2l_file_delimiter_guided\") ne \"_DIAP_NA_\") and\n                        &wof2l_diap_guided_automation = 1) %then\n                %do;\n\n                    proc datasets library=work nolist;\n                        modify get_table_info_&wo2c_file_counter;\n                            rename\n                            %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                var&wof2c_variable_counter = var_&wo2c_file_counter._&wof2c_variable_counter\n                            %end;\n                            ;\n                    quit;\n                    proc sql noprint;\n                        create table columns_&wo2c_file_counter as\n                        select\n                            libname,\n                            memname,\n                            name,\n                            length,\n                            type,\n                            varnum,\n                            format,\n                            informat\n                        from\n                            dictionary.columns\n                        where\n                            kupcase(libname) = \"WORK\" and\n                            kupcase(memname) = \"GET_TABLE_INFO_&wo2c_file_counter\"\n                        ;\n                    quit;\n                    data columns_&wo2c_file_counter;\n                        set columns_&wo2c_file_counter;\n                        if missing(format) and\n                            missing(informat) then\n                        do;\n                            if trim(left(kupcase(type))) = \"NUM\" then\n                            do;\n                                informat = \"best12.\";\n                                format = \"best12.\";\n                            end; else\n                            do;\n                                informat = \"$32.\";\n                                format = \"$32.\";\n                            end;\n                        end; else\n                        do;\n                            if missing(format) then format = informat;\n                            if missing(informat) then informat = format;\n                        end;\n                    run;\n\n                %end;\n\n                %if &wof2l_debug_mode %then\n                            %put INFORMATION: The number of columns of table # &wo2c_file_counter to read in is: &&wof2l_max_varnumber_&wo2c_file_counter;\n\n                %do wof2l_var_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                    %local\n                        wof2l_varname_seq_&wo2c_file_counter._&wof2l_var_counter\n                        wof2l_varnum_seq_&wo2c_file_counter._&wof2l_var_counter\n                        wof2l_format_seq_&wo2c_file_counter._&wof2l_var_counter\n                        wof2l_informat_seq_&wo2c_file_counter._&wof2l_var_counter\n                        wof2l_length_seq_&wo2c_file_counter._&wof2l_var_counter\n                        wof2l_type_seq_&wo2c_file_counter._&wof2l_var_counter\n                        ;\n                    %let wof2l_varname_seq_&wo2c_file_counter._&wof2l_var_counter = ;\n                    %let wof2l_varnum_seq_&wo2c_file_counter._&wof2l_var_counter = ;\n                    %let wof2l_format_seq_&wo2c_file_counter._&wof2l_var_counter = ;\n                    %let wof2l_informat_seq_&wo2c_file_counter._&wof2l_var_counter = ;\n                    %let wof2l_length_seq_&wo2c_file_counter._&wof2l_var_counter = ;\n                    %let wof2l_type_seq_&wo2c_file_counter._&wof2l_var_counter = ;\n                %end;\n                data _null_;\n                    set columns_&wo2c_file_counter;\n                    suffix = put(_n_, 6.);\n                    call symput(cats(\"wof2l_varname_seq_&wo2c_file_counter._\", suffix), name);\n                    call symput(cats(\"wof2l_varnum_seq_&wo2c_file_counter._\", suffix), varnum);\n                    call symput(cats(\"wof2l_format_seq_&wo2c_file_counter._\", suffix), format);\n                    call symput(cats(\"wof2l_informat_seq_&wo2c_file_counter._\", suffix), informat);\n                    call symput(cats(\"wof2l_length_seq_&wo2c_file_counter._\", suffix), length);\n                    call symput(cats(\"wof2l_type_seq_&wo2c_file_counter._\", suffix), type);\n                run;\n\n                %do wof2l_var_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                    %let wof2l_varname_seq_&wo2c_file_counter._&wof2l_var_counter = %trim(%left(&&wof2l_varname_seq_&wo2c_file_counter._&wof2l_var_counter));\n                    %let wof2l_varnum_seq_&wo2c_file_counter._&wof2l_var_counter = %trim(%left(&&wof2l_varnum_seq_&wo2c_file_counter._&wof2l_var_counter));\n                    %let wof2l_format_seq_&wo2c_file_counter._&wof2l_var_counter = %trim(%left(&&wof2l_format_seq_&wo2c_file_counter._&wof2l_var_counter));\n                    %let wof2l_informat_seq_&wo2c_file_counter._&wof2l_var_counter = %trim(%left(&&wof2l_informat_seq_&wo2c_file_counter._&wof2l_var_counter));\n                    %let wof2l_length_seq_&wo2c_file_counter._&wof2l_var_counter = %trim(%left(&&wof2l_length_seq_&wo2c_file_counter._&wof2l_var_counter));\n                    %let wof2l_type_seq_&wo2c_file_counter._&wof2l_var_counter = %trim(%left(&&wof2l_type_seq_&wo2c_file_counter._&wof2l_var_counter));\n                %end;\n\n\n                %let wof2l_varname_seq_count = &&wof2l_max_varnumber_&wo2c_file_counter;\n                %if &wof2l_debug_mode %then\n                %do;\n                    %do wof2l_var_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                        %put INFORMATION: wof2l_varname_seq_&wo2c_file_counter._&wof2l_var_counter = &&wof2l_varname_seq_&wo2c_file_counter._&wof2l_var_counter;\n                        %put INFORMATION: wof2l_varnum_seq_&wo2c_file_counter._&wof2l_var_counter = &&wof2l_varnum_seq_&wo2c_file_counter._&wof2l_var_counter;\n                        %put INFORMATION: wof2l_format_seq_&wo2c_file_counter._&wof2l_var_counter = &&wof2l_format_seq_&wo2c_file_counter._&wof2l_var_counter;\n                        %put INFORMATION: wof2l_informat_seq_&wo2c_file_counter._&wof2l_var_counter = &&wof2l_informat_seq_&wo2c_file_counter._&wof2l_var_counter;\n                        %put INFORMATION: wof2l_length_seq_&wo2c_file_counter._&wof2l_var_counter = &&wof2l_length_seq_&wo2c_file_counter._&wof2l_var_counter;\n                        %put INFORMATION: wof2l_type_seq_&wo2c_file_counter._&wof2l_var_counter = &&wof2l_type_seq_&wo2c_file_counter._&wof2l_var_counter;\n                    %end;\n                %end;\n            %end;\n\n    /*********************************************\n    process special definition cases...\n    *********************************************/\n\n            %if \"&wof2l_fixed_file_definition_ds\" ne \"\" %then\n            %do;\n                %if %upcase(%trim(%left(&wof2l_special_file_type))) = FIX or\n                    %upcase(%trim(%left(&wof2l_special_file_type))) = XML %then\n                %do;\n\n                    data work.varnames_&wo2c_file_counter._2  ;\n                        length\n                        %do wof2c_variable_counter = 1 %to &variable_count;\n                            var_&wo2c_file_counter._&wof2c_variable_counter $ &wof2l_variable_length_max\n                        %end;\n                        %if &fwf_fn_include_indicator = 1 %then\n                        %do;\n                            %let wof2c_variable_counter = %eval(&variable_count + 1);\n                            var_&wo2c_file_counter._&wof2c_variable_counter $ &wof2l_variable_length_max\n                        %end;\n                        ;\n                        %do wof2c_variable_counter = 1 %to &variable_count;\n                            %let original_varname_fwf = %trim(%left(%scan(&fwf_variable_name_seq, &wof2c_variable_counter, '#')));\n\n                            var_&wo2c_file_counter._&wof2c_variable_counter = \"&original_varname_fwf\";\n                        %end;\n                        %if &fwf_fn_include_indicator = 1 %then\n                        %do;\n                            %let wof2c_variable_counter = %eval(&variable_count + 1);\n                            var_&wo2c_file_counter._&wof2c_variable_counter = \"_diap_gen_source_file_name\";\n                        %end;\n\n                    run;\n                %end;\n                data work.varnames_&wo2c_file_counter._2 ;\n\n                    set work.varnames_&wo2c_file_counter._2 ;\n                    %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                        if missing(var_&wo2c_file_counter._&wof2c_variable_counter) or\n                            var_&wo2c_file_counter._&wof2c_variable_counter = \"_\" then\n                        do;\n                            var_&wo2c_file_counter._&wof2c_variable_counter = \"ZZ_MISSING_VARNAME_&wof2c_variable_counter._FILE_&&wo2c_file_counter.\";\n                            call symput(\"wof2l_check_source_fl_flag_&wo2c_file_counter\", 1);\n                        end;\n                    %end;\n                run;\n                %if &wof2l_debug_mode %then\n                %do;\n                    data work.varnames_fwf_&wo2c_file_counter._2 ;\n                        set work.varnames_&wo2c_file_counter._2 ;\n                    run;\n                %end;\n\n            %end;\n            %else\n            %do;\n\n    /*********************************************\n    now process the variable names for all the other cases...\n    *********************************************/\n\n                %if \"&wo2c_file_extension\" eq \"CSV\" or\n                    \"&wo2c_file_extension\" eq \"TXT\" or\n                    ((\"&wof2l_file_delimiter_guided\" ne \"\" and %upcase(\"&wof2l_file_delimiter_guided\") ne \"_DIAP_NA_\") and\n                    &wof2l_diap_guided_automation = 1) %then\n                %do;\n                    %if &&wof2l_has_header_file_no_&wo2c_file_counter %then\n                    %do;\n                        %if &wof2l_csv_big_data_mode = 0 %then\n                        %do;\n                            data work.varnames_&wo2c_file_counter._2  ;\n                            %let _EFIERR_ = 0;\n                                infile &&wof2l_input_file_&wo2c_file_counter\n\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"TAB\" %then\n                                %do;\n                                    delimiter = '09'x\n                                %end; %else\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"HASH\" %then\n                                %do;\n                                    delimiter = '#' ;\n                                %end; %else\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"EXCLAMATION\" %then\n                                %do;\n                                    delimiter = '!' ;\n                                %end; %else\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"BLANK\" %then\n                                %do;\n                                    delimiter = ' '\n                                %end; %else\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"COMMA\" %then\n                                %do;\n                                    delimiter = ','\n                                %end; %else\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"SEMICOLON\" %then\n                                %do;\n                                    delimiter = ';'\n                                %end; %else\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"PIPE\" %then\n                                %do;\n                                    delimiter = '|'\n                                %end; %else\n                                %do;\n                                    delimiter = \"&&wof2l_delimiter_file_no_&wo2c_file_counter\"\n                                %end;\n\n                                MISSOVER DSD lrecl=&wof2l_lrec_length obs = 1;\n                                length\n                                %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                    var_&wo2c_file_counter._&wof2c_variable_counter $ &wof2l_variable_length_max\n                                %end;\n                                ;\n                                input\n                                %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                    var_&wo2c_file_counter._&wof2c_variable_counter $\n                                %end;\n                                ;\n                            run;\n                        %end;\n                        %if &wof2l_csv_big_data_mode = 1 %then\n                        %do;\n                            data work.varnames_&wo2c_file_counter._2 ;\n                                infile  &&wof2l_input_file_&wo2c_file_counter lrecl=5000000  dsd\n\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"TAB\" %then\n                                %do;\n                                    delimiter = '09'x\n                                %end; %else\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"HASH\" %then\n                                %do;\n                                    delimiter = '#' ;\n                                %end; %else\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"EXCLAMATION\" %then\n                                %do;\n                                    delimiter = '!' ;\n                                %end; %else\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"BLANK\" %then\n                                %do;\n                                    delimiter = ' '\n                                %end; %else\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"COMMA\" %then\n                                %do;\n                                    delimiter = ','\n                                %end; %else\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"SEMICOLON\" %then\n                                %do;\n                                    delimiter = ';'\n                                %end; %else\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"PIPE\" %then\n                                %do;\n                                    delimiter = '|'\n                                %end; %else\n                                %do;\n                                    delimiter = \"&&wof2l_delimiter_file_no_&wo2c_file_counter\"\n                                %end;\n                                obs = 1;\n                                array varplaceholder{&&wof2l_max_varnumber_&wo2c_file_counter} $ &wof2l_variable_length_max var_&wo2c_file_counter._1-var_&wo2c_file_counter._&&wof2l_max_varnumber_&wo2c_file_counter;\n                                length name  $ &wof2l_variable_length_max ;\n                                drop name row_counter varnum;\n                                do varnum=1 by 1 ;\n                                    input name @;\n                                    row_counter = mod(varnum, &&wof2l_max_varnumber_&wo2c_file_counter);\n                                    if row_counter = 0 then\n                                    do;\n                                        row_counter = &&wof2l_max_varnumber_&wo2c_file_counter;\n                                    end;\n                                    varplaceholder{row_counter}= name;\n                                    if row_counter = &&wof2l_max_varnumber_&wo2c_file_counter then\n                                    do;\n                                        output;\n                                    end;\n                                end;\n                            run;\n                        %end;\n                    %end; %else\n                    %do;\n                        data work.varnames_&wo2c_file_counter._2  ;\n                        %let _EFIERR_ = 0;\n                            length\n                            %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                var_&wo2c_file_counter._&wof2c_variable_counter $ &wof2l_variable_length_max\n                            %end;\n                            ;\n                            %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                var_&wo2c_file_counter._&wof2c_variable_counter = \"DIAP_varname_gnrtd_&wof2c_variable_counter._FILE_&&wo2c_file_counter.\";\n                            %end;\n                        run;\n                        %let wof2l_check_source_fl_flag_&wo2c_file_counter = 2;\n                    %end;\n                    data work.varnames_&wo2c_file_counter._2 ;\n\n                        set work.varnames_&wo2c_file_counter._2 ;\n                        %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                            if missing(var_&wo2c_file_counter._&wof2c_variable_counter) or\n                                var_&wo2c_file_counter._&wof2c_variable_counter = \"_\" then\n                            do;\n                                var_&wo2c_file_counter._&wof2c_variable_counter = \"ZZ_MISSING_VARNAME_&wof2c_variable_counter._FILE_&&wo2c_file_counter.\";\n                                call symput(\"wof2l_check_source_fl_flag_&wo2c_file_counter\", 1);\n                            end;\n\n                        %end;\n                    run;\n                %end; %else\n                %if \"&wo2c_file_extension\" eq \"XLSX\"  or\n                    (\"&wo2c_file_extension\" eq \"XLS\" and &wof2l_diap_guided_automation = 1) %then\n                %do;\n                    %let wof2l_final_column_name = ;\n                    %let wof2l_xlsx_varname_seq = ;\n                    proc sql noprint;\n                        select\n                            name\n                        into\n                            :wof2l_final_column_name\n                        from\n                            dictionary.columns\n                        where\n                            kupcase(libname) = \"WORK\" and\n                            kupcase(memname) = \"%upcase(get_table_info_&wo2c_file_counter)\" and\n                            varnum = &&wof2l_max_varnumber_&wo2c_file_counter;\n                    quit;\n                    proc import\n                        datafile=inf&wo2c_file_counter\n                        out=work.varnames_&wo2c_file_counter._2\n                        dbms=&wo2c_file_extension replace;\n                        datarow = 1;\n                        range=\"&wof2l_sheet_name$A1:%trim(%left(&wof2l_final_column_name.))1\";\n                        getnames=no;\n                    run;\n\n                    data work.varnames_&wo2c_file_counter._2 ;\n                        length\n                        %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                            _&&wof2l_varname_seq_&wo2c_file_counter._&wof2c_variable_counter $ &wof2l_variable_length_max\n                        %end;\n                        ;\n                        set work.varnames_&wo2c_file_counter._2 ;\n                        %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                            drop &&wof2l_varname_seq_&wo2c_file_counter._&wof2c_variable_counter;\n                            _&&wof2l_varname_seq_&wo2c_file_counter._&wof2c_variable_counter = &&wof2l_varname_seq_&wo2c_file_counter._&wof2c_variable_counter;\n                            if missing(_&&wof2l_varname_seq_&wo2c_file_counter._&wof2c_variable_counter) or\n                                _&&wof2l_varname_seq_&wo2c_file_counter._&wof2c_variable_counter = \"_\" then\n                            do;\n                                _&&wof2l_varname_seq_&wo2c_file_counter._&wof2c_variable_counter = \"ZZ_MISSING_VARNAME_&wof2c_variable_counter._FILE_&&wo2c_file_counter.\";\n                                call symput(\"wof2l_check_source_fl_flag_&wo2c_file_counter\", 1);\n                            end;\n                        %end;\n                    run;\n                    data work.varnames_&wo2c_file_counter._2 ;\n                        length\n                        %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                            &&wof2l_varname_seq_&wo2c_file_counter._&wof2c_variable_counter $ &wof2l_variable_length_max\n                        %end;\n                        ;\n                        set work.varnames_&wo2c_file_counter._2 ;\n                        %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                            drop _&&wof2l_varname_seq_&wo2c_file_counter._&wof2c_variable_counter;\n                            &&wof2l_varname_seq_&wo2c_file_counter._&wof2c_variable_counter = _&&wof2l_varname_seq_&wo2c_file_counter._&wof2c_variable_counter;\n                        %end;\n                    run;\n                %end; %else\n                %if \"&wo2c_file_extension\" eq \"JMP\" or\n                    \"&wo2c_file_extension\" eq \"SHP\" or\n                    \"&wo2c_file_extension\" eq \"JSON\" or\n                    \"&wo2c_file_extension\" eq \"XML\" %then\n                %do;\n                    data work.varnames_&wo2c_file_counter._2;\n                        length\n                            %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                var&&wof2l_varnum_seq_&wo2c_file_counter._&wof2c_variable_counter $256.\n                            %end;\n                            ;\n                            %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                var&&wof2l_varnum_seq_&wo2c_file_counter._&wof2c_variable_counter = \"&&wof2l_varname_seq_&wo2c_file_counter._&wof2c_variable_counter\";\n                                if missing(var&&wof2l_varnum_seq_&wo2c_file_counter._&wof2c_variable_counter) or\n                                    var&&wof2l_varnum_seq_&wo2c_file_counter._&wof2c_variable_counter = \"_\" then\n                                do;\n                                    var&&wof2l_varnum_seq_&wo2c_file_counter._&wof2c_variable_counter = \"ZZ_MISSING_VARNAME_&wof2c_variable_counter._FILE_&&wo2c_file_counter.\";\n                                    call symput(\"wof2l_check_source_fl_flag_&wo2c_file_counter\", 1);\n                                end;\n                            %end;\n                    run;\n            /****\n            the next step is just there to align the jump case with the other cases.\n            And also, just in case if the variable name needs to get changed, this would take care of it.\n            ****/\n                    data get_table_info_&wo2c_file_counter;\n                        set get_table_info_&wo2c_file_counter;\n                            %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                var&&wof2l_varnum_seq_&wo2c_file_counter._&wof2c_variable_counter = &&wof2l_varname_seq_&wo2c_file_counter._&wof2c_variable_counter;\n                                drop &&wof2l_varname_seq_&wo2c_file_counter._&wof2c_variable_counter;\n                            %end;\n                    run;\n                    %let wof2l_max_var_name_length_target = 29;\n                %end;\n            %end;\n\n            %if &wof2l_debug_mode %then\n                        %put INFORMATION: File &wo2c_full_file_name contains &&wof2l_max_varnumber_&wo2c_file_counter variables;\n        /**********\n        transposing to get all the variable names into one column\n        **********/\n            %if %sysfunc(exist(work.varnames_&wo2c_file_counter._2)) %then\n            %do;\n                proc transpose\n                    data = work.varnames_&wo2c_file_counter._2\n                    out = varnames_transposed_&wo2c_file_counter;\n                    var _all_;\n                run;\n            /**********\n            adjusting the variable name and in one first step replacing the \"&\" to reduce headaches\n            downstream\n            **********/\n\n                data work.varnames_transposed_&wo2c_file_counter._exp;\n                    length\n                        varname_first_29char $32.\n                        new_varname $32.\n                        current_varname $32.\n                        original_varname $256.\n                        filename_1st_occurence $256.\n                        format_value $32.\n                        informat_value $32.\n                        ;\n                    drop\n                        _name_\n                        %if &wof2l_string_seq_cut_count eq 0 %then\n                        %do;\n                            col1\n                        %end;\n                        ;\n                    set varnames_transposed_&wo2c_file_counter;\n                    original_order = _n_;\n                    original_varname = kupcase(col1);\n                    new_varname = \"\";\n                    current_varname = _name_;\n                    %if &wof2l_string_seq_cut_count eq 0 %then\n                    %do;\n                        if notalpha(ksubstr(col1, 1, 1)) then col1 = \"V\"||col1;\n                    %end;\n                    varname_first_29char = ksubstr(kupcase(col1), 1, &wof2l_max_var_name_length_target);\n                    filename_1st_occurence = \"&wo2c_full_file_name\";\n                    %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                        if kupcase(trim(left(current_varname))) = \"%trim(%left(%upcase(&&wof2l_varname_seq_&wo2c_file_counter._&wof2c_variable_counter)))\" then\n                        do;\n                            format_value = \"%trim(%left(&&wof2l_format_seq_&wo2c_file_counter._&wof2c_variable_counter))\";\n                            informat_value = \"%trim(%left(&&wof2l_informat_seq_&wo2c_file_counter._&wof2c_variable_counter))\";\n                        end;\n                    %end;\n                run;\n\n    /******\n    the next segment cuts out unwanted characters strings from the variable names\n    *******/\n\n                %if &wof2l_string_seq_cut_count ne 0 %then\n                %do;\n                    %do wof2l_string_seq_cut_counter = 1 %to &wof2l_string_seq_cut_count;\n                        %let wof2l_string_2_cut = %scan(&wof2l_stringseq_2_cutout_from_vn, &wof2l_string_seq_cut_counter, \"#\");\n\n                        data work.varnames_transposed_&wo2c_file_counter._exp;\n                            set work.varnames_transposed_&wo2c_file_counter._exp;\n                            drop\n                                wof2l_string_2_cut\n                                position\n                                length_chk\n                                length_org\n                                ;\n                            wof2l_string_2_cut = \"&wof2l_string_2_cut\";\n                            length_chk = klength(wof2l_string_2_cut);\n                            length_org = klength(col1);\n                            position = 0;\n                            position = kindex(kupcase(col1), kupcase(wof2l_string_2_cut));\n                            if position ne 0 then\n                            do;\n                                if position = 1 and length_chk ne length_org then\n                                    col1 = trim(left(ksubstr(col1, position + length_chk)));\n                                else if position = 1 and length_chk eq length_org then\n                                    col1 = \"\";\n                                else\n                                    col1 = trim(left(trim(left(ksubstr(col1, 1, position - 1)))||trim(left(ksubstr(col1, position + length_chk)))));\n                            end;\n                            if notalpha(ksubstr(col1, 1, 1)) then col1 = \"V\"||trim(left(col1));\n                            if missing(col1) then col1 = \"ZZ_Check_cutout_strng_4_VN_&wo2c_file_counter\";\n                            varname_first_29char = ksubstr(kupcase(col1), 1, &wof2l_max_var_name_length_target);\n                        run;\n                    %end;\n                    data work.varnames_transposed_&wo2c_file_counter._exp;\n                        set work.varnames_transposed_&wo2c_file_counter._exp;\n                        drop\n                            col1\n                        ;\n                    run;\n                %end;\n\n\n                proc sort\n                    data = work.varnames_transposed_&wo2c_file_counter._exp;\n                    by    original_varname;\n                quit;\n            %end; /* end if exist */ %else\n            %do;\n                data work.varnames_transposed_&wo2c_file_counter._exp;\n                    length\n                        varname_first_29char $32.\n                        new_varname $32.\n                        current_varname $32.\n                        original_varname $256.\n                        filename_1st_occurence $256.\n                        format_value $32.\n                        informat_value $32.\n                        original_order 8\n                        ;\n                    if 0;\n                run;\n            %end;\n        %end; %else\n        %do;\n    /*******\n    create empty dataset so the whole process can run through smoothly.\n    *******/\n            data work.varnames_transposed_&wo2c_file_counter._exp;\n                length\n                    varname_first_29char $32.\n                    new_varname $32.\n                    current_varname $32.\n                    original_varname $256.\n                    filename_1st_occurence $256.\n                    format_value $32.\n                    informat_value $32.\n                    original_order 8\n                    ;\n                if 0;\n            run;\n\n        %end;\n    %end;\n\n    /**********\n    now, processing the metadata, we are bringing all the files together from the previous loop into one file\n    **********/\n\n    data work.varnames_all_in_one;\n        set\n    %do wo2c_file_counter = 1 %to &wp2c_file_count;\n        work.varnames_transposed_&wo2c_file_counter._exp\n    %end;\n    ;\n    run;\n    /**********\n    deduping the variable names by the ORIGINAL variable name to prepare for the variable name creation\n        that adheres to the SAS variable names rules.\n    **********/\n\n    proc sort\n        data = work.varnames_all_in_one\n        out = varnames_all_in_one_deduped ;\n        by original_varname format_value;\n    quit;\n\n    data varnames_all_in_one_deduped;\n        set varnames_all_in_one_deduped;\n        by original_varname ;\n        if first.original_varname;\n    run;\n\n    /*************************\n    check if table exists in CAS , but it not loaded yet\n    **************************/\n    %let wof2l_log_target_environment = ;\n    %let wof2l_caslib_temp = %trim(%left(%scan(&wof2l_variable_dict_dataset, 1, '.')));\n    proc sql noprint;\n        select distinct(engine)\n        into :wof2l_log_target_environment\n        from dictionary.libnames\n        where kupcase(libname) = \"%upcase(&wof2l_caslib_temp)\"\n        ;\n    quit;\n\n\n    %if %sysfunc(exist(&wof2l_variable_dict_dataset)) = 0 and\n        &wof2l_log_target_environment eq CAS %then\n    %do;\n        %let wof2l_castable_temp = %trim(%left(%scan(&wof2l_variable_dict_dataset, 2, '.')));\n        proc cas;\n            table.caslibinfo\n                result=sss/caslib=\"&wof2l_caslib_temp\"  ;\n            describe sss;\n            print sss;\n            saveresult sss\n                dataout=work._temp_path_data;\n        run;\n        %let wof2l_temp_lib_path = ;\n        proc sql;\n            select path\n            into:wof2l_temp_lib_path\n            from work._temp_path_data;\n        quit;\n\n        %if %sysfunc(fileexist(%trim(%left(&wof2l_temp_lib_path))&wof2l_castable_temp..sashdat)) %then\n        %do;\n            proc casutil\n                incaslib=\"&wof2l_caslib_temp\" outcaslib = \"&wof2l_caslib_temp\";\n                load casdata=\"&wof2l_castable_temp..sashdat\" casout=\"&wof2l_castable_temp\" promote;\n            quit;\n        %end;\n    %end;\n\n\n    %if %sysfunc(exist(&wof2l_variable_dict_dataset)) %then\n    %do;\n        data work.original_var_overview_ds;\n            set &wof2l_variable_dict_dataset;\n        run;\n        proc sort\n            data = work.original_var_overview_ds;\n            by original_varname;\n        quit;\n        data work.overview_new_var_upload_list;\n            merge\n                work.varnames_all_in_one_deduped (in = update)\n                work.original_var_overview_ds (in = original)\n                ;\n            by     original_varname;\n        run;\n        data work.varnames_all_in_one_deduped;\n            set overview_new_var_upload_list;\n        run;\n    %end;\n\n    /**********\n    now preparing the sort order so we can find out if we have duplicates when we\n        shorten the variable name to 29 characters\n    **********/\n\n    proc sort\n        data = work.varnames_all_in_one_deduped;\n        by     varname_first_29char\n            descending new_varname;\n    quit;\n\n    /**********\n    this datastep deals with duplicates and if there are, we are appending a counter to\n        the newly created variable name to make them unique.\n        we also replace characters in the newly variable name that we don't like for SAS variable names.\n        Then we are writing out the dataset so it is available for reference later on.\n    **********/\n\n    data &wof2l_variable_dict_dataset;\n        retain\n            original_varname\n            new_varname\n            filename_1st_occurence\n            varname_first_29char\n            format_value\n            informat_value\n            ;\n        length new_varname $32.;\n        set work.varnames_all_in_one_deduped;\n        by varname_first_29char;\n        keep new_varname\n            original_varname\n            varname_first_29char\n            filename_1st_occurence\n            format_value\n            informat_value\n            ;\n        retain counter 0;\n        if first.varname_first_29char then\n            counter = 0;\n        counter = counter + 1;\n        if (first.varname_first_29char ne last.varname_first_29char) or\n            (not first.varname_first_29char and not last.varname_first_29char) then\n        do;\n            if missing(new_varname) then\n            do;\n                new_varname = trim(left(varname_first_29char)) || \"_\" || strip(put(counter, z2.));\n                %if &wof2l_chck_4_spcl_char_in_vars = 1 %then\n                %do;\n                    new_varname = tranwrd(strip(new_varname), ' ', \"_\");\n                    new_varname = tranwrd(new_varname, '@', \"_\");\n                    new_varname = tranwrd(new_varname, ':', \"_\");\n                    new_varname = tranwrd(new_varname, '/', \"_\");\n                    new_varname = tranwrd(new_varname, '\\', \"_\");\n                    new_varname = tranwrd(new_varname, '|', \"_\");\n                    new_varname = tranwrd(new_varname, ';', \"_\");\n                    new_varname = tranwrd(new_varname, '$', \"_\");\n                    new_varname = tranwrd(new_varname, '>', \"_\");\n                    new_varname = tranwrd(new_varname, '<', \"_\");\n                    new_varname = tranwrd(new_varname, '^', \"_\");\n                    new_varname = tranwrd(new_varname, '~', \"_\");\n                    new_varname = tranwrd(new_varname, '*', \"_\");\n                    new_varname = tranwrd(new_varname, '(', \"_\");\n                    new_varname = tranwrd(new_varname, '[', \"_\");\n                    new_varname = tranwrd(new_varname, ']', \"_\");\n                    new_varname = tranwrd(new_varname, '{', \"_\");\n                    new_varname = tranwrd(new_varname, '}', \"_\");\n                    new_varname = tranwrd(new_varname, ')', \"_\");\n                    new_varname = tranwrd(new_varname, '!', \"_\");\n                    new_varname = tranwrd(new_varname, '+', \"_\");\n                    new_varname = tranwrd(new_varname, '=', \"_\");\n                    new_varname = tranwrd(new_varname, '?', \"_\");\n                    new_varname = tranwrd(new_varname, '.', \"_\");\n                    new_varname = tranwrd(new_varname, '-', \"_\");\n                    new_varname = tranwrd(trim(left(new_varname)), ' ', \"_\");\n                %end;\n            end;\n        end; else\n            if missing(new_varname) then\n            do;\n                new_varname = varname_first_29char;\n                %if &wof2l_chck_4_spcl_char_in_vars = 1 %then\n                %do;\n                    new_varname = tranwrd(trim(left(new_varname)), ' ', \"_\");\n                    new_varname = tranwrd(new_varname, '@', \"_\");\n                    new_varname = tranwrd(new_varname, ':', \"_\");\n                    new_varname = tranwrd(new_varname, '/', \"_\");\n                    new_varname = tranwrd(new_varname, '\\', \"_\");\n                    new_varname = tranwrd(new_varname, '|', \"_\");\n                    new_varname = tranwrd(new_varname, ';', \"_\");\n                    new_varname = tranwrd(new_varname, '$', \"_\");\n                    new_varname = tranwrd(new_varname, '>', \"_\");\n                    new_varname = tranwrd(new_varname, '<', \"_\");\n                    new_varname = tranwrd(new_varname, '^', \"_\");\n                    new_varname = tranwrd(new_varname, '~', \"_\");\n                    new_varname = tranwrd(new_varname, '*', \"_\");\n                    new_varname = tranwrd(new_varname, '(', \"_\");\n                    new_varname = tranwrd(new_varname, '[', \"_\");\n                    new_varname = tranwrd(new_varname, ']', \"_\");\n                    new_varname = tranwrd(new_varname, '{', \"_\");\n                    new_varname = tranwrd(new_varname, '}', \"_\");\n                    new_varname = tranwrd(new_varname, ')', \"_\");\n                    new_varname = tranwrd(new_varname, '!', \"_\");\n                    new_varname = tranwrd(new_varname, '+', \"_\");\n                    new_varname = tranwrd(new_varname, '=', \"_\");\n                    new_varname = tranwrd(new_varname, '?', \"_\");\n                    new_varname = tranwrd(new_varname, '.', \"_\");\n                    new_varname = tranwrd(new_varname, '-', \"_\");\n                    new_varname = tranwrd(trim(left(new_varname)), ' ', \"_\");\n                %end;\n            end;\n            new_varname = tranwrd(new_varname, '&', \"_\");\n            new_varname = tranwrd(new_varname, '#', \"_\");\n            new_varname = tranwrd(new_varname, ',', \"_\");\n            new_varname = tranwrd(new_varname, '%', \"_\");\n            new_varname = tranwrd(new_varname, '\"', \"_\");\n            new_varname = tranwrd(new_varname, \"'\", \"_\");\n    run;\n\n    /***\n    sort into work dataset, just incase if variable dictionary libnamae is a CAS lib.\n    ***/\n    data work._temp_variable_dict_ds_sorted;\n        set &wof2l_variable_dict_dataset;\n    run;\n    proc sort\n        data=work._temp_variable_dict_ds_sorted;\n        by original_varname;\n    quit;\n    data &wof2l_variable_dict_dataset;\n        set work._temp_variable_dict_ds_sorted;\n    run;\n\n    /**********\n    after we determined the new variable names, we now have to read in the actual files from CSV into SAS.\n        When doing that, we are now using the new variable names, and we put the original variable names\n        into the label.\n    **********/\n\n    %do wo2c_file_counter = 1 %to &wp2c_file_count;\n    /**********\n    looping again through all the provided files, this time to read in the actual data.\n    **********/\n\n        %let wo2c_full_file_name = %scan(&wof2l_full_fname_path_2_load_seq, &wo2c_file_counter, '#');\n        %let wo2c_file_extension = %scan(&wof2l_extension_2_load_seq, &wo2c_file_counter, '#');\n        %let wof2l_sheet_name = %scan(&wof2l_sheet_name_seq, &wo2c_file_counter, '#');\n        %let wof2l_final_table_name = %scan(&wof2l_target_table_name_seq, &wo2c_file_counter, '#');\n        %let wof2l_filepath_for_sas_content = %scan(&wof2l_path_for_sas_content_seq, &wo2c_file_counter, '#');\n        %let wof2l_file_delimiter_guided = %scan(&wof2l_file_delimiter_seq, &wo2c_file_counter, '#');\n        %let wof2l_header_flag_guided = %scan(&wof2l_file_header_flag_seq, &wo2c_file_counter, '#');\n\n        %let wof2l_table_to_process_check = .;\n\n        proc sql;\n            select load_date\n            into :wof2l_table_to_process_check\n            from work._DIAP_working_upload_log_ds\n            where\n                kupcase(file_path_full_name) = \"%upcase(&wo2c_full_file_name)\" and\n                kupcase(adjusted_table_name) = \"%upcase(&wof2l_final_table_name)\"\n            ;\n        quit;\n\n        %put GENERAL INFORMATION: File # &wo2c_file_counter &wo2c_full_file_name with sheet &wof2l_sheet_name ;\n        %put GENERAL INFORMATION: wof2l_table_to_process_check &wof2l_table_to_process_check for final tablename &wof2l_final_table_name ;\n\n        %if &wof2l_table_to_process_check = . %then\n        %do;\n\n\n            data work.varnames_transposed_&wo2c_file_counter._exp;\n                merge     work.varnames_transposed_&wo2c_file_counter._exp (in = infile)\n                        work._temp_variable_dict_ds_sorted (drop = format_value informat_value);\n                by    original_varname;\n                if infile;\n                original_varname = tranwrd(original_varname, '&', \"_\");\n                original_varname = tranwrd(original_varname, '#', \"_\");\n                original_varname = tranwrd(original_varname, ',', \"_\");\n                original_varname = tranwrd(original_varname, '%', \"_\");\n                original_varname = tranwrd(original_varname, '\"', \"_\");\n                original_varname = tranwrd(original_varname, \"'\", \"_\");\n            run;\n            data work.varnames_transposed_&wo2c_file_counter._exp;\n                set work.varnames_transposed_&wo2c_file_counter._exp;\n                if missing(new_varname) then\n                do;\n                    new_varname = kcompress(\"CHECK_SOURCEFILE_4_DUP_VARNAME\"||_n_);\n                    call symput(\"wof2l_check_source_fl_flag_&wo2c_file_counter\", 1);\n                end;\n            run;\n            %let new_variable_name_seq = ;\n            %let original_varname_seq = ;\n            %let current_variable_name_seq = ;\n            %let format_value_seq = ;\n            %let informat_value_seq = ;\n\n            %local\n                new_variable_name_seq\n                original_varname_seq\n                current_variable_name_seq\n                format_value_seq\n                informat_value_seq\n                ;\n    /**********\n    so above we are merging back in the newly created variable name for the current file\n            and writing those out into macro variables below for easier processing later and looping...\n    **********/\n\n    /***\n    sort it first so that missing informat values come last.\n    **/\n            proc sort\n                data = varnames_transposed_&wo2c_file_counter._exp;\n                by original_order;\n            quit;\n\n\n                %do wof2l_var_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                    %let new_var_name_seq_&wo2c_file_counter._&wof2l_var_counter = ;\n                    %let curr_var_name_seq_&wo2c_file_counter._&wof2l_var_counter = ;\n                    %let orig_varname_seq_&wo2c_file_counter._&wof2l_var_counter = ;\n                    %let format_value_seq_&wo2c_file_counter._&wof2l_var_counter = ;\n                    %let informat_value_seq_&wo2c_file_counter._&wof2l_var_counter = ;\n                %end;\n                data _null_;\n                    set varnames_transposed_&wo2c_file_counter._exp;\n                    suffix = put(_n_, 6.);\n                    call symput(cats(\"new_var_name_seq_&wo2c_file_counter._\", suffix), new_varname);\n                    call symput(cats(\"curr_var_name_seq_&wo2c_file_counter._\", suffix), current_varname);\n                    call symput(cats(\"orig_varname_seq_&wo2c_file_counter._\", suffix), original_varname);\n                    call symput(cats(\"format_value_seq_&wo2c_file_counter._\", suffix), format_value);\n                    call symput(cats(\"informat_value_seq_&wo2c_file_counter._\", suffix), informat_value);\n                run;\n                %do wof2l_var_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                    %let new_var_name_seq_&wo2c_file_counter._&wof2l_var_counter = \"%trim(%left(&&new_var_name_seq_&wo2c_file_counter._&wof2l_var_counter))\"n;\n                    %let curr_var_name_seq_&wo2c_file_counter._&wof2l_var_counter = %trim(%left(&&curr_var_name_seq_&wo2c_file_counter._&wof2l_var_counter));\n                    %let orig_varname_seq_&wo2c_file_counter._&wof2l_var_counter = %trim(%left(&&orig_varname_seq_&wo2c_file_counter._&wof2l_var_counter));\n                    %let format_value_seq_&wo2c_file_counter._&wof2l_var_counter = %trim(%left(&&format_value_seq_&wo2c_file_counter._&wof2l_var_counter));\n                    %let informat_value_seq_&wo2c_file_counter._&wof2l_var_counter = %trim(%left(&&informat_value_seq_&wo2c_file_counter._&wof2l_var_counter));\n                %end;\n\n\n\n            %if &wof2l_debug_mode %then\n            %do;\n                    %do wof2l_var_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                        %put INFORMATION: new_var_name_seq_&wo2c_file_counter._&wof2l_var_counter = &&new_var_name_seq_&wo2c_file_counter._&wof2l_var_counter;\n                        %put INFORMATION: curr_var_name_seq_&wo2c_file_counter._&wof2l_var_counter = &&curr_var_name_seq_&wo2c_file_counter._&wof2l_var_counter;\n                        %put INFORMATION: orig_varname_seq_&wo2c_file_counter._&wof2l_var_counter = &&orig_varname_seq_&wo2c_file_counter._&wof2l_var_counter;\n                        %put INFORMATION: format_value_seq_&wo2c_file_counter._&wof2l_var_counter = &&format_value_seq_&wo2c_file_counter._&wof2l_var_counter;\n                        %put INFORMATION: informat_value_seq_&wo2c_file_counter._&wof2l_var_counter = &&informat_value_seq_&wo2c_file_counter._&wof2l_var_counter;\n                    %end;\n            %end;\n    /**********\n    now reading in the complete dataset and setting all the variable characteristics as determined in above\n            steps.\n    **********/\n\n\n    /****\n    Check for variable counter to be different from zero ,so that a valid table is created\n    *****/\n\n            %if &&wof2l_max_varnumber_&wo2c_file_counter gt 0 %then\n            %do;\n    /****\n    have to check for fixed delimited file first, since they might have a CSV or TXT extension.\n    ****/\n            %let wof2l_check_source_file_flag = &&wof2l_check_source_fl_flag_&wo2c_file_counter;\n\n            %if &wof2l_check_source_file_flag = 1 and\n                \"&wof2l_prefix_4_suspicious_src_fl\" ne \"\" and\n                \"&wof2l_fnl_ds_name_4_all_extfiles\" eq \"\" %then\n            %do;\n                %let wof2l_length_prefix_fn_str = %length(&wof2l_prefix_4_suspicious_src_fl);\n                %if &wof2l_max_lgth_of_suspicious_str < &wof2l_length_prefix_fn_str %then\n                %do;\n                    %let &wof2l_length_prefix_fn_str = &wof2l_max_lgth_of_suspicious_str;\n                    %let wof2l_prefix_4_suspicious_src_fl = %substr(&wof2l_prefix_4_suspicious_src_fl, 1, &wof2l_length_prefix_fn_str);\n                %end;\n                %let wof2l_final_table_name = &wof2l_prefix_4_suspicious_src_fl%trim(%left(%substr(&wof2l_final_table_name, %eval(&wof2l_length_prefix_fn_str + 1))));\n            %end;\n\n            %if \"&wof2l_fixed_file_definition_ds\" ne \"\" %then\n            %do;\n\n                    %if &wof2l_debug_mode %then\n                    %do;\n                        %put INFORMATION: Loading FIXED/Width delimited file #&wo2c_file_counter. &wo2c_full_file_name;\n                        %put INFORMATION: Target libname is: &wof2l_cas_target_libname;\n                        %put INFORMATION: Target Table name is: &wof2l_final_table_name;\n                    %end;\n\n                    %if &wof2l_upload_activation = 1 %then\n                    %do;\n                        %if \"&wof2l_fnl_ds_name_4_all_extfiles\" ne \"\" and\n                            %sysfunc(exist(&wof2l_cas_target_libname..&wof2l_final_table_name)) %then\n                        %do;\n                            data work.&wof2l_fnl_ds_name_4_all_extfiles;\n                                set &wof2l_cas_target_libname..&wof2l_final_table_name;\n                            run;\n                        %end;\n\n                        %if &wof2l_target_environment eq CAS %then\n                        %do;\n                            proc casutil;\n                                droptable casdata = \"&wof2l_final_table_name\" incaslib = \"&wof2l_cas_target_libname\" quiet;\n                                droptable casdata = \"&wof2l_final_table_name\" incaslib = \"&wof2l_cas_target_libname\" quiet;\n                            quit;\n                        %end;\n                        data &wof2l_cas_target_libname..&wof2l_final_table_name;\n                            set\n                            %if \"&wof2l_fnl_ds_name_4_all_extfiles\" ne \"\" and\n                                %sysfunc(exist(work.&wof2l_fnl_ds_name_4_all_extfiles)) %then\n                            %do;\n                                work.&wof2l_fnl_ds_name_4_all_extfiles\n                            %end;\n                                work.get_table_info_&wo2c_file_counter\n                                ;\n                            %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                &&new_var_name_seq_&wo2c_file_counter._&wof2c_variable_counter = &&curr_var_name_seq_&wo2c_file_counter._&wof2c_variable_counter;\n                                drop &&curr_var_name_seq_&wo2c_file_counter._&wof2c_variable_counter;\n                            %end;\n                            format\n                            %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                &&new_var_name_seq_&wo2c_file_counter._&wof2c_variable_counter &&format_value_seq_&wo2c_file_counter._&wof2c_variable_counter\n                            %end;\n                            ;\n                            informat\n                            %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                %if \"%trim(%left(&&informat_value_seq_&wo2c_file_counter._&wof2c_variable_counter))\" = \"\" %then\n                                    %let informat_value_seq_&wo2c_file_counter._&wof2c_variable_counter = &&format_value_seq_&wo2c_file_counter._&wof2c_variable_counter;\n                                &&new_var_name_seq_&wo2c_file_counter._&wof2c_variable_counter &&informat_value_seq_&wo2c_file_counter._&wof2c_variable_counter\n                            %end;\n                            ;\n                            label\n                            %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                &&new_var_name_seq_&wo2c_file_counter._&wof2c_variable_counter = \"&&orig_varname_seq_&wo2c_file_counter._&wof2c_variable_counter\"\n                            %end;\n                            ;\n                        run;\n                        data work._DIAP_working_upload_log_ds;\n                            set work._DIAP_working_upload_log_ds;\n                            if file_path_full_name = \"&wo2c_full_file_name\" then\n                            do;\n                                %if &wof2l_check_source_file_flag = 1 and\n                                    \"&wof2l_prefix_4_suspicious_src_fl\" ne \"\" and\n                                    \"&wof2l_fnl_ds_name_4_all_extfiles\" eq \"\" %then\n                                %do;\n                                    adjusted_table_name = \"&wof2l_final_table_name\";\n                                %end;\n                                check_source_file_flag = &wof2l_check_source_file_flag;\n                                load_date = today();\n                                load_time = time();\n                                library = \"%upcase(&wof2l_cas_target_libname)\";\n                            end;\n                        run;\n                        %if &wof2l_target_environment eq CAS %then\n                        %do;\n                            proc casutil;\n                                promote casdata=\"&wof2l_final_table_name\" incaslib=\"&wof2l_cas_target_libname\"\n                                        outcaslib=\"&wof2l_cas_target_libname\" casout=\"&wof2l_final_table_name\";\n                                %if &wof2l_make_imported_data_prsstnt = 1 %then\n                                %do;\n                                    save casdata=\"&wof2l_final_table_name\" incaslib=\"&wof2l_cas_target_libname\"\n                                            outcaslib=\"&wof2l_cas_target_libname\" casout=\"&wof2l_final_table_name\" replace;\n                                %end;\n                            quit;\n                        %end;\n                        %let wof2l_ds_2_profile_seq = &wof2l_ds_2_profile_seq.# &wof2l_cas_target_libname..&wof2l_final_table_name;\n                    %end; %else %put INFORMATION ALERT: Upload is set to be NOT active!!!;\n            %end;\n            %else\n            %do;\n                %let wof2l_final_ds_name = &wof2l_cas_target_libname..&wof2l_final_table_name;\n                %if &wof2l_drop_missing_vars ne 0 %then\n                %do;\n                    %let wof2l_output_dataset_name = work.&wof2l_final_table_name;\n                %end; %else\n                %do;\n                    %let wof2l_output_dataset_name = &wof2l_final_ds_name;\n                %end;\n\n\n                %if \"&wo2c_file_extension\" eq \"CSV\" or\n                    \"&wo2c_file_extension\" eq \"TXT\" or\n                    ((\"&wof2l_file_delimiter_guided\" ne \"\" and %upcase(\"&wof2l_file_delimiter_guided\") ne \"_DIAP_NA_\") and\n                    &wof2l_diap_guided_automation = 1) %then\n                %do;\n                    %if &wof2l_debug_mode %then\n                    %do;\n                        %put INFORMATION: Loading file #&wo2c_file_counter. &wo2c_full_file_name;\n                        %put INFORMATION: Target libname is: &wof2l_cas_target_libname;\n                        %put INFORMATION: Target Table name is: &wof2l_final_table_name;\n                    %end;\n                    %if &wof2l_upload_activation = 1 %then\n                    %do;\n\n                        %if \"&wof2l_fnl_ds_name_4_all_extfiles\" ne \"\" and\n                            %sysfunc(exist(&wof2l_output_dataset_name)) %then\n                        %do;\n                            data work.&wof2l_fnl_ds_name_4_all_extfiles;\n                                set &wof2l_output_dataset_name;\n                            run;\n                        %end;\n\n                        %if &wof2l_target_environment eq CAS %then\n                        %do;\n                            proc casutil;\n                                droptable casdata = \"&wof2l_final_table_name\" incaslib = \"&wof2l_cas_target_libname\" quiet;\n                                droptable casdata = \"&wof2l_final_table_name\" incaslib = \"&wof2l_cas_target_libname\" quiet;\n                            quit;\n                        %end;\n\n                        %let wof2l_input_file_&wo2c_file_counter = inf&wo2c_file_counter;\n                        %if &wof2l_chck_txt_fl_4_spcl_chrct = 1 %then\n                        %do;\n                            filename cf&wo2c_file_counter temp;\n                            %let wof2l_count_of_chrct_2_chk = %wordcnt(&wof2l_spcl_chrctr_sq2chck_in_hex, '#');\n                            %let wof2l_hex_chrct_2_chck = %trim(%left(%scan(&wof2l_spcl_chrctr_sq2chck_in_hex, 1, '#')));\n                            /* MAGIC preprocessing step */\n                            data _null_;\n                                infile &&wof2l_input_file_&wo2c_file_counter recfm=n;\n                                file cf&wo2c_file_counter recfm=n;\n                                input a $char1.;\n                                retain open 0;\n                                if a='\"' then\n                                    open = not open;\n                                if (\n                                    a=\"&wof2l_hex_chrct_2_chck\"x\n                                    %do wof2l_counter_of_chrct_2_chk = 2 %to &wof2l_count_of_chrct_2_chk;\n                                            %let wof2l_hex_chrct_2_chck = %trim(%left(%scan(&wof2l_spcl_chrctr_sq2chck_in_hex, &wof2l_counter_of_chrct_2_chk, '#')));\n                                        or a=\"&wof2l_hex_chrct_2_chck\"x\n                                    %end;\n                                    )\n                                    and open then\n                                    put \"%trim(%left(&wof2l_spcl_chrct_chck_rplcmnt_hx))\"x @;\n                                else\n                                    put a $char1. @;\n                            run;\n                            %let wof2l_input_file_&wo2c_file_counter = cf&wo2c_file_counter;\n                        %end;\n\n                        %if &wof2l_csv_big_data_mode = 0 %then\n                        %do;\n                            data\n                                %if \"&wof2l_fnl_ds_name_4_all_extfiles\" ne \"\" and\n                                    %sysfunc(exist(work.&wof2l_fnl_ds_name_4_all_extfiles)) %then\n                                %do;\n                                    work._wof2l_output_dataset_name\n                                %end; %else\n                                %do;\n                                    &wof2l_output_dataset_name\n                                %end;\n                            ;\n                            %let _EFIERR_ = 0;\n                                infile &&wof2l_input_file_&wo2c_file_counter\n\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"TAB\" %then\n                                %do;\n                                    delimiter = '09'x\n                                %end; %else\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"HASH\" %then\n                                %do;\n                                    delimiter = '#' ;\n                                %end; %else\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"EXCLAMATION\" %then\n                                %do;\n                                    delimiter = '!' ;\n                                %end; %else\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"BLANK\" %then\n                                %do;\n                                    delimiter = ' '\n                                %end; %else\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"COMMA\" %then\n                                %do;\n                                    delimiter = ','\n                                %end; %else\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"SEMICOLON\" %then\n                                %do;\n                                    delimiter = ';'\n                                %end; %else\n                                %if %upcase(\"&&wof2l_delimiter_file_no_&wo2c_file_counter\") eq \"PIPE\" %then\n                                %do;\n                                    delimiter = '|'\n                                %end; %else\n                                %do;\n                                    delimiter = \"&&wof2l_delimiter_file_no_&wo2c_file_counter\"\n                                %end;\n\n                                MISSOVER DSD\n                                lrecl=&wof2l_lrec_length\n                                %if &&wof2l_has_header_file_no_&wo2c_file_counter %then\n                                %do;\n                                    firstobs = 2;\n                                %end;\n                                %else\n                                %do;\n                                    firstobs = 1;\n                                %end;\n                                length\n                                %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                    %if \"&&wof2l_length_seq_&wo2c_file_counter._&wof2c_variable_counter\" eq \"\" %then\n                                        %let wof2l_length_seq_&wo2c_file_counter._&wof2c_variable_counter = 3;\n                                    var_&wo2c_file_counter._&wof2c_variable_counter\n                                    %if \"%upcase(&&wof2l_type_seq_&wo2c_file_counter._&wof2c_variable_counter)\" = \"CHAR\" %then\n                                    %do;\n                                        $\n                                    %end; &&wof2l_length_seq_&wo2c_file_counter._&wof2c_variable_counter\n                                %end;\n                                ;\n\n                                %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                    %if \"&&wof2l_format_seq_&wo2c_file_counter._&wof2c_variable_counter\" eq \"\" %then\n                                        %let wof2l_format_seq_&wo2c_file_counter._&wof2c_variable_counter = best12.;\n                                    format var_&wo2c_file_counter._&wof2c_variable_counter &&wof2l_format_seq_&wo2c_file_counter._&wof2c_variable_counter;\n                                %end;\n                                %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                    %if \"&&wof2l_informat_seq_&wo2c_file_counter._&wof2c_variable_counter\" eq \"\" %then\n                                        %let wof2l_informat_seq_&wo2c_file_counter._&wof2c_variable_counter = best32.;\n                                    informat var_&wo2c_file_counter._&wof2c_variable_counter &&wof2l_informat_seq_&wo2c_file_counter._&wof2c_variable_counter;\n                                %end;\n                                label\n                                %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                    &&new_var_name_seq_&wo2c_file_counter._&wof2c_variable_counter = \"&&orig_varname_seq_&wo2c_file_counter._&wof2c_variable_counter\"\n                                %end;\n                                ;\n                                input\n                                %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                    var_&wo2c_file_counter._&wof2c_variable_counter\n                                    %if \"%upcase(&&wof2l_type_seq_&wo2c_file_counter._&wof2c_variable_counter)\" = \"CHAR\" %then\n                                    %do;\n                                        $\n                                    %end;\n                                %end;\n                                ;\n                                %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                    &&new_var_name_seq_&wo2c_file_counter._&wof2c_variable_counter = &&curr_var_name_seq_&wo2c_file_counter._&wof2c_variable_counter;\n                                    drop &&curr_var_name_seq_&wo2c_file_counter._&wof2c_variable_counter;\n                                %end;\n                                format\n                                %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                    &&new_var_name_seq_&wo2c_file_counter._&wof2c_variable_counter &&format_value_seq_&wo2c_file_counter._&wof2c_variable_counter\n                                %end;\n                                ;\n                                informat\n                                %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                    %if \"%trim(%left(&&informat_value_seq_&wo2c_file_counter._&wof2c_variable_counter))\" = \"\" %then\n                                        %let informat_value_seq_&wo2c_file_counter._&wof2c_variable_counter = &&format_value_seq_&wo2c_file_counter._&wof2c_variable_counter;\n                                    &&new_var_name_seq_&wo2c_file_counter._&wof2c_variable_counter &&informat_value_seq_&wo2c_file_counter._&wof2c_variable_counter\n                                %end;\n                                ;\n                            run;\n                            %if \"&wof2l_fnl_ds_name_4_all_extfiles\" ne \"\" and\n                                %sysfunc(exist(work.&wof2l_fnl_ds_name_4_all_extfiles)) %then\n                            %do;\n                                data &wof2l_output_dataset_name;\n                                    set work.&wof2l_fnl_ds_name_4_all_extfiles\n                                        work._wof2l_output_dataset_name;\n                                run;\n                            %end;\n                        %end;\n                        %if &wof2l_csv_big_data_mode = 1 %then\n                        %do;\n                            data &wof2l_output_dataset_name;\n                                set\n                                %if \"&wof2l_fnl_ds_name_4_all_extfiles\" ne \"\" and\n                                    %sysfunc(exist(work.&wof2l_fnl_ds_name_4_all_extfiles)) %then\n                                %do;\n                                    work.&wof2l_fnl_ds_name_4_all_extfiles\n                                %end;\n                                    work.get_table_info_&wo2c_file_counter\n                                    ;\n                                %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                    &&new_var_name_seq_&wo2c_file_counter._&wof2c_variable_counter = &&curr_var_name_seq_&wo2c_file_counter._&wof2c_variable_counter;\n                                    drop &&curr_var_name_seq_&wo2c_file_counter._&wof2c_variable_counter;\n                                %end;\n                                label\n                                %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                    &&new_var_name_seq_&wo2c_file_counter._&wof2c_variable_counter = \"&&orig_varname_seq_&wo2c_file_counter._&wof2c_variable_counter\"\n                                %end;\n                                ;\n                                format\n                                %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                    &&new_var_name_seq_&wo2c_file_counter._&wof2c_variable_counter &&format_value_seq_&wo2c_file_counter._&wof2c_variable_counter\n                                %end;\n                                ;\n                                informat\n                                %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                    %if \"%trim(%left(&&informat_value_seq_&wo2c_file_counter._&wof2c_variable_counter))\" = \"\" %then\n                                        %let informat_value_seq_&wo2c_file_counter._&wof2c_variable_counter = &&format_value_seq_&wo2c_file_counter._&wof2c_variable_counter;\n                                    &&new_var_name_seq_&wo2c_file_counter._&wof2c_variable_counter &&informat_value_seq_&wo2c_file_counter._&wof2c_variable_counter\n                                %end;\n                                ;\n                            run;\n\n                        %end;\n                        %if &wof2l_debug_mode %then\n                                    %put INFORMATION PROGRESS: Updating Loaddate of &wo2c_full_file_name;\n\n                        %if &wof2l_drop_missing_vars ne 0 %then\n                        %do;\n                            %DIAP_handling_missings_vars(\n                                dhm_missing_handling_option = &wof2l_drop_missing_vars,\n                                dhm_dataset_2_check = &wof2l_output_dataset_name,\n                                dhm_dataset_2_check_output = &wof2l_final_ds_name,\n                                dhm_dataset_2_write_out_results = _DIAP_missing_analysis_&wo2c_file_counter,\n                                dhm_stg_2_chk_var_b4_drop = &wof2l_chk_strng_in_var_4_missing\n                                );\n\n                        %end;\n                        data work._DIAP_working_upload_log_ds;\n                            set work._DIAP_working_upload_log_ds;\n                            if file_path_full_name = \"&wo2c_full_file_name\" then\n                            do;\n                                %if &wof2l_check_source_file_flag = 1 and\n                                    \"&wof2l_prefix_4_suspicious_src_fl\" ne \"\" and\n                                    \"&wof2l_fnl_ds_name_4_all_extfiles\" eq \"\" %then\n                                %do;\n                                    adjusted_table_name = \"&wof2l_final_table_name\";\n                                %end;\n                                check_source_file_flag = &wof2l_check_source_file_flag;\n                                load_date = today();\n                                load_time = time();\n                                library = \"%upcase(&wof2l_cas_target_libname)\";\n                            end;\n                        run;\n\n                        %if &wof2l_target_environment eq CAS %then\n                        %do;\n                            proc casutil;\n                                promote casdata=\"&wof2l_final_table_name\" incaslib=\"&wof2l_cas_target_libname\"\n                                        outcaslib=\"&wof2l_cas_target_libname\" casout=\"&wof2l_final_table_name\";\n                                %if &wof2l_make_imported_data_prsstnt = 1 %then\n                                %do;\n                                    save casdata=\"&wof2l_final_table_name\" incaslib=\"&wof2l_cas_target_libname\"\n                                            outcaslib=\"&wof2l_cas_target_libname\" casout=\"&wof2l_final_table_name\" replace;\n                                %end;\n                            quit;\n                        %end;\n                        %let wof2l_ds_2_profile_seq = &wof2l_ds_2_profile_seq.# &wof2l_cas_target_libname..&wof2l_final_table_name;\n                    %end; %else %put INFORMATION ALERT: Upload is set to be NOT active!!!;\n                %end; %else\n                %if \"&wo2c_file_extension\" eq \"XLSX\"  or\n                    (\"&wo2c_file_extension\" eq \"XLS\" and &wof2l_diap_guided_automation = 1) %then\n                %do;\n                    %if &wof2l_debug_mode %then\n                    %do;\n                        %put INFORMATION: Loading EXCEL file #&wo2c_file_counter. &wo2c_full_file_name;\n                        %put INFORMATION: SHEET  &wof2l_sheet_name;\n                        %put INFORMATION: Target libname is: &wof2l_cas_target_libname;\n                        %put INFORMATION: Target Table name is: &wof2l_final_table_name;\n                    %end;\n\n                    %if &wof2l_upload_activation = 1 %then\n                    %do;\n\n\n                        %if \"&wof2l_fnl_ds_name_4_all_extfiles\" ne \"\" and\n                            %sysfunc(exist(&wof2l_output_dataset_name)) %then\n                        %do;\n                            data work.&wof2l_fnl_ds_name_4_all_extfiles;\n                                set &wof2l_output_dataset_name;\n                            run;\n                        %end;\n\n                        %if &wof2l_target_environment eq CAS %then\n                        %do;\n                            proc casutil;\n                                droptable casdata = \"&wof2l_final_table_name\" incaslib = \"&wof2l_cas_target_libname\" quiet;\n                                droptable casdata = \"&wof2l_final_table_name\" incaslib = \"&wof2l_cas_target_libname\" quiet;\n                            quit;\n                        %end;\n                        data &wof2l_output_dataset_name;\n                            set\n                            %if \"&wof2l_fnl_ds_name_4_all_extfiles\" ne \"\" and\n                                %sysfunc(exist(work.&wof2l_fnl_ds_name_4_all_extfiles)) %then\n                            %do;\n                                work.&wof2l_fnl_ds_name_4_all_extfiles\n                            %end;\n                                work.get_table_info_&wo2c_file_counter;\n                            %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                &&new_var_name_seq_&wo2c_file_counter._&wof2c_variable_counter = &&curr_var_name_seq_&wo2c_file_counter._&wof2c_variable_counter;\n                                drop &&curr_var_name_seq_&wo2c_file_counter._&wof2c_variable_counter;\n                            %end;\n                            label\n                            %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                &&new_var_name_seq_&wo2c_file_counter._&wof2c_variable_counter = \"&&orig_varname_seq_&wo2c_file_counter._&wof2c_variable_counter\"\n                            %end;\n                            ;\n                            format\n                            %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                &&new_var_name_seq_&wo2c_file_counter._&wof2c_variable_counter &&format_value_seq_&wo2c_file_counter._&wof2c_variable_counter\n                            %end;\n                            ;\n                            informat\n                            %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                %if \"%trim(%left(&&informat_value_seq_&wo2c_file_counter._&wof2c_variable_counter))\" = \"\" %then\n                                    %let informat_value_seq_&wo2c_file_counter._&wof2c_variable_counter = &&format_value_seq_&wo2c_file_counter._&wof2c_variable_counter;\n                                &&new_var_name_seq_&wo2c_file_counter._&wof2c_variable_counter &&informat_value_seq_&wo2c_file_counter._&wof2c_variable_counter\n                            %end;\n                            ;\n                            %if &wof2l_skip_mssng_vrnm_in_xls = 1 %then\n                            %do;\n                                ZZ_MISSING_VARNAME_2_AVOID_WNG = 0;\n                                drop ZZ_MISSING_VARNAME_:;\n                            %end;\n                        run;\n                        %if &wof2l_drop_missing_vars ne 0 %then\n                        %do;\n                            %DIAP_handling_missings_vars(\n                                dhm_missing_handling_option = &wof2l_drop_missing_vars,\n                                dhm_dataset_2_check = &wof2l_output_dataset_name,\n                                dhm_dataset_2_check_output = &wof2l_final_ds_name,\n                                dhm_dataset_2_write_out_results = _DIAP_missing_analysis_&wo2c_file_counter,\n                                dhm_stg_2_chk_var_b4_drop = &wof2l_chk_strng_in_var_4_missing\n                                );\n                        %end;\n                        data work._DIAP_working_upload_log_ds;\n                            set work._DIAP_working_upload_log_ds;\n                            if file_path_full_name = \"&wo2c_full_file_name\" and\n                                original_sheetname = \"&wof2l_sheet_name\" then\n                            do;\n                                %if &wof2l_check_source_file_flag = 1 and\n                                    \"&wof2l_prefix_4_suspicious_src_fl\" ne \"\" and\n                                    \"&wof2l_fnl_ds_name_4_all_extfiles\" eq \"\" %then\n                                %do;\n                                    adjusted_table_name = \"&wof2l_final_table_name\";\n                                %end;\n                                check_source_file_flag = &wof2l_check_source_file_flag;\n                                load_date = today();\n                                load_time = time();\n                                library = \"%upcase(&wof2l_cas_target_libname)\";\n                            end;\n                        run;\n\n                        %if &wof2l_target_environment eq CAS %then\n                        %do;\n                            proc casutil;\n                                promote casdata=\"&wof2l_final_table_name\" incaslib=\"&wof2l_cas_target_libname\"\n                                        outcaslib=\"&wof2l_cas_target_libname\" casout=\"&wof2l_final_table_name\";\n                                %if &wof2l_make_imported_data_prsstnt = 1 %then\n                                %do;\n                                    save casdata=\"&wof2l_final_table_name\" incaslib=\"&wof2l_cas_target_libname\"\n                                            outcaslib=\"&wof2l_cas_target_libname\" casout=\"&wof2l_final_table_name\" replace;\n                                %end;\n                            quit;\n                        %end;\n                        %let wof2l_ds_2_profile_seq = &wof2l_ds_2_profile_seq.# &wof2l_cas_target_libname..&wof2l_final_table_name;\n                    %end; %else %put INFORMATION ALERT: Upload is set to be NOT active!!!;\n                %end; %else\n                %if \"&wo2c_file_extension\" eq \"JMP\" or\n                    \"&wo2c_file_extension\" eq \"SHP\" or\n                    \"&wo2c_file_extension\" eq \"JSON\" or\n                    \"&wo2c_file_extension\" eq \"XML\" %then\n                %do;\n                    %if &wof2l_debug_mode %then\n                    %do;\n                        %put INFORMATION: Loading JUMP/SHP file #&wo2c_file_counter. &wo2c_full_file_name;\n                        %put INFORMATION: Target libname is: &wof2l_cas_target_libname;\n                        %put INFORMATION: Target Table name is: &wof2l_final_table_name;\n                    %end;\n\n                    %if &wof2l_upload_activation = 1 %then\n                    %do;\n                        proc datasets lib= work;\n                            delete _DIAP_xml_temp_storage;\n                        quit;\n                        %if (\"&wo2c_file_extension\" eq \"XML\" and\n                        %sysfunc(exist(&wof2l_output_dataset_name))) or\n                        (\"&wof2l_fnl_ds_name_4_all_extfiles\" ne \"\" and\n                            %sysfunc(exist(&wof2l_output_dataset_name)) ) %then\n                        %do;\n                            data work._DIAP_xml_temp_storage;\n                                set &wof2l_output_dataset_name;\n                            run;\n                        %end;\n\n                        %if &wof2l_target_environment eq CAS %then\n                        %do;\n                            proc casutil;\n                                droptable casdata = \"&wof2l_final_table_name\" incaslib = \"&wof2l_cas_target_libname\" quiet;\n                                droptable casdata = \"&wof2l_final_table_name\" incaslib = \"&wof2l_cas_target_libname\" quiet;\n                            quit;\n                        %end;\n                        data\n                            %if (\"&wo2c_file_extension\" eq \"XML\" and\n                                %sysfunc(exist(work._DIAP_xml_temp_storage))) or\n                                (\"&wof2l_fnl_ds_name_4_all_extfiles\" ne \"\" and\n                                %sysfunc(exist(work._DIAP_xml_temp_storage)) ) %then\n                            %do;\n                                work._DIAP_XML_Temp_storage_new;\n                            %end; %else\n                            %do;\n                                &wof2l_output_dataset_name;\n                            %end;\n                            set work.get_table_info_&wo2c_file_counter\n\n                                ;\n                            %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                &&new_var_name_seq_&wo2c_file_counter._&wof2c_variable_counter = &&curr_var_name_seq_&wo2c_file_counter._&wof2c_variable_counter;\n                                drop &&curr_var_name_seq_&wo2c_file_counter._&wof2c_variable_counter;\n                            %end;\n                            label\n                            %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                &&new_var_name_seq_&wo2c_file_counter._&wof2c_variable_counter = \"&&orig_varname_seq_&wo2c_file_counter._&wof2c_variable_counter\"\n                            %end;\n                            ;\n                            format\n                            %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                &&new_var_name_seq_&wo2c_file_counter._&wof2c_variable_counter &&format_value_seq_&wo2c_file_counter._&wof2c_variable_counter\n                            %end;\n                            ;\n                            informat\n                            %do wof2c_variable_counter = 1 %to &&wof2l_max_varnumber_&wo2c_file_counter;\n                                %if \"%trim(%left(&&informat_value_seq_&wo2c_file_counter._&wof2c_variable_counter))\" = \"\" %then\n                                    %let informat_value_seq_&wo2c_file_counter._&wof2c_variable_counter = &&format_value_seq_&wo2c_file_counter._&wof2c_variable_counter;\n                                &&new_var_name_seq_&wo2c_file_counter._&wof2c_variable_counter &&informat_value_seq_&wo2c_file_counter._&wof2c_variable_counter\n                            %end;\n                            ;\n                        run;\n\n                        %if (\"&wo2c_file_extension\" eq \"XML\" and\n                            %sysfunc(exist(work._DIAP_xml_temp_storage))) or\n                            (\"&wof2l_fnl_ds_name_4_all_extfiles\" ne \"\" and\n                            %sysfunc(exist(work._DIAP_xml_temp_storage)) )%then\n                        %do;\n                            data &wof2l_output_dataset_name;\n                                set work._DIAP_xml_temp_storage\n                                    work._DIAP_XML_Temp_storage_new;\n                            run;\n                            proc datasets lib = work;\n                                delete _DIAP_xml_temp_storage\n                                        _DIAP_XML_Temp_storage_new;\n                            quit;\n                        %end;\n                        %if &wof2l_drop_missing_vars ne 0 %then\n                        %do;\n                            %DIAP_handling_missings_vars(\n                                dhm_missing_handling_option = &wof2l_drop_missing_vars,\n                                dhm_dataset_2_check = &wof2l_output_dataset_name,\n                                dhm_dataset_2_check_output = &wof2l_final_ds_name,\n                                dhm_dataset_2_write_out_results = _DIAP_missing_analysis_&wo2c_file_counter,\n                                dhm_stg_2_chk_var_b4_drop = &wof2l_chk_strng_in_var_4_missing\n                                );\n                        %end;\n                        data work._DIAP_working_upload_log_ds;\n                            set work._DIAP_working_upload_log_ds;\n                            if file_path_full_name = \"&wo2c_full_file_name\"\n                            %if \"&wo2c_file_extension\" eq \"JSON\" or\n                                \"&wo2c_file_extension\" eq \"XML\" %then\n                            %do;\n                                and\n                                original_sheetname = \"&wof2l_sheet_name\"\n                            %end;\n                                then\n                            do;\n                                %if &wof2l_check_source_file_flag = 1 and\n                                    \"&wof2l_prefix_4_suspicious_src_fl\" ne \"\" and\n                                    \"&wof2l_fnl_ds_name_4_all_extfiles\" eq \"\" %then\n                                %do;\n                                    adjusted_table_name = \"&wof2l_final_table_name\";\n                                %end;\n                                check_source_file_flag = &wof2l_check_source_file_flag;\n                                load_date = today();\n                                load_time = time();\n                                library = \"%upcase(&wof2l_cas_target_libname)\";\n                            end;\n                        run;\n                        %if &wof2l_target_environment eq CAS %then\n                        %do;\n                            proc casutil;\n                                promote casdata=\"&wof2l_final_table_name\" incaslib=\"&wof2l_cas_target_libname\"\n                                        outcaslib=\"&wof2l_cas_target_libname\" casout=\"&wof2l_final_table_name\";\n                                %if &wof2l_make_imported_data_prsstnt = 1 %then\n                                %do;\n                                    save casdata=\"&wof2l_final_table_name\" incaslib=\"&wof2l_cas_target_libname\"\n                                            outcaslib=\"&wof2l_cas_target_libname\" casout=\"&wof2l_final_table_name\" replace;\n                                %end;\n                            quit;\n                        %end;\n                        %let wof2l_ds_2_profile_seq = &wof2l_ds_2_profile_seq.# &wof2l_cas_target_libname..&wof2l_final_table_name;\n                    %end; %else %put INFORMATION ALERT: Upload is set to be NOT active!!!;\n                %end; %else\n                %if \"&wo2c_file_extension\" eq \"NEF\" %then\n                %do;\n                    %if &wof2l_debug_mode %then\n                    %do;\n                        %put INFORMATION: Copying NEF file #&wo2c_file_counter. &wo2c_full_file_name;\n                        %put INFORMATION: Target libname is: &wof2l_cas_target_libname;\n                        %put INFORMATION: Target Table name is: &wof2l_final_table_name;\n                    %end;\n                    %if &wof2l_upload_activation = 1 %then\n                    %do;\n                        %let wof2l_libname_path = ;\n                        %if &wof2l_target_environment eq CAS %then\n                        %do;\n                            proc cas;\n                                table.caslibinfo result=sss/caslib=\"&wof2l_cas_target_libname\"  ;\n                                describe sss;\n                                print sss;\n                                saveresult sss  dataout=work.xdata;\n                            run;\n\n                            proc sql;\n                                select path into:wof2l_libname_path\n                                from work.xdata;\n                            quit;\n                        %end; %else\n                        %do;\n                            %let wof2l_libname_path = %trim(%left(%sysfunc(pathname(&wof2l_cas_target_libname))))&wof2l_delimiter.;\n                        %end;\n                        data work._DIAP_working_upload_log_ds;\n                            set work._DIAP_working_upload_log_ds;\n                            if file_path_full_name = \"&wo2c_full_file_name\" then\n                            do;\n                                %if &wof2l_check_source_file_flag = 1 and\n                                    \"&wof2l_prefix_4_suspicious_src_fl\" ne \"\" and\n                                    \"&wof2l_fnl_ds_name_4_all_extfiles\" eq \"\" %then\n                                %do;\n                                    adjusted_table_name = \"&wof2l_final_table_name\";\n                                %end;\n                                check_source_file_flag = &wof2l_check_source_file_flag;\n                                load_date = today();\n                                load_time = time();\n                                library = \"%upcase(&wof2l_cas_target_libname)\";\n                            end;\n                        run;\n                        %if &wof2l_debug_mode %then\n                            %put INFORMATION GENERAL: This file is copied into this path: wof2l_libname_path = &wof2l_libname_path;\n                        x \"scp &wo2c_full_file_name &wof2l_libname_path.&wof2l_final_table_name..NEF\";\n\n                    %end; %else %put INFORMATION ALERT: Upload is set to be NOT active!!!;\n                %end; %else\n                %put INFORMATION ALERT: Extension &wo2c_file_extension is unknown!;\n            %end; /* end of fixed width file ELSE*/\n\n            %end; /*end of check for varnumber gt 0 */ %else\n            %do;\n                %put INFORMATION: File #&wo2c_file_counter. &wo2c_full_file_name not uploaded no variable in source file!;\n            %end;\n\n        %end; %else\n        %do;\n            %put INFORMATION: File #&wo2c_file_counter. &wo2c_full_file_name not uploaded since no new version available!!;\n        %end;\n\n    filename inf&wo2c_file_counter clear;\n    %end; /* end file counter */\n\n    %if &wof2l_target_environment eq CAS %then\n    %do;\n        data wof2l_upload_log_ds;\n            set work._DIAP_working_upload_log_ds;\n            if missing(library) then delete;\n        run;\n        %let wof2l_final_table_name = %scan(&wof2l_upload_log_ds, 2, '.');\n        %let wof2l_cas_target_libname = %scan(&wof2l_upload_log_ds, 1, '.');\n        proc casutil;\n            droptable casdata = \"&wof2l_final_table_name\" incaslib = \"&wof2l_cas_target_libname\" quiet;\n            droptable casdata = \"&wof2l_final_table_name\" incaslib = \"&wof2l_cas_target_libname\" quiet;\n        quit;\n        data &wof2l_cas_target_libname..&wof2l_final_table_name;\n            set wof2l_upload_log_ds;\n        run;\n        proc casutil;\n            promote casdata=\"&wof2l_final_table_name\" incaslib=\"&wof2l_cas_target_libname\"\n                    outcaslib=\"&wof2l_cas_target_libname\" casout=\"&wof2l_final_table_name\" ;\n            save casdata=\"&wof2l_final_table_name\" incaslib=\"&wof2l_cas_target_libname\"\n                    outcaslib=\"&wof2l_cas_target_libname\" casout=\"&wof2l_final_table_name\" replace;\n        quit;\n\n        data wof2l_variable_dict_dataset;\n            set &wof2l_variable_dict_dataset;\n        run;\n        %let wof2l_final_table_name = %scan(&wof2l_variable_dict_dataset, 2, '.');\n        %let wof2l_cas_target_libname = %scan(&wof2l_variable_dict_dataset, 1, '.');\n        proc casutil;\n            droptable casdata = \"&wof2l_final_table_name\" incaslib = \"&wof2l_cas_target_libname\" quiet;\n            droptable casdata = \"&wof2l_final_table_name\" incaslib = \"&wof2l_cas_target_libname\" quiet;\n        quit;\n        data &wof2l_cas_target_libname..&wof2l_final_table_name;\n            set wof2l_variable_dict_dataset;\n        run;\n        proc casutil;\n            promote casdata=\"&wof2l_final_table_name\" incaslib=\"&wof2l_cas_target_libname\"\n                    outcaslib=\"&wof2l_cas_target_libname\" casout=\"&wof2l_final_table_name\" ;\n            save casdata=\"&wof2l_final_table_name\" incaslib=\"&wof2l_cas_target_libname\"\n                    outcaslib=\"&wof2l_cas_target_libname\" casout=\"&wof2l_final_table_name\" replace;\n        quit;\n    %put &=wof2l_ds_2_profile_seq;\n        %if \"%upcase(&wof2l_do_profiling)\" = \"DICT_ONLY\" or\n            \"%upcase(&wof2l_do_profiling)\" = \"PROFILE\" %then\n        %do;\n            %automated_profiling_4_DIAP(\n                ap4d_table_2_prep_4_prof_seq = &wof2l_ds_2_profile_seq,\n                ap4d_dict_source_file_path = &wof2l_profile_dict_location,\n                ap4d_prof_execution_option = &wof2l_do_profiling,\n                ap4d_libname_4_dictionaries = %scan(&wof2l_upload_log_ds, 1, '.'),\n                ap4d_viyaversion = &wof2l_viyaversion\n                );\n        %end;\n\n    %end; /* if CAS */ %else\n    %do;\n        data &wof2l_upload_log_ds;\n            set work._DIAP_working_upload_log_ds;\n            if missing(library) then delete;\n        run;\n\n    %end; /* file loop */\n    %end; /*   zero files check */\n%end; /* check for doing only profiling */\n%mend write_out_files_2_libname;\n\n/** FOR TESTING ***\noption mprint source notes;\n%let full_filename_path_seq = ;\nproc sql noprint;\n    select\n        full_file_name\n    into\n        :full_filename_path_seq separated by \" #\"\n    from\n        &overview_ds;\nquit;\n%put &=full_filename_path_seq;\n\n%write_out_files_2_libname(\n    &wo2c_full_file_name_seq,\n    &target_libname,\n    &overview_ds\n    );\n\n\n*********************/\n/******************************************************************************\n                                        %wordcnt\n                                        ________\nCounts the words in a list\n______________________________________________________________________________\n\nUSAGE:                         %wordcnt(list,delim)\n______________________________________________________________________________\n\nDESCRIPTION:\n\nFinds the number of words/tokens in a string.  The user specifies a\ndelimiter e.g. # to identify what separates the words.  The macro should be\ncalled in the following way:\ne.g. %let x=%wordcnt(item1#item2 item2a#item3, '#').\nAfter running the macro x will be assigned the value of wordcnt.\n______________________________________________________________________________\n\nINPUT PARAMETERS AND KEYWORDS:\n\n  list            the name of the string.\n  delim           the delimiter e.g. '#'.\n_________________________________________________________________________\n\nCALLS: none.\n______________________________________________________________________________\n\nNOTES: (Initials, date, summary)\n\nStephan Weigandt    20200406  First officially Released Version\n______________________________________________________________________________\n\n*******************************************************************************/\n%macro wordcnt(\n    list,\n    delim\n    )\n    ;\n    %local\n        word\n        wc_count;\n    %let wc_count = 0;\n    %if %quote(&list) ne %then\n    %do;\n        %let word = %scan(%quote(&list), 1, &delim);\n        %let word = %quote(&word);\n        %do %while (&word ne);\n            %let wc_count = %eval(&wc_count + 1);\n            %let word = %scan(%quote(&list), &wc_count+1, &delim);\n            %let word = %quote(&word);\n        %end;\n    %end;\n    &wc_count\n%mend wordcnt;\n/** FOR TESTING ***\noption mprint source notes ;\n%let item_seq = a b c#d$f g #h#i$j;\n%let separator = '$' ;\n%let separator = '#' ;\n%let separator = ' ' ;\n%let number_of_items = %wordcnt(&item_seq, &separator);\n%put &=number_of_items;\n\n*********************/\n/******************************************************************************\n\n                                %log_dataset_4_upload_maintenance\n                                        ________\n\n\nuploads a list of files that are listed in a \"#\"-separated sequence (without quotes).\nSpecifically this macro maintains the upload log dataset and preparess the upload log dataset\nso it can be used by \"write_out_files_2_libname.sas\" to read in the files that need\nto be read in.\n\n______________________________________________________________________________\n\n\nUSAGE:                         see testing section on the bottom of this code\n\n______________________________________________________________________________\n\nDESCRIPTION:\n\nThis macro uploads all files that are listed in a #-separated macro sequence into CAS.\nIt takes care of the following formats:\n- CSV\n- JMP\n- XLSX.\n______________________________________________________________________________\n\n\nINPUT PARAMETERS AND KEYWORDS:\n\n    ld4um_upload_log_ds_name:\n            name and place of the dataset that keeps track of all the uploaded files.\n    ld4um_upload_new_seq_of_files:\n            list of files separated by # that need to be uploaded to SAS/CAS.\n    ld4um_directory_path_seq:\n            list of directories of files that need to be uploaded separated by #\n    ld4um_substitute_string_seq:\n            if the filename or variable names need to be truncated, one way to get there\n            is to omit certain characters im the target table name/variable name.\n    ld4um_fn_in_fxd_wdth_def_fl_seq:\n            if the macro is called based on \"special definition\" file, this will\n            reference which table name was provided in that dictionary\n    ld4um_max_name_length:\n            the total filename has to be less than 32, this process adds at least 2 characters\n            to the target table name in case when the truncated table name from 2 or more\n            source files end up to be the same name.\n            So this number indicates how many characters are used in case the table name\n            has to be truncated. it is recommneded to use a number less or equal than 30.\n    ld4um_debug_mode:\n            1: writes out additional information to the log.\n            0 (default): no additional information is written out to the log.\n    ld4um_check_modify_date:\n            1 (default): process checks for the modified date of the file to be uploaded and compares\n                        to the load date of that file in case the same file was uploaded in the past.\n            0: modified date is ignored and all files are uploaded no matter what.\n    ld4um_stringseq_2_cutout_from_fn\n            a string sequence separated by # can be provided, which will be cut out of the filename\n\n\n______________________________________________________________________________\n\nNOTES: (Initials, date, summary)\n\nStephan Weigandt    20200406  First officially Released Version\n______________________________________________________________________________\n\n*******************************************************************************/\n\n%macro log_dataset_4_upload_maintenance(\n    ld4um_upload_log_ds_name,\n    ld4um_upload_new_seq_of_files,\n    ld4um_directory_path_seq = ,\n    ld4um_substitute_string_seq = ,\n    ld4um_fn_in_fxd_wdth_def_fl_seq = ,\n    ld4um_max_name_length = 29,\n    ld4um_debug_mode = 0,\n    ld4um_check_modify_date = 1,\n    ld4um_stringseq_2_cutout_from_fn = ,\n    ld4um_force_upload_of_all_files = 0,\n    ld4um_fnl_tblname_from_sheetonly = 1,\n    ld4um_create_unique_target_tblnm = 0,\n    ld4um_delimiter = /,\n    ld4um_fnl_ds_name_4_all_extfiles = ,\n    ld4um_diap_guided_automation = 0,\n    ld4um_gddauto_upd_fls_del_seq = ,\n    ld4um_gddauto_upd_fls_sht_seq = ,\n    ld4um_gddauto_upd_fls_cntt_flg = ,\n    ld4um_gddauto_upd_fls_tgt_seq = ,\n    ld4um_gddauto_upd_fls_hdr_seq =\n\n    );\n\n\n%local\n    ld4um_file_count\n    ld4um_file_counter\n    ld4um_full_file_name\n    ld4um_file_extension\n    ld4um_filename\n    ld4um_full_file_name_length\n    ld4um_table_name\n    ld4um_excel_table_seq\n    ld4um_xlsx_table_count\n    ld4um_xlsx_table_counter\n    ld4um_first_char\n    ld4um_original_table_name\n    ld4um_final_table_name\n    ld4um_sheet_name\n    ld4um_file_name_length\n    ld4um_full_table_name\n    ld4um_original_sheet_name\n    ld4um_sheet_name_length\n    ld4um_onefile\n    ld4um_string_seq_cut_count\n    ld4um_string_seq_cut_counter\n    ld4um_gddauto_upd_fls_del\n    ld4um_gddauto_upd_fls_sht\n    ld4um_gddauto_upd_fls_ct_flag\n    ld4um_gddauto_upd_fls_tgt\n    ld4um_gddauto_upd_fls_hdr_flg\n    ;\n\n\n%let ld4um_gddauto_upd_fls_del = ;\n\n%let ld4um_half_of_max_name_length = %eval(&ld4um_max_name_length / 2);\n%let ld4um_file_count = %wordcnt(&ld4um_upload_new_seq_of_files, '#');\n%let ld4um_string_seq_cut_count = 0;\n%let ld4um_string_seq_cut_count = %wordcnt(&ld4um_stringseq_2_cutout_from_fn, \"#\");\n\nproc datasets lib = work;\n    delete _file_list_complete_info_:;\nquit;\n\n%do ld4um_file_counter = 1 %to &ld4um_file_count;\n/*********\nFirst check the length of the filename and such, since that will become the table name.\nExcel will be treated separately, since one XLS file can contain multiple sheets.\n*********/\n    %let ld4um_full_file_name = %scan(&ld4um_upload_new_seq_of_files, &ld4um_file_counter, '#');\n    %let ld4um_file_extension = %upcase(%trim(%left(%scan(&ld4um_full_file_name, -1))));\n\n    %if \"&ld4um_gddauto_upd_fls_cntt_flg\" ne \"\" %then\n        %let ld4um_gddauto_upd_fls_ct_flag = %scan(&ld4um_gddauto_upd_fls_cntt_flg, &ld4um_file_counter, '#');\n\n    %if \"&ld4um_gddauto_upd_fls_ct_flag\" eq \"\" %then\n        %let ld4um_gddauto_upd_fls_ct_flag = 0;\n\n    %if &ld4um_diap_guided_automation = 1 %then\n    %do;\n        %if \"&ld4um_gddauto_upd_fls_del_seq\" ne \"\" %then\n        %do;\n            %let ld4um_gddauto_upd_fls_del = %scan(&ld4um_gddauto_upd_fls_del_seq, &ld4um_file_counter, '#');\n        %end; %else\n        %do;\n            %let ld4um_gddauto_upd_fls_del = ;\n        %end;\n\n        %if \"&ld4um_gddauto_upd_fls_hdr_seq\" ne \"\" %then\n        %do;\n            %let ld4um_gddauto_upd_fls_hdr_flg = %scan(&ld4um_gddauto_upd_fls_hdr_seq, &ld4um_file_counter, '#');\n        %end; %else\n        %do;\n            %let ld4um_gddauto_upd_fls_hdr_flg = ;\n        %end;\n\n        %let ld4um_gddauto_upd_fls_sht = %scan(&ld4um_gddauto_upd_fls_sht_seq, &ld4um_file_counter, '#');\n        %if %upcase(\"&ld4um_gddauto_upd_fls_sht\") eq \"_DIAP_NA_\" %then\n            %let ld4um_gddauto_upd_fls_sht = ;\n        %if \"&ld4um_gddauto_upd_fls_tgt_seq\" ne \"\" %then\n        %do;\n            %let ld4um_gddauto_upd_fls_tgt = %scan(&ld4um_gddauto_upd_fls_tgt_seq, &ld4um_file_counter, '#');\n            %if %upcase(\"&ld4um_gddauto_upd_fls_tgt\") eq \"_DIAP_NA_\" %then\n                %let ld4um_gddauto_upd_fls_tgt = ;\n        %end; %else\n        %do;\n            %let ld4um_gddauto_upd_fls_tgt = ;\n        %end;\n    %end;\n\n\n    %if \"&ld4um_fn_in_fxd_wdth_def_fl_seq\" ne \"\" %then\n    %do;\n        %let ld4um_fn_in_fxd_wdth_def_fl = %scan(&ld4um_fn_in_fxd_wdth_def_fl_seq, &ld4um_file_counter, '#');\n        %if &ld4um_debug_mode %then\n        %do;\n            %put INFORMATION: General: Working on  &=ld4um_fn_in_fxd_wdth_def_fl;\n            %put INFORMATION: General: Working on  &=ld4um_full_file_name;\n        %end;\n    %end;\n    %let ld4um_filename = %scan(&ld4um_full_file_name, -1, \"&ld4um_delimiter\");\n    %let ld4um_original_table_name = %scan(&ld4um_filename, 1, '.');\n    %if \"&ld4um_directory_path_seq\" ne \"\" %then\n    %do;\n        %let ld4um_directory_path = %scan(&ld4um_directory_path_seq, &ld4um_file_counter, '#');\n    %end; %else\n    %do;\n        %let ld4um_full_file_name_length = %length(&ld4um_full_file_name);\n        %let ld4um_file_name_length = %length(&ld4um_filename);\n        %let ld4um_directory_path = %substr(&ld4um_full_file_name, 1, %eval(&ld4um_full_file_name_length - &ld4um_file_name_length));\n    %end;\n    %let ld4um_onefile = _DIAP_DT;\n\n    %if &ld4um_gddauto_upd_fls_ct_flag = 0 %then\n    %do;\n        filename _DIAP_DT \"&ld4um_full_file_name\";\n    %end; %else\n    %do;\n        filename _DIAP_DT filesrvc folderpath= \"&ld4um_directory_path\" filename=\"&ld4um_filename\";\n    %end;\n\n    %if &ld4um_debug_mode %then\n    %do;\n        %put INFORMATION: General: Working on  &=ld4um_filename;\n        %put INFORMATION: General: Working on  &=ld4um_directory_path;\n    %end;\n    %let ld4um_file_modified_date = ;\n    %if &ld4um_check_modify_date = 1\n/*        and*/\n/*        &ld4um_gddauto_upd_fls_ct_flag = 0 */\n        %then\n    %do;\n        %let ld4um_fid=%sysfunc(fopen(&ld4um_onefile));\n        %let ld4um_Modify_Datetime = %qsysfunc(finfo(&ld4um_fid,Last Modified));\n        %let ld4um_file_modified_date = %substr(&ld4um_Modify_Datetime, 1, 9);\n        %let ld4um_file_modified_time = %substr(&ld4um_Modify_Datetime, 11, 8);\n        %let ld4um_fid=%sysfunc(fclose(&ld4um_fid));\n    %end;\n    %if \"&ld4um_file_modified_date\" eq \"\" %then\n    %do;\n        %let ld4um_file_modified_date = 10Jan2199;\n        %let ld4um_file_modified_time = 00:00:01;\n    %end;\n\n    %if &ld4um_string_seq_cut_count ne 0 %then\n    %do;\n        %do ld4um_string_seq_cut_counter = 1 %to &ld4um_string_seq_cut_count;\n            %let ld4um_string_2_cut = %scan(&ld4um_stringseq_2_cutout_from_fn, &ld4um_string_seq_cut_counter, \"#\");\n\n            %if &ld4um_debug_mode %then\n            %do;\n                %put INFORMATION: General: Omitting character string from File: &ld4um_original_table_name;\n            %end;\n\n            data _null_;\n                ld4um_original_table_name = \"&ld4um_original_table_name\";\n                ld4um_string_2_cut = \"&ld4um_string_2_cut\";\n                length_chk = klength(ld4um_string_2_cut);\n                length_org = klength(ld4um_original_table_name);\n                position = 0;\n                position = kindex(kupcase(ld4um_original_table_name), kupcase(ld4um_string_2_cut));\n                if position ne 0 then\n                do;\n                    if position = 1 and length_chk ne length_org then\n                        ld4um_original_table_name = trim(left(ksubstr(ld4um_original_table_name, position + length_chk)));\n                    else if position = 1 and length_chk eq length_org then\n                        ld4um_original_table_name = \"\";\n                    else\n                        ld4um_original_table_name = trim(left(trim(left(ksubstr(ld4um_original_table_name, 1, position - 1)))||trim(left(ksubstr(ld4um_original_table_name, position + length_chk)))));\n                end;\n                if missing(ld4um_original_table_name) then ld4um_original_table_name = \"ZZ_Check_out_cut_out_string_4_FN_&ld4um_file_counter\";\n                call symput(\"ld4um_original_table_name\", ld4um_original_table_name);\n            run;\n            %let ld4um_original_table_name = %trim(%left(&ld4um_original_table_name));\n\n            %if &ld4um_debug_mode %then\n            %do;\n                %put INFORMATION: General: To New Filename: &ld4um_original_table_name;\n            %end;\n\n        %end;\n    %end;\n\n    %if \"&ld4um_gddauto_upd_fls_tgt\" ne \"\" %then\n        %let ld4um_original_table_name = &ld4um_gddauto_upd_fls_tgt;\n\n    %let ld4um_first_char = %substr(&ld4um_original_table_name, 1, 1);\n    %if &ld4um_debug_mode %then\n    %do;\n        %put INFORMATION: General: Working on  &=ld4um_first_char;\n        %put INFORMATION: General: Working on  &=ld4um_file_modified_date;\n    %end;\n    data _null_;\n        if kcompress(\"&ld4um_first_char\",\"1234567890(-@*+{[}])\") = \"\" then\n            call symput(\"ld4um_first_char\", 1);\n    run;\n    %if &ld4um_first_char = 1 %then\n        %let ld4um_table_name = T&ld4um_original_table_name;\n    %else\n        %let ld4um_table_name = &ld4um_original_table_name;\n        %if &ld4um_debug_mode %then\n    %do;\n        %put INFORMATION: General: Working on  &=ld4um_table_name;\n    %end;\n\n    /*********\n    before checking table name length, reduce characters that need to be dropped\n    mandatorily.\n    *********/\n    %let ld4um_table_name = %upcase(%sysfunc(kcompress(%superQ(ld4um_table_name),%(%))));\n    %if %length(&ld4um_table_name) gt &ld4um_max_name_length %then\n    %do;\n        %let ld4um_table_name = %sysfunc(kcompress(%superQ(ld4um_table_name),&ld4um_substitute_string_seq.));\n        %if %length(&ld4um_table_name) gt &ld4um_max_name_length %then\n            %let ld4um_table_name = %substr(&ld4um_table_name, 1, &ld4um_max_name_length);\n    %end;\n    %let ld4um_original_sheet_name = ;\n    %let ld4um_xlsx_table_counter = 1;\n/*********\nFor Excel this is an attempt to come up with some intelligent way to determine the opimal\nlength of file name and sheet name(s) per Excel file for the target table name.\n*********/\n    %if ((\"&ld4um_file_extension\" eq \"XLSX\" or\n        \"&ld4um_file_extension\" eq \"JSON\" or\n        \"&ld4um_file_extension\" eq \"XML\") or\n        (\"&ld4um_file_extension\" eq \"XLS\" and &ld4um_diap_guided_automation = 1) ) and\n        (\"&ld4um_fn_in_fxd_wdth_def_fl_seq\" eq \"\") %then\n    %do;\n        %if \"&ld4um_file_extension\" eq \"XML\" and\n            &ld4um_diap_guided_automation ne 1 %then\n        %do;\n            filename  tempxlsx \"&ld4um_full_file_name.\";\n            filename  tpxmlmap \"%substr(&ld4um_full_file_name, 1, %eval(%length(&ld4um_full_file_name) - 3))map\";\n            libname tempxlsx xmlv2 automap=replace xmlmap=tpxmlmap;\n            libname tempxlsx xmlv2 xmlmap=tpxmlmap access=READONLY;\n\n        %end; %else\n        %if &ld4um_diap_guided_automation ne 1 %then\n        %do;\n            libname tempxlsx &ld4um_file_extension \"&ld4um_full_file_name.\";\n        %end;\n        %let ld4um_excel_table_seq = ;\n        %if &ld4um_fnl_tblname_from_sheetonly = 1 %then\n        %do;\n            %let ld4um_table_name = ;\n        %end;\n        %let ld4um_org_excel_table_name = &ld4um_table_name;\n        %if &ld4um_diap_guided_automation ne 1 %then\n        %do;\n            proc sql noprint;\n                select\n                    memname\n                into\n                    :ld4um_excel_table_seq separated by \"#\"\n                from\n                    dictionary.tables\n                where\n                    kupcase(libname) = \"TEMPXLSX\";\n            quit;\n        %end; %else\n        %do;\n            %let ld4um_excel_table_seq = &ld4um_gddauto_upd_fls_sht;\n        %end;\n        %let ld4um_xlsx_table_count = %wordcnt(&ld4um_excel_table_seq, '#');\n        %let ld4um_table_name_length = %length(&ld4um_table_name);\n        %if &ld4um_debug_mode %then\n            %put INFORMATION: General: Working on  &ld4um_org_excel_table_name;\n        %do ld4um_xlsx_table_counter = 1 %to &ld4um_xlsx_table_count;\n            %let ld4um_table_name = &ld4um_org_excel_table_name;\n            %let ld4um_original_sheet_name = %scan(&ld4um_excel_table_seq, &ld4um_xlsx_table_counter, \"#\");\n            %let ld4um_sheet_name = %sysfunc(tranwrd(%quote(&ld4um_original_sheet_name),-,_));\n            %let ld4um_sheet_name = %sysfunc(kcompress(%superQ(ld4um_sheet_name),%(%)));\n            /**\n                check if name is final table name is provided through guided automation,\n                then sheet name is not needed.\n            **/\n            %if \"&ld4um_gddauto_upd_fls_tgt\" ne \"\" %then\n                %let ld4um_sheet_name = ;\n            %let ld4um_sheet_name_length = %length(&ld4um_sheet_name);\n            %let ld4um_complete_length = %eval(&ld4um_sheet_name_length + &ld4um_table_name_length);\n            %if &ld4um_debug_mode %then\n            %do;\n                %put INFORMATION: General: Working on  &=ld4um_sheet_name;\n                %put INFORMATION: General: Working on  &=ld4um_complete_length;\n            %end;\n            %if &ld4um_complete_length gt &ld4um_max_name_length %then\n            %do;\n                %let ld4um_sheet_name = %sysfunc(kcompress(%superQ(ld4um_sheet_name),&ld4um_substitute_string_seq.));\n                %let ld4um_sheet_name_length = %length(&ld4um_sheet_name);\n                %if &ld4um_sheet_name_length gt &ld4um_max_name_length %then\n                %do;\n                    %let ld4um_sheet_name = %substr(&ld4um_sheet_name, 1, &ld4um_max_name_length);\n                    %let ld4um_sheet_name_length = &ld4um_max_name_length;\n                %end;\n                %let ld4um_complete_length = %eval(&ld4um_sheet_name_length + &ld4um_table_name_length);\n                %if &ld4um_complete_length gt &ld4um_max_name_length %then\n                %do;\n                    %let ld4um_table_name = %sysfunc(kcompress(%superQ(ld4um_table_name),&ld4um_substitute_string_seq.));\n                %end;\n\n            %end;\n            %let ld4um_table_name_length = %length(&ld4um_table_name);\n            %let ld4um_sheet_name_length = %length(&ld4um_sheet_name);\n            %let ld4um_complete_length = %eval(&ld4um_sheet_name_length + &ld4um_table_name_length);\n            %if %length(&ld4um_sheet_name) gt &ld4um_half_of_max_name_length and\n                %length(&ld4um_table_name) gt &ld4um_half_of_max_name_length %then\n            %do;\n                    %let ld4um_table_name = %substr(&ld4um_table_name, 1, &ld4um_half_of_max_name_length);\n                    %let ld4um_sheet_name = %substr(&ld4um_sheet_name, 1, &ld4um_half_of_max_name_length);\n            %end; %else\n            %if &ld4um_complete_length gt &ld4um_max_name_length %then\n            %do;\n                %if &ld4um_table_name_length gt &ld4um_sheet_name_length %then\n                %do;\n                    %let ld4um_allowed_length = %eval(&ld4um_max_name_length - &ld4um_sheet_name_length);\n                    %let ld4um_table_name = %substr(&ld4um_table_name, 1, &ld4um_allowed_length);\n                %end; %else\n                %do;\n                    %let ld4um_allowed_length = %eval(&ld4um_max_name_length - &ld4um_table_name_length);\n                    %let ld4um_sheet_name = %substr(&ld4um_sheet_name, 1, &ld4um_allowed_length);\n                %end;\n            %end;\n            %let ld4um_table_name = %sysfunc(tranwrd(%quote(&ld4um_table_name&ld4um_sheet_name),%str( ),_));\n            %let ld4um_final_table_name = %sysfunc(tranwrd(%quote(&ld4um_table_name),%str( ),_));\n            %let ld4um_final_table_name = %upcase(%sysfunc(tranwrd(%quote(&ld4um_final_table_name),-,_)));\n/*********\nWrite out information to a temporary file for later consumption in case for Excel.\n*********/\n/** **/\n            %if &ld4um_debug_mode %then\n            %do;\n                %put INFORMATION PROGRESS: File &ld4um_full_file_name;\n                %put INFORMATION PROGRESS: Sheet &ld4um_original_sheet_name;\n                %put INFORMATION PROGRESS: Mofify Date &ld4um_file_modified_date;\n                %put INFORMATION PROGRESS: Modify Time &ld4um_file_modified_time;\n                %put INFORMATION PROGRESS: Final Table Name &ld4um_final_table_name;\n            %end;\n\n\n            data work._file_list_complete_info_&ld4um_file_counter._&ld4um_xlsx_table_counter;\n                length\n                    file_path_full_name $512\n                    original_filename $128\n                    original_sheetname $128\n                    adjusted_table_name $64\n                    adjusted_table_name_org $64\n                    extension $12\n                    library $8\n                    file_delimiter $32\n                    %if \"&ld4um_directory_path_seq\" ne \"\" %then\n                    %do;\n                        directory_path  $512\n                    %end;\n                    ;\n                format\n                    file_modified_date date10.\n                    file_modified_time time8.\n                    ;\n                file_path_full_name = \"&ld4um_full_file_name\";\n                original_filename = \"&ld4um_filename\";\n                original_sheetname = \"&ld4um_original_sheet_name\";\n                adjusted_table_name_org = \"%trim(%left(&ld4um_final_table_name))\";\n                adjusted_table_name = \"\";\n                file_delimiter = \"&ld4um_gddauto_upd_fls_del\";\n                extension = \"&ld4um_file_extension\";\n                library = \"\";\n                file_modified_date = input(\"&ld4um_file_modified_date\", date9.);\n                file_modified_time = input(\"&ld4um_file_modified_time\", time8.);\n                check_source_file_flag = 0;\n                filepath_is_for_sas_content = &ld4um_gddauto_upd_fls_ct_flag;\n                %if &ld4um_gddauto_upd_fls_hdr_flg = 0 %then\n                %do;\n                    variable_name_is_in_header = 0;\n                %end; %else\n                %do;\n                    variable_name_is_in_header = 1;\n                %end;\n                %if \"&ld4um_directory_path_seq\" ne \"\" %then\n                %do;\n                    directory_path = \"&ld4um_directory_path\";\n                %end;\n            run;\n        %end;\n    %end; %else\n    %do;\n        %if \"&ld4um_file_extension\" ne \"DBF\" and\n            \"&ld4um_file_extension\" ne \"PRJ\" and\n            \"&ld4um_file_extension\" ne \"SHX\" %then\n        %do;\n/*********\nWrite out information to a temporary file for later consumption in case for all other cases.\n*********/\n            %let ld4um_final_table_name = %sysfunc(tranwrd(%quote(&ld4um_table_name),%str( ),_));\n            %let ld4um_final_table_name = %sysfunc(tranwrd(%quote(&ld4um_final_table_name),-,_));\n\n    /**\n            %put INFORMATION PROGRESS: File &ld4um_full_file_name;\n            %put INFORMATION PROGRESS: Mofify Date &ld4um_file_modified_date;\n            %put INFORMATION PROGRESS: Modify Time &ld4um_file_modified_time;\n    **/\n            data work._file_list_complete_info_&ld4um_file_counter._&ld4um_xlsx_table_counter;\n                    length\n                        file_path_full_name $512\n                        original_filename $128\n                        original_sheetname $128\n                        adjusted_table_name $64\n                        adjusted_table_name_org $64\n                        extension $12\n                        library $8\n                        file_delimiter $32\n                        %if \"&ld4um_directory_path_seq\" ne \"\" %then\n                        %do;\n                            directory_path  $512\n                        %end;\n                        %if \"&ld4um_fn_in_fxd_wdth_def_fl_seq\" ne \"\" %then\n                        %do;\n                            filename_asin_fxd_wdth_def_fl $128\n                        %end;\n                        ;\n                    format\n                        file_modified_date date9.\n                        file_modified_time time8.\n                        ;\n                    file_path_full_name = \"&ld4um_full_file_name\";\n                    original_filename = \"&ld4um_filename\";\n                    original_sheetname = \"&ld4um_original_sheet_name\";\n                    adjusted_table_name_org = \"%trim(%left(&ld4um_final_table_name))\";\n                    adjusted_table_name = \"\";\n                    library = \"\";\n                    file_delimiter = \"&ld4um_gddauto_upd_fls_del\";\n                    extension = \"&ld4um_file_extension\";\n                    file_modified_date = input(\"&ld4um_file_modified_date\", date9.);\n                    file_modified_time = input(\"&ld4um_file_modified_time\", time8.);\n                    check_source_file_flag = 0;\n                    filepath_is_for_sas_content = &ld4um_gddauto_upd_fls_ct_flag;\n                    %if &ld4um_gddauto_upd_fls_hdr_flg = 0 %then\n                    %do;\n                        variable_name_is_in_header = 0;\n                    %end; %else\n                    %do;\n                        variable_name_is_in_header = 1;\n                    %end;\n                    %if \"&ld4um_directory_path_seq\" ne \"\" %then\n                    %do;\n                        directory_path = \"&ld4um_directory_path\";\n                    %end;\n                    %if \"&ld4um_fn_in_fxd_wdth_def_fl_seq\" ne \"\" %then\n                    %do;\n                        filename_asin_fxd_wdth_def_fl = \"&ld4um_fn_in_fxd_wdth_def_fl\";\n                    %end;\n                run;\n        %end;\n    %end;\n\n\n%end;\n/*********\nPut all the information together into one file and check if there is an original overview\nfile available.\n*********/\n%let ld4um_temp_table_seq_2_check = ;\n\nproc sql noprint;\n    select memname\n    into :ld4um_temp_table_seq_2_check separated by \" \"\n    from dictionary.tables\n    where\n        kupcase(libname) = \"WORK\" and\n        kupcase(memname) contains \"_FILE_LIST_COMPLETE_INFO_\";\nquit;\n\n%if &ld4um_temp_table_seq_2_check eq %then\n%do;\n    data &ld4um_temp_table_seq_2_check;\n        length\n            file_path_full_name $512\n            original_filename $128\n            original_sheetname $128\n            adjusted_table_name $64\n            adjusted_table_name_org $64\n            extension $12\n            library $8\n            file_delimiter $32\n            %if \"&ld4um_directory_path_seq\" ne \"\" %then\n            %do;\n                directory_path  $512\n            %end;\n            %if \"&ld4um_fn_in_fxd_wdth_def_fl_seq\" ne \"\" %then\n            %do;\n                filename_asin_fxd_wdth_def_fl $128\n            %end;\n            ;\n        check_source_file_flag = 0;\n        filepath_is_for_sas_content = 0;\n        if 0;\n    run;\n%end;\n\n\n/*************************\ncheck if table exists in CAS , but it not loaded yet\n**************************/\n%let ld4um_target_environment = ;\n%let ld4um_caslib_temp = %trim(%left(%scan(&ld4um_upload_log_ds_name, 1, '.')));\nproc sql noprint;\n    select distinct(engine)\n    into :ld4um_target_environment\n    from dictionary.libnames\n    where kupcase(libname) = \"%upcase(&ld4um_caslib_temp)\"\n    ;\nquit;\n\n%if %sysfunc(exist(&ld4um_upload_log_ds_name)) = 0 and\n    &ld4um_target_environment eq CAS %then\n%do;\n    %let ld4um_castable_temp = %trim(%left(%scan(&ld4um_upload_log_ds_name, 2, '.')));\n    proc cas;\n        table.caslibinfo\n            result=sss/caslib=\"&ld4um_caslib_temp\"  ;\n        describe sss;\n        print sss;\n        saveresult sss\n            dataout=work._temp_path_data;\n    run;\n    %let ld4um_temp_lib_path = ;\n    proc sql;\n        select path\n        into:ld4um_temp_lib_path\n        from work._temp_path_data;\n    quit;\n\n    %if %sysfunc(fileexist(%trim(%left(&ld4um_temp_lib_path))&ld4um_castable_temp..sashdat)) %then\n    %do;\n        proc casutil\n            incaslib=\"&ld4um_caslib_temp\" outcaslib = \"&ld4um_caslib_temp\";\n            load casdata=\"&ld4um_castable_temp..sashdat\" casout=\"&ld4um_castable_temp\" promote;\n        quit;\n    %end;\n%end;\n\n\n\n%if %sysfunc(exist(&ld4um_upload_log_ds_name)) %then\n%do;\n    data work.ld4um_combined_log_ds;\n        set &ld4um_temp_table_seq_2_check\n        ;\n    run;\n    proc sort\n        data = work.ld4um_combined_log_ds;\n        by\n            file_path_full_name\n            ;\n    quit;\n\n    data work.original_overview_ds;\n        set &ld4um_upload_log_ds_name;\n        if missing(check_source_file_flag) then check_source_file_flag = 0;\n    run;\n    proc sort\n        data = work.original_overview_ds;\n        by\n            file_path_full_name\n            ;\n    quit;\n    data work.overview_new_upload_list;\n        merge\n            work.ld4um_combined_log_ds (in = update)\n            work.original_overview_ds (in = original);\n        by\n            file_path_full_name;\n        format\n            temp_mod_date best12.\n            temp_load_date best12.;\n        temp_mod_date = .;\n        temp_load_date = .;\n        if not update and original then\n            output; else\n        if update and original then\n        do;\n            temp_mod_date = file_modified_date;\n            temp_load_date = load_date;\n            %if &ld4um_force_upload_of_all_files = 0 %then\n            %do;\n                if temp_mod_date < temp_load_date or\n                    (file_modified_date = load_date and\n                    file_modified_time < load_time) then\n                do;\n                    put \"PROCESSSING INFORMATION: Following file is not uploaded again since the last upload date is more recent then the file date:\" ;\n                    put \"PROCESSSING INFORMATION: \" file_path_full_name;\n                    output;\n                end; else\n                do;\n            %end;\n                    load_date = .;\n                    load_time = .;\n                    output;\n            %if &ld4um_force_upload_of_all_files = 0 %then\n            %do;\n                end;\n            %end;\n        end; else\n        if update and not original then\n        do;\n            output;\n        end;\n        drop\n            temp_mod_date\n            temp_load_date\n            file_modified_date\n            file_modified_time;\n    run;\n    data work.zz_ld4um_upload_log_ds_name;\n        set overview_new_upload_list;\n    run;\n%end; %else\n%do;\n    data work.zz_ld4um_upload_log_ds_name;\n        set &ld4um_temp_table_seq_2_check\n        ;\n        format\n            load_time time8.\n            load_date date9.\n        ;\n        load_date = .;\n        load_time = .;\n        drop\n            file_modified_date\n            file_modified_time;\n    run;\n\n%end;\n\nproc sort data = work.zz_ld4um_upload_log_ds_name;\n    by\n        adjusted_table_name_org\n        descending load_date;\nquit;\n\n/**********\nthis datastep deals with duplicates and if there are, we are appending a counter to\n    the newly created table name to make them unique.\n**********/\n%let ld4um_z_prefix = %eval(31 - &ld4um_max_name_length);\ndata &ld4um_upload_log_ds_name;\n    set work.zz_ld4um_upload_log_ds_name;\n    by\n        adjusted_table_name_org;\n    retain counter 0;\n    drop counter;\n    if first.adjusted_table_name_org then\n        counter = 0;\n    counter = counter + 1;\n    %if &ld4um_create_unique_target_tblnm = 1 %then\n    %do;\n        if (first.adjusted_table_name_org ne last.adjusted_table_name_org) or\n            (not first.adjusted_table_name_org and not last.adjusted_table_name_org) then\n        do;\n            if missing(adjusted_table_name) then\n            do;\n                %if \"&ld4um_fnl_ds_name_4_all_extfiles\" eq \"\" %then\n                %do;\n                    adjusted_table_name = trim(left(adjusted_table_name_org)) || \"_\" || put(counter, z&ld4um_z_prefix..);\n                %end; %else\n                %do;\n                    adjusted_table_name = \"&ld4um_fnl_ds_name_4_all_extfiles\";\n                %end;\n            end;\n        end; else\n    %end;\n        %if \"&ld4um_fnl_ds_name_4_all_extfiles\" eq \"\" %then\n        %do;\n            adjusted_table_name = trim(left(adjusted_table_name_org));\n        %end; %else\n        %do;\n            adjusted_table_name = \"&ld4um_fnl_ds_name_4_all_extfiles\";\n        %end;\n\nrun;\n\n\n\n%mend log_dataset_4_upload_maintenance;\n/** FOR TESTING ***\noption mprint source notes;\noption mprint source notes;\n* %include \"C:\\Users\\<<MYUSERID>>\\OneDrive - SAS\\Documents\\Data Management\\Code Examples\\Viya\\DIAP\\Git_Section\\diap\\macros\\wordcnt.sas\";\n%include \"/mnt/downloads/production_code/macros/wordcnt.sas\";\n\n%let upload_new_seq_of_files=/mnt/downloads/ZZ_Testing/top_folder/excel_2/excel_test.xlsx#\n/Public/DIAP/TestFiles/excelfile.xlsx# /mnt/downloads/ZZ_Testing/top_folder/excel_2/_DIAP_guided_execution.csv#\n/Public/DIAP/TestFiles/testdir1/TestData_w_blank_del.csv# /Public/DIAP/TestFiles/testdir2/TestData.csv;\n%let directory_path_seq=/mnt/downloads/ZZ_Testing/top_folder/excel_2/# /Public/DIAP/TestFiles/#\n/mnt/downloads/ZZ_Testing/top_folder/excel_2/# /Public/DIAP/TestFiles/testdir1/# /Public/DIAP/TestFiles/testdir2/;\n%let WOF2L_FNL_DS_NAME_4_ALL_EXTFILES=;\n%let WOF2L_DIAP_GUIDED_AUTOMATION=1;\n%let WOF2L_GDDAUTO_UPD_FLS_DEL_SEQ=# # #blank #;\n%let WOF2L_GDDAUTO_UPD_FLS_SHT_SEQ=Sheet1 #ByPlant # # #;\n%let WOF2L_GDDAUTO_UPD_FLS_CNTT_FLG=0 #1 #0 #1 #1;\n%let WOF2L_GDDAUTO_UPD_FLS_TGT_SEQ=#ByPlantData # #TestBlankCSVFile #;\n%let WOF2L_GDDAUTO_UPD_FLS_HDR_SEQ=1 #1 #1 #1 #1;\n\n\n%let upload_log_ds_name = work._upload_log_work2;\n\n%let substitute_string_seq = aeiouAEOIU;\n%log_dataset_4_upload_maintenance(\n    &upload_log_ds_name,\n    &upload_new_seq_of_files,\n    ld4um_directory_path_seq = &directory_path_seq,\n    ld4um_substitute_string_seq = &substitute_string_seq,\n    ld4um_max_name_length = 29,\n    ld4um_debug_mode = 1,\n    ld4um_check_modify_date = 1,\n    ld4um_stringseq_2_cutout_from_fn = ,\n    ld4um_force_upload_of_all_files = 0,\n    ld4um_fnl_tblname_from_sheetonly = 1,\n    ld4um_create_unique_target_tblnm = 0,\n    ld4um_delimiter = /,\n    ld4um_fnl_ds_name_4_all_extfiles = ,\n    ld4um_diap_guided_automation = 1,\n    ld4um_gddauto_upd_fls_del_seq = &WOF2L_GDDAUTO_UPD_FLS_DEL_SEQ,\n    ld4um_gddauto_upd_fls_sht_seq = &WOF2L_GDDAUTO_UPD_FLS_SHT_SEQ,\n    ld4um_gddauto_upd_fls_cntt_flg = &WOF2L_GDDAUTO_UPD_FLS_CNTT_FLG,\n    ld4um_gddauto_upd_fls_tgt_seq = &WOF2L_GDDAUTO_UPD_FLS_TGT_SEQ,\n    ld4um_gddauto_upd_fls_hdr_seq = &WOF2L_GDDAUTO_UPD_FLS_HDR_SEQ\n    );\n\n\n*********************/\n\n\n/******************************************************************************\n\n                                    %automated_profiling_4_DIAP\n                                            ________\n\n\n\n______________________________________________________________________________\n\n\nUSAGE:                         see testing section on the bottom of this code\n\n______________________________________________________________________________\n\nDESCRIPTION:\n\n  This macro is used within DIAP to integrate the AUTOPROFILING app developed\nby Joao Olivera in SAS Portugal. It bridges the information coming from DIAP to the\nAutorprofiling application.\n______________________________________________________________________________\n\n\nINPUT PARAMETERS AND KEYWORDS:\n\n    ap4d_table_2_prep_4_prof_seq: sequence of tables loaded to CAS separated by #\n    ap4d_dict_source_file_name: this parameter is not used at the moment\n    ap4d_dict_source_file_path: this parameter is not used at the moment\n    ap4d_prof_execution_option:\n        2 options\n            DICT_ONLY:  only fills in the default dictionary entries needed for the\n                        AUTOPROFILING app. The actual profiling needs to be triggered\n                        separatedly.\n            PROFILE:    This option fills in the default dictionary entries AND also\n                        triggers the execution of creating the actual profiles.\n    ad4d_fcmp_execution:\n        2 options\n            1: used proc FCMP to execute commands\n            0: uses traditional macro processing to execute commands\n______________________________________________________________________________\n\nNOTES: (Initials, date, summary)\n\nStephan Weigandt    20200707  First officially Released Version\n______________________________________________________________________________\n\n*******************************************************************************/\n\n%macro automated_profiling_4_DIAP(\n    ap4d_table_2_prep_4_prof_seq = ,\n    ap4d_dict_source_file_name = ,\n    ap4d_dict_source_file_path = ,\n    ap4d_prof_execution_option = DICT_ONLY,\n    ad4d_fcmp_execution = 1,\n    ap4d_libname_4_dictionaries = ,\n    ap4d_viyaversion = 35\n    );\n\n    %let ViyaVersion = &ap4d_viyaversion;        /* constant used on the macro routine called | 34 = Viya 3.4 | 35 = Viya 3.5 */\n    %let DataMartLib = &ap4d_libname_4_dictionaries;    /* constant used on the macro routine called | Data Mart Location */\n\n\n\n\n    /* Including the Auto Profiling code that creates / populates the Data Mart*/\n\n    %local\n        ap4d_table_count\n        ap4d_table_counter\n        ap4d_full_table_name\n        ap4d_col_seq\n        ap4d_ds_name\n        ap4d_ds_libname\n        ap4d_col_counter\n        ap4d_col_count\n        ap4d_col_name\n        ap4d_col_name_seq\n        ap4d_col_type_seq\n    ;\n    %let ap4d_table_count = %wordcnt(&ap4d_table_2_prep_4_prof_seq, \"#\");\n\n\n    %do ap4d_table_counter = 1 %to &ap4d_table_count;\n        %let ap4d_full_table_name = %scan(&ap4d_table_2_prep_4_prof_seq, &ap4d_table_counter, \"#\");\n        %let ap4d_ds_libname = %scan(&ap4d_full_table_name, 1, \".\");\n        %let ap4d_ds_name = %scan(&ap4d_full_table_name, 2, \".\");\n        %let ap4d_col_name_seq = ;\n        %let ap4d_col_type_seq = ;\n        %if \"%upcase(&ap4d_prof_execution_option)\" = \"DICT_ONLY\" or\n            \"%upcase(&ap4d_prof_execution_option)\" = \"PROFILE\" %then\n        %do;\n\n            %let ap4d_final_table_name = &ap4d_ds_name;\n            %let ap4d_cas_target_libname = DM_DtMrt;\n            %let ap4d_max_varnumber_&ap4d_table_counter = ;\n            proc sql noprint;\n                select\n                    nobs into :ap4d_max_varnumber_&ap4d_table_counter\n                from dictionary.tables\n                where\n                    kupcase(libname) = \"%upcase(&ap4d_ds_libname)\" and\n                    kupcase(memname) = \"%upcase(&ap4d_ds_name)\";\n            quit;\n\n\n\n            %do ap4d_var_counter = 1 %to &&ap4d_max_varnumber_&ap4d_table_counter;\n                %local\n                    ap4d_varname_seq_&ap4d_table_counter._&ap4d_var_counter\n                    ap4d_type_seq_&ap4d_table_counter._&ap4d_var_counter\n                    ;\n                %let ap4d_varname_seq_&ap4d_table_counter._&ap4d_var_counter = ;\n                %let ap4d_type_seq_&ap4d_table_counter._&ap4d_var_counter = ;\n            %end;\n\n            proc sql noprint;\n                create table columns_4_prfl_&ap4d_table_counter as\n                select\n                    name,\n                    type\n                from\n                    dictionary.columns\n                where\n                    kupcase(libname) = \"%upcase(&ap4d_ds_libname)\" and\n                    kupcase(memname) = \"%upcase(&ap4d_ds_name)\"\n                ;\n            quit;\n\n\n\n            data _null_;\n                set columns_4_prfl_&ap4d_table_counter;\n                suffix = put(_n_, 6.);\n                call symput(cats(\"ap4d_varname_seq_&ap4d_table_counter._\", suffix), name);\n                call symput(cats(\"ap4d_type_seq_&ap4d_table_counter._\", suffix), type);\n            run;\n            %do ap4d_var_counter = 1 %to &&ap4d_max_varnumber_&ap4d_table_counter;\n                %let ap4d_varname_seq_&ap4d_table_counter._&ap4d_var_counter = %trim(%left(&&ap4d_varname_seq_&ap4d_table_counter._&ap4d_var_counter));\n                %let ap4d_type_seq_&ap4d_table_counter._&ap4d_var_counter = %trim(%left(&&ap4d_type_seq_&ap4d_table_counter._&ap4d_var_counter));\n            %end;\n            %let ap4d_varname_seq_count = &&ap4d_max_varnumber_&ap4d_table_counter;\n                %do ap4d_var_counter = 1 %to &&ap4d_max_varnumber_&ap4d_table_counter;\n                    %put INFORMATION: ap4d_varname_seq_&ap4d_table_counter._&ap4d_var_counter = &&ap4d_varname_seq_&ap4d_table_counter._&ap4d_var_counter;\n                    %put INFORMATION: ap4d_type_seq_&ap4d_table_counter._&ap4d_var_counter = &&ap4d_type_seq_&ap4d_table_counter._&ap4d_var_counter;\n                %end;\n\n\n            proc casutil;\n                droptable casdata = \"&ap4d_final_table_name\" incaslib = \"&ap4d_cas_target_libname\" quiet;\n                droptable casdata = \"&ap4d_final_table_name\" incaslib = \"&ap4d_cas_target_libname\" quiet;\n            quit;\n\n\n            data &ap4d_cas_target_libname..&ap4d_ds_name;\n                length\n                    _Definition_Version        4\n                    _Definition_date            8\n                    _rawdta_lib_name            $40\n                    _rawdta_table_name         $40\n                    _column_2profile         $1\n                    _column_mr_group            $128\n                    _column_name                $40\n                    _column_name_matchcode    $64\n                    _column_label            $64\n                    _column_meaning             $256\n                    _column_func_meaning        $64\n                    _column_iscritical         $1\n                    _column_type                $32\n                    _column_datatype         $32\n                    _column_data_fmt            $64\n                    _column_decimals            8\n                    _column_pattern            $2048\n                    _column_minmax            $64\n                    _DQ_Resolution_Actions     $2048\n                    _DQ_locale                $10\n                    _DQ_match_level_names    3.0\n                    _DQ_match_level_addrs    3.0\n                    _Func_Validation            $128\n                    _Func_ValDesc            $2048\n                    _SID_model_name            $128\n                    _SID_model_table            $40\n                    _SID_model_caslib        $40\n                    _SID_model_params        $2048\n                    _max_sample_size            8\n                ;\n\n                %do ap4d_var_counter = 1 %to &&ap4d_max_varnumber_&ap4d_table_counter;\n                    _column_2profile = \"Y\";\n                    _column_name = \"&&ap4d_varname_seq_&ap4d_table_counter._&ap4d_var_counter\";\n                    _column_label = \"&&ap4d_varname_seq_&ap4d_table_counter._&ap4d_var_counter\";\n                    _column_iscritical = \"Y\";\n                    _column_type =\n                    %if \"%upcase(&&ap4d_type_seq_&ap4d_table_counter._&ap4d_var_counter)\" = \"CHAR\" %then\n                    %do;\n                        \"CHAR\"\n                    %end; %else\n                    %do;\n                        \"DOUBLE\"\n                    %end;\n                    ;\n                    _column_datatype = _column_type;\n                    _max_sample_size = 250;\n                    _rawdta_lib_name = \"&ap4d_ds_libname\";\n                    _rawdta_table_name = \"&ap4d_ds_name\";\n                    output;\n                %end;\n            run;\n\n            proc casutil;\n                promote casdata=\"&ap4d_final_table_name\" incaslib=\"&ap4d_cas_target_libname\"\n                        outcaslib=\"&ap4d_cas_target_libname\" casout=\"&ap4d_final_table_name\" ;\n            quit;\n\n\n            %let ViyaVersion = 35;\n            %let DataMartLib = DM_DtMrt;\n            %let inSrcFile = &ap4d_ds_name..csv;\n            %let inSrcFileType = CSV;\n            %let inSrcTable = &ap4d_ds_name.;\n            %let do_update_defs = YES;\n            %if &ap4d_table_counter = &ap4d_table_count %then\n            %do;\n                %let save_to_disk = YES;\n            %end; %else\n            %do;\n                %let save_to_disk = NO;\n            %end;\n            %let prfTableSuffix=_PRF;            /* Suffix to be used on the profile results table */\n            %if &ad4d_fcmp_execution = 1 %then\n            %do;\n\n                data _null_;\n                    retain     _inViyaVer _dmCasLib\n                            _inSrcFile _inSrcFileType _inSrcTable\n                            _do_update_defs _save_to_disk\n                    ;\n                    length     _inViyaVer         $4\n                            _dmCasLib        $40\n                            _inSrcFile         $40\n                            _inSrcFileType    $10\n                            _inSrcTable     $40\n                            _do_update_defs    $3\n                            _save_to_disk     $3\n\n                            _val    $80\n                            len        8\n                            maxlen    8\n                    ;\n                    /* Looping throughout the JSON set */\n\n                        /* Initiation of variables and stuff */\n                            _dmCasLib = \"&DataMartLib\";\n                            _inViyaVer= &ViyaVersion;\n\n                        /* Making sure that the params content has no spaces / blanks and special characters\n                        although this should be already handled on the javascript gathering param values*/\n                        _inSrcFile = \"&ap4d_cas_target_libname..SASDS\";\n                        _inSrcFileType = \"&inSrcFileType\";\n                        _inSrcTable = \"&ap4d_final_table_name\";\n                        _do_update_defs = \"&do_update_defs\";\n                        _save_to_disk = \"&save_to_disk\";\n\n                        put \"======================| Run_Loading_Dictionary with |======================\";\n\n                        put _inViyaVer=\n                            _dmCasLib=\n                            _inSrcFile=\n                            _inSrcFileType=\n                            _inSrcTable=\n                            _do_update_defs=\n                            _save_to_disk=;\n                        put \"=========================| Calling the Program |==========================\";\n                        if (_inViyaVer > 0) then do;\n                            call TblDict_Load_Dictionary(_inViyaVer,        _dmCasLib,\n                                                        _inSrcFile,         _inSrcTable,\n                                                        _do_update_defs,     _save_to_disk\n                                                        );\n                        end;\n\n                run;\n            %end; %else\n            %do;\n                %put &=DataMartLib;\n                %load_DTA_prf_rawdta_tabledict(\n                                    inViyaVer      = &ViyaVersion,\n                                    dmCasLib      = &DataMartLib,\n                                    inSrcFile      = &ap4d_cas_target_libname..SASDS,\n                                    inSrcTable      = &ap4d_final_table_name,\n                                    do_update_defs= &do_update_defs,\n                                    save_to_disk  = &save_to_disk\n                                  );\n\n\n            %end;\n\n            proc casutil;\n                droptable casdata = \"&ap4d_final_table_name\" incaslib = \"&ap4d_cas_target_libname\" quiet;\n            quit;\n\n        %end; /** end if **/\n    %end;\n    %do ap4d_table_counter = 1 %to &ap4d_table_count;\n        %let ap4d_full_table_name = %scan(&ap4d_table_2_prep_4_prof_seq, &ap4d_table_counter, \"#\");\n        %let ap4d_ds_libname = %scan(&ap4d_full_table_name, 1, \".\");\n        %let ap4d_ds_name = %scan(&ap4d_full_table_name, 2, \".\");\n\n        %if \"%upcase(&ap4d_prof_execution_option)\" = \"PROFILE\" %then\n        %do;\n            %let ViyaVersion = 35;\n            %let DataMartLib = DM_DtMrt;\n            %let inSrcFile = &ap4d_ds_name..csv;\n            %let inSrcFileType = CSV;\n            %let prfTableSuffix=_PRF;\n            %let inSrcTable = &ap4d_ds_name.;\n            %let do_update_defs = YES;\n            %if &ap4d_table_counter = &ap4d_table_count %then\n            %do;\n                %let save_to_disk = YES;\n            %end; %else\n            %do;\n                %let save_to_disk = NO;\n            %end;\n\n            %if &ad4d_fcmp_execution = 1 %then\n            %do;\n                data _null_;\n                    retain     _in_rawdta_lib _in_rawdta_table _in_prf_table_desc\n                            _dm_cas_lib _in_prf_table _do_append_master _save_to_disk\n                    ;\n                    length     _in_rawdta_lib         $40\n                            _in_rawdta_table     $40\n                            _in_prf_table        $40\n                            _dm_cas_lib            $40\n                            _in_prf_table_desc     $255\n                            _do_append_master     $3\n                            _save_to_disk         $3\n\n                            _val    $256\n                            len        8\n                            maxlen    8\n                    ;\n                            _dm_cas_lib = \"&DataMartLib\";\n                            _inViyaVer= &ViyaVersion;\n\n                        /* Making sure that the params content has no spaces / blanks and special characters\n                        although this should be already handled on the javascript gathering param values*/\n                        _in_rawdta_lib = \"&ap4d_ds_libname\";\n                        _in_rawdta_table = strip(\"&ap4d_ds_name\");\n                        _in_prf_table_desc = \"Automated Profile prepared by DIAP\";\n                        _do_append_master = \"&do_update_defs\";\n                        _save_to_disk = \"&save_to_disk\";\n\n\n                        put \"======================| Run_Auto_Profiling |======================\";\n                        /* Generating the Profiling Table Name =\n                            raw data table name plus the Suffix defined by 'prfTableSuffix' */\n                        _val = kcompress(kupcase(_in_rawdta_table));\n                        len = klength(_val);\n                        maxlen = 32 - klength(\"_PRF\");\n                        if len gt maxlen then  _in_prf_table = strip(ksubstrn(_val, 1, maxlen) || \"_PRF\");\n                        else                   _in_prf_table = strip(ksubstrn(_val, 1, len) || \"_PRF\");\n\n                        put _in_rawdta_lib=\n                            _in_rawdta_table=\n                            _in_prf_table=\n                            _in_prf_table_desc=\n                            _dm_cas_lib=\n                            _do_append_master=\n                            _save_to_disk=;\n                        put \"======================| Calling the Program |=======================\";\n                        call DQ_AutoProfile_Run(\n                                _in_rawdta_lib,\n                                _in_rawdta_table,\n                                _in_prf_table,\n                                _in_prf_table_desc,\n                                _dm_cas_lib,\n                                _do_append_master,\n                                _save_to_disk\n                                                );\n\n                run;\n            %end; %else\n            %do;\n                %let ap4d_ds_name = %trim(%left(%upcase(&ap4d_ds_name));\n                %let ap4d_length_ds_name = %length(&ap4d_ds_name);\n                %let ap4d_legnth_prefix = %length(&prfTableSuffix);\n                %let ad4d_max_length_ds_name = %eval(32 - &ap4d_legnth_prefix);\n                %if &ap4d_length_ds_name gt &ad4d_max_length_ds_name %then\n                %do;\n                    %let in_prf_table = %trim(%left(%substr(&ap4d_ds_name, 1, &ad4d_max_length_ds_name)))&prfTableSuffix;\n                %end; %else\n                %do;\n                    %let in_prf_table = %trim(%left(%substr(&ap4d_ds_name, 1, &ap4d_length_ds_name)))&prfTableSuffix;\n                %End;\n\n                %let in_prf_tabl = %trim(%left((&in_prf_tabl)));\n\n                %do_profile_results2(\n                            in_rawdta_lib        = &ap4d_ds_libname,\n                            in_rawdta_table   = &ap4d_ds_name,\n                            in_prf_table        = &in_prf_table,\n                            in_prf_table_desc = Automated Profile prepared by DIAP,\n                            dm_cas_lib        = &DataMartLib,\n                            do_append_master  = &do_update_defs,\n                            save_to_disk        = &save_to_disk\n                            );\n            %end;\n        %end;\n    %end; /**     end of ap4d_table_counter  **/\n%mend automated_profiling_4_DIAP;\n\n/** FOR TESTING ***\noption mprint source notes;\n%include \"/mnt/downloads/production_code/macros/wordcnt.sas\";\n    OPTIONS cashost=\"&_CASHOST_\" casport=&_CASPORT_;\n    cas;\n    caslib _all_ assign;\nlibname test \"/mnt/downloads/blast_covid/data/100_Loading\";\n%let table_2_prep_4_prof_seq = test._variable_dictionary_bl_load#test.first_blast#test.first_blast_expanded1#test._upload_log_bl_load;\n%let dict_source_file_name = ;\n%let profile_option = PROFILE;\n%let dict_source_file_path = /Public/DM_Assets/SAS_DQ_AUTOPROFILE/Imports;\n%automated_profiling_4_DIAP(\n    ap4d_table_2_prep_4_prof_seq = &table_2_prep_4_prof_seq,\n    ap4d_dict_source_file_name = &dict_source_file_name,\n    ap4d_dict_source_file_path = &dict_source_file_path,\n    ap4d_prof_execution_option = &profile_option\n    );\n\n*********************/\n/******************************************************************************\n\n                                    %wrapper_import_files_into_viya\n                                                ________\n\n\nthis is the core wrapper of DIAP.\nIt takes in all the parameters and prepares and starts the process\n- to find the files in the directories\n- process the files found in the directories\n- manages the metadata of those files and cleans up the metadata\n- triggers the profiling execution .\n\n______________________________________________________________________________\n\n\nUSAGE:        see testing section on the bottom of this code\n\n______________________________________________________________________________\n\nDESCRIPTION:\n\n  DIAP can handle a whole variety of external files to be uploaded into SAS/CAS.\n\n______________________________________________________________________________\n\n\nINPUT PARAMETERS AND KEYWORDS:\n\n    wifiv_inRootDir:\n        default: /mnt/downloads/ZZ_Testing/top_folder/\n        This is the path to the top level directory that DIAP should use to start looking for\n        files that should be uploaded.\n    wifiv_inExtension:\n        default: *\n        provide which extensions to look for. Choose * (default) to look for any extensions.\n    wifiv_inTargetLib:\n        default: work\n        provide a SAS or CAS libname where the files that are found in the directory should be uploaded to.\n        The system can handle SAS or CAS libnames.\n    wifiv_inUpldLogDS:\n        This parameter is not used at this point.\n    wifiv_inSbstStrgSeq:\n        default: aeiouAEIOU\n        This sequence of characters determine which characters will be omitted if the target file name or variable name\n        needs to be truncated.\n    wifiv_meta_centralized:\n        default: 1\n        1: if set to 1, then all the information will be centrally stored in the library as specified in wifiv_libname_meta_centralized\n            libname. The overview of the uploaded tables are stored under\n                _Upload_log ,\n            and the overview of the variables created is stored in this table:\n                _Variable_Dictionary\n        0: if set to 0, then the metainformation about the upload process is stored within the chosen target library\n            as specified in wifiv_inTargetLib.\n            The overview of the uploaded tables are stored under\n                _Upload_log_&wifiv_inTargetLib,\n            and the overview of the variables created is stored in this table:\n                _Variable_Dictionary_&wifiv_inTargetLib\n    wifiv_libname_meta_centralized:\n        default: DM_DtMrt\n        this parameter determines the library name where the metainformation about this process is stored in case a\n        centralized location is desired.\n    wifiv_max_table_name_length:\n        default: 27\n        determines the maximum table length allowed after truncation of the name. It is recommended to have a value less than\n        30 for sure, since the underscore plus a counter is added in case the truncated name is the name for multiple source files.\n    wifiv_debug_mode:\n        default: 0\n        1: writes out additional detail information about the process to the log window.\n        0: no additional information is written out.\n    wifiv_shp_enrich_with_zip:\n        default: 0\n        0: Shape files are read in as is.\n        1: additional zip information is merged into the SHAPE files assuming that they contain lattitude and longitude\n            information. It also needs a specific lookup table for the process to be available.\n    wifiv_do_profiling:\n        default: NO\n        NO: no additional processing is done for profiling purposes. This is also automatically chosen if the underlying\n            parameters are not set that are needed for the processing of profiling.\n        DICT_ONLY:  only fills in the default dictionary entries needed for the\n            AUTOPROFILING app. The actual profiling needs to be triggered separatedly.\n        PROFILE:    This option fills in the default dictionary entries AND also\n            triggers the execution of creating the actual profiles.\n        The last 2 options require the \"Autoprofiling\" application to be included with DIAP. For details check\n        the installation instructions.\n    wifiv_profiling_dict_location:\n        This parameter is NOT used at this point.\n    wifiv_profiling_code_location:\n        This parameter is NOT used at this point.\n\n______________________________________________________________________________\n\nNOTES: (Initials, date, summary)\n\nStephan Weigandt    20200406  First officially Released Version\n______________________________________________________________________________\n\n*******************************************************************************/\n%macro wrapper_import_files_into_viya(\n    wifiv_inRootDir        = /mnt/downloads/ZZ_Testing/top_folder/,\n    wifiv_inExtension   = *,\n    wifiv_inTargetLib        = work,\n    wifiv_inUpldLogDS = _NONE_,\n    wifiv_inSbstStrgSeq        = aeiouAEIOU,\n    wifiv_meta_centralized = 1,\n    wifiv_libname_meta_centralized = DM_DtMrt,\n    wifiv_max_table_name_length = 27,\n    wifiv_debug_mode = 0,\n    wifiv_shp_enrich_with_zip = 0,\n    wifiv_do_profiling = NO,\n    wifiv_profiling_dict_location = ,\n    wifiv_profiling_code_location = ,\n    wifiv_path_2_python_shape_script = ,\n    wifiv_csv_big_data_mode = 0,\n    wifiv_write_log_into_file = 1,\n    wifiv_provide_default_log_path = ,\n    wifiv_drop_missing_vars = 0,\n    wifiv_stringseq_2_cutout_from_fn = ,\n    wifiv_stringseq_2_cutout_from_vn = ,\n    wifiv_prefix_4_suspicious_src_fl = CHK,\n    wifiv_max_lgth_of_suspicious_str = 4,\n    wifiv_check_csv_4_num = 0,\n    wifiv_macro_varname_cashost = controller.viya.sas,\n    wifiv_macro_varname_casport = 5570,\n    wifiv_viyaversion = 35,\n    wifiv_install_mode_in_SASContent = 0,\n    wifiv_chck_txt_fl_4_spcl_chrct = 0,\n    wifiv_spcl_chrctr_sq2chck_in_hex = 0A#0D,\n    wifiv_spcl_chrct_chck_rplcmnt_hx = 00,\n    wifiv_make_imported_data_prsstnt = 1,\n    wifiv_force_upload_of_all_files = 0,\n    wifiv_traverse_directories = 1,\n    wifiv_skip_files_start_with_seq = ,\n    wifiv_skip_files_end_with_seq = ,\n    wifiv_fnl_tblname_from_sheetonly = 0,\n    wifiv_create_unique_target_tblnm = 1,\n    wifiv_delimiter = /,\n    wifiv_chck_4_spcl_char_in_vars = 1,\n    wifiv_fnl_ds_name_4_all_extfiles = ,\n    wifiv_diap_guided_auto_fl_loc =\n);\n\n%put INFORMATION GENERAL: &=wifiv_inExtension;\n%put INFORMATION GENERAL: &=wifiv_inTargetLib;\n%put INFORMATION GENERAL: &=wifiv_inUpldLogDS;\n\n%local\n    wifiv_temp_file\n    wifiv_temp_path_length\n    wifiv_temp_file_length\n    wifiv_temp_path_only\n    wifiv_diap_gdd_auto_fl_loc_src\n    wifiv_diap_gdd_auto_fl_loc_only\n    wifiv_temp_count\n    wifiv_diap_guided_automation\n    wifiv_gddauto_upd_fls_del_seq\n    wifiv_gddauto_upd_fls_dir_seq\n    wifiv_gddauto_upd_fls_sht_seq\n    wifiv_gddauto_upd_fls_cntt_flg\n    wifiv_gddauto_upd_fls_tgt_seq\n    ;\n\n%let fixed_width_file_definition_name = _DIAP_Special_File_Definition.csv;\n\n%let wifiv_diap_gdd_auto_fl_loc_src = ;\n%let wifiv_diap_gdd_auto_fl_loc_only = ;\n%if \"&wifiv_diap_guided_auto_fl_loc\" = \"\" %then\n%do;\n    %let wifiv_diap_guided_automation = 0;\n    %let wifiv_gddauto_upd_fls_del_seq = ;\n    %let wifiv_gddauto_upd_fls_dir_seq = ;\n    %let wifiv_gddauto_upd_fls_sht_seq = ;\n    %let wifiv_gddauto_upd_fls_hdr_seq = ;\n    %let wifiv_gddauto_upd_fls_cntt_flg = ;\n    %let wifiv_gddauto_upd_fls_tgt_seq = ;\n\n    %let length = %length(&root_directory);\n    %let last_char = %substr(&root_directory,&length, 1);\n\n    %if \"&last_char\" ne \"&wifiv_delimiter.\" %then\n        %let root_directory = &root_directory.&wifiv_delimiter.;\n\n\n%end; %else\n%do;\n\n    %let wifiv_diap_gdd_auto_fl_loc_src = %scan(&wifiv_diap_guided_auto_fl_loc, 1, \":\");\n    %let wifiv_gdd_src_length = %length(&wifiv_diap_gdd_auto_fl_loc_src);\n    %let wifiv_gdd_loc_length = %length(&wifiv_diap_guided_auto_fl_loc);\n    %if &wifiv_debug_mode = 1 %then\n        %put &=wifiv_diap_guided_auto_fl_loc;\n    %if &wifiv_debug_mode = 1 %then\n        %put &=wifiv_gdd_src_length;\n    %if &wifiv_debug_mode = 1 %then\n        %put &=wifiv_diap_gdd_auto_fl_loc_src;\n    %if &wifiv_debug_mode = 1 %then\n        %put &=wifiv_gdd_loc_length;\n\n    %let wifiv_diap_gdd_auto_fl_loc_only = %substr(&wifiv_diap_guided_auto_fl_loc, %eval(&wifiv_gdd_src_length + 2));\n\n    %let do_processing = 1;\n    %if %upcase(\"&wifiv_diap_gdd_auto_fl_loc_src\") eq \"SASSERVER\" %then\n    %do;\n        filename _DIAP_GA \"&wifiv_diap_gdd_auto_fl_loc_only\";\n    %end; %else\n    %do;\n        %let wifiv_temp_file = %scan(&wifiv_diap_gdd_auto_fl_loc_only, -1, \"&wifiv_delimiter\");\n        %let wifiv_temp_path_length = %length(&wifiv_diap_gdd_auto_fl_loc_only);\n        %let wifiv_temp_file_length = %length(&wifiv_temp_file);\n        %let wifiv_temp_path_only = %substr(&wifiv_diap_gdd_auto_fl_loc_only, 1, %eval(&wifiv_temp_path_length - &wifiv_temp_file_length));\n\n        filename _DIAP_GA\n                filesrvc\n                folderpath     = \"&wifiv_temp_path_only\"\n                filename    = \"&wifiv_temp_file\";\n    %end;\n    %let wifiv_diap_guided_automation = 1;\n    %let wifiv_gddauto_upd_fls_del_seq = ;\n    %let wifiv_gddauto_upd_fls_dir_seq = ;\n    %let wifiv_gddauto_upd_fls_sht_seq = ;\n    %let wifiv_gddauto_upd_fls_cntt_flg = ;\n    %let wifiv_gddauto_upd_fls_hdr_seq = ;\n    %let wifiv_gddauto_upd_fls_tgt_seq = ;\n    %let wifiv_ga_full_filename_path_seq = ;\n    %let wifiv_fllist_contains_fixed_def = 0;\n\n    proc import\n        datafile = _DIAP_GA\n        out = work._DIAP_guided_execution_order\n        dbms=dlm replace;\n        delimiter = \",\" ;\n        datarow = 2;\n        guessingrows = 200;\n        getnames=yes;\n    quit;\n\n    %let wifiv_temp_count = 0;\n    %let wifiv_temp_target_count = 0;\n    %let wifiv_temp_header_flag_count = 0;\n\n    proc sql;\n        select\n            count(name)\n        into :wifiv_temp_count\n        from dictionary.columns\n        where kupcase(libname) = \"WORK\" and\n        kupcase(memname) = \"_DIAP_GUIDED_EXECUTION_ORDER\" and\n        kupcase(name) = \"DELIMITER_FOR_TEXT_FILES\";\n    quit;\n    proc sql;\n        select\n            count(name)\n        into :wifiv_temp_target_count\n        from dictionary.columns\n        where kupcase(libname) = \"WORK\" and\n        kupcase(memname) = \"_DIAP_GUIDED_EXECUTION_ORDER\" and\n        kupcase(name) = \"TARGET_TABLE_NAME\";\n    quit;\n    proc sql;\n        select\n            count(name)\n        into :wifiv_temp_header_flag_count\n        from dictionary.columns\n        where kupcase(libname) = \"WORK\" and\n        kupcase(memname) = \"_DIAP_GUIDED_EXECUTION_ORDER\" and\n        kupcase(name) = \"COLUMN_NAMES_IN_FIRST_ROW\";\n    quit;\n    proc sql;\n        select\n            count(full_file_name)\n        into\n            :wifiv_fllist_contains_fixed_def\n        from work._DIAP_guided_execution_order\n        where kupcase(full_file_name) contains %upcase(\"&fixed_width_file_definition_name\");\n    quit;\n\n    data work._DIAP_guided_execution_order;\n        length target_table_name $64.\n                delimiter_for_text_files $64.\n                sheet_xml_json_tablename $64.;\n        set work._DIAP_guided_execution_order (rename=(delimiter_for_text_files = del_ftf_old\n                                                        target_table_name = ttn_old\n                                                        sheet_xml_json_tablename = sheet_xjt_old));\n        file_name = kscan(full_file_name, -1, \"&wifiv_delimiter\");\n        drop\n            file_name_length\n            full_name_length\n            del_ftf_old\n            ttn_old\n            sheet_xjt_old\n            ;\n        if missing(ttn_old) then\n            target_table_name = \"_DIAP_NA_\";\n        else\n            target_table_name = ttn_old;\n        if missing(del_ftf_old) then\n            delimiter_for_text_files = \"_DIAP_NA_\";\n        else\n            delimiter_for_text_files = del_ftf_old;\n        if missing(sheet_xjt_old) then\n            sheet_xml_json_tablename = \"_DIAP_NA_\";\n        else\n            sheet_xml_json_tablename = sheet_xjt_old;\n        %if &wifiv_temp_header_flag_count ne 0 %then\n        %do;\n            if missing(column_names_in_first_row) then\n                column_names_in_first_row = 1;\n        %end;\n        if missing(is_in_SAS_Content_flag) then\n            is_in_SAS_Content_flag = 0;\n        file_name_length = klength(file_name);\n        full_name_length = klength(full_file_name);\n        directory_path = ksubstr(full_file_name, 1, full_name_length - file_name_length);\n    run;\n\n\n\n%end;\n\n%let wifiv_root_dir_src = %upcase(%scan(&wifiv_inRootDir, 1, \":\"));\n%let wifiv_root_is_sas_content = 0;\n%if %upcase(\"&wifiv_root_dir_src\") eq \"SASCONTENT\" %then\n%do;\n    %let root_directory = %scan(&wifiv_inRootDir, 2, \":\");\n    %let wifiv_root_is_sas_content = 1;\n%end; %else\n%do;\n    %if %upcase(\"&wifiv_root_dir_src\") eq \"SASSERVER\" %then\n    %do;\n        %let root_directory = %scan(&wifiv_inRootDir, 2, \":\");\n    %end; %else\n    %do;\n        %let root_directory = &wifiv_inRootDir;\n    %end;\n%end;\n%let extension = &wifiv_inExtension;\n%let target_libname = &wifiv_inTargetLib;\n\n/****\nmax_table_name_length:\nthis determines the maximum allowed table name length.\nE.g. in the case of uploading XLSX files to SAS94, the final table name\nis built by concatenating Excel-filename and Sheetname.\nSo this can easily lead to a datasetname that is too long.\nAlso take into consideration that the concatenated name for multiple tables could\npotentially the same in the abbreviated form.\nThe system checks for that and adds a counter to the table name.\nSo leave at least 2 characters for a counter.\n****/\n%let max_table_name_length = &wifiv_max_table_name_length;\n/****\nsubstitute_string_seq:\nIf the target table name is too long, this string determines which\ncharacters are taken out from the targeet name to shorten the name further,\nbefore the truncation process kicks in.\nE.g. when substitute_string_seq = aeAEoO\nthen a table name of\n\"ThisIsAVeryLongTableNameThatIsTooLong\" and a\nmax_table_name_length = 29\nwould be first changed to the following:\n\"ThisIsVryLngTblNmThtIsTLng\" which would be short enough\n****/\n%let substitute_string_seq = &wifiv_inSbstStrgSeq.;\n\n%let meta_centralized = &wifiv_meta_centralized;\n%let libname_meta_centralized = &wifiv_libname_meta_centralized;\n\n%let debug_mode = &wifiv_debug_mode;\n%let shp_enrich_with_zip = &wifiv_shp_enrich_with_zip;\n/**************\nPlease change all parameters above this section as needed.\nSee the meaning of the keywords in the headersection.\nDon't change anything below this section!!\n***************/\n\n\n%let wifiv_clean_up_worklib_inbetween = 1;\n\n%if &meta_centralized = 1 %then\n%do;\n    %let upload_log_ds = &libname_meta_centralized.._UPLOAD_LOG;\n    %let variable_dict_ds = &libname_meta_centralized.._VARIABLE_DICTIONARY;\n%end; %else\n%do;\n    %let upload_log_ds = &target_libname.._UPLOAD_LOG_%upcase(&target_libname.);\n    %let variable_dict_ds = &target_libname.._VARIABLE_DICTIONARY_%upcase(&target_libname.);\n%end;\n\n%let wifiv_target_environment = ;\n\nproc sql noprint;\n    select distinct(engine)\n    into :wifiv_target_environment\n    from dictionary.libnames\n    where kupcase(libname) = \"%upcase(&wifiv_inTargetLib)\"\n    ;\nquit;\n\n\n%if \"%upcase(&wifiv_target_environment)\" eq \"CAS\" %then\n%do;\n    %if \"&wifiv_macro_varname_cashost\" ne  \"\" %then\n    %do;\n        options cashost=\"&wifiv_macro_varname_cashost\" casport=&wifiv_macro_varname_casport;\n    %end;\n/*    cas DIAP_PRC;*/\n    caslib _all_ assign;\n%end;\n/***\nCheck that last characters is either / or \\\n***/\n\n\n%if \"&wifiv_provide_default_log_path\" eq \"\" %then\n    %let wifiv_write_log_into_file = 0;\n\n\n%if &wifiv_write_log_into_file = 1 %then\n%do;\n    %let wifiv_timestamp = ;\n    data _null_;\n        todaysdate = today();\n        year = year(todaysdate);\n        month = put(month(todaysdate), z2.);\n        day = put(day(todaysdate), z2.);\n        nowtime = time();\n        hour = put(hour(nowtime), z2.);\n        minute = put(minute(nowtime), z2.);\n        put minute;\n        timestamp = trim(left(year))||trim(left(month))||trim(left(day))||\"_\"||trim(left(hour))||trim(left(minute));\n        call symput('wifiv_timestamp', timestamp);\n    run;\n    %let wifiv_timestamp = %trim(%left(&wifiv_timestamp));\n\n    %if \"&wifiv_provide_default_log_path\" eq \"\" %then\n        %let wifiv_provide_default_log_path = %trim(%left(&root_directory));\n\n    %if &wifiv_install_mode_in_SASContent = 0 %then\n    %do;\n        proc printto\n            log=\"&wifiv_provide_default_log_path.&target_libname._&wifiv_timestamp._DIAP_upload_run.log\";\n        quit;\n    %end; %else\n    %if &wifiv_install_mode_in_SASContent = 1 %then\n    %do;\n        filename logfile\n            filesrvc\n            folderpath = \"&wifiv_provide_default_log_path\"\n            filename = \"&target_libname._&wifiv_timestamp._DIAP_upload_run.log\";\n\n        proc printto\n            log=logfile new;\n        quit;\n    %end;\n\n%end;\n/***\noverview_ds:\n        provide the location of the SAS dataset, that contains the list\n        of all found files in the directory.\n***/\n    %let overview_ds = work._file_overview;\n    %let batchsize = 100;\n\n    proc datasets lib=%scan(&overview_ds, 1, '.');\n        delete %scan(&overview_ds, 2, '.');\n    quit;\n\n/***\nIn case CUSTOM is selected make sure that to check for the files, all the extensions are checked for\n****/\n    %let extension_pass_through = &extension;\n    %if \"%upcase(&extension)\" eq \"CUSTOM\" %then\n        %let extension_pass_through = *;\n\n    %if &wifiv_diap_guided_automation = 1 %then\n    %do;\n\n        data &overview_ds;\n            set work._DIAP_guided_execution_order;\n        run;\n\n    %end; %else\n    %do;\n        %list_all_files(\n            &root_directory,\n            &extension_pass_through,\n            &overview_ds,\n            laf_debug_mode = &debug_mode,\n            laf_traverse_directories = &wifiv_traverse_directories,\n            laf_directory_separator = &wifiv_delimiter.,\n            laf_is_sas_content_directory = &wifiv_root_is_sas_content\n            );\n    %end;\n    %if \"%upcase(&wifiv_do_profiling)\" = \"DICT_ONLY\" or\n        \"%upcase(&wifiv_do_profiling)\" = \"PROFILE\" or\n        \"%upcase(&wifiv_do_profiling)\" = \"PROFILE_ONLY_NO_UPLOAD\" %then\n    %do;\n        %if \"&wifiv_profiling_dict_location\" eq \"\" %then\n        %do;\n            %let wifiv_do_profiling = NO;\n        %end; %else\n        %do;\n            filename PrfRslts     /* limited to 8 characters */\n                    filesrvc     /* SAS Viya Service to load the code stored within Viya */\n                    folderpath     = \"&prfl_cd_lctn_in_content_area\"\n                    filename    = 'DQ_AutoDataProfiling_Exec_4.sas';\n            %include PrfRslts;\n            filename _TblDict     /* limited to 8 characters */\n                    filesrvc     /* SAS Viya Service to load the code stored within Viya */\n                    folderpath     = \"&prfl_cd_lctn_in_content_area\"\n                    filename    = 'DQ_AutoDataProfiling_TableDict_4.sas';\n            %include _TblDict;\n        %end;\n    %end;\n\n\n\n    %if %sysfunc(exist(&overview_ds)) ne 0 %then\n    %do;\n\n/****\nprepare for fixed-width file import\n****/\n        %let diap_fixed_width_file_def_seq = ;\n        %let fixed_file_ds_name_4_processing = ;\n\n        %local\n            wifiv_skip_files_start_count\n            wifiv_skip_files_end_count\n            ;\n\n        proc sql;\n            select\n                full_file_name\n            into\n                :diap_fixed_width_file_def_seq separated by ' #'\n            from\n                &overview_ds\n            where\n                kupcase(file_name) = \"%upcase(&fixed_width_file_definition_name)\"\n            ;\n        quit;\n        %let fixed_file_width_def_count = %wordcnt(&diap_fixed_width_file_def_seq, '#');\n        %put &=fixed_file_width_def_count;\n\n\n        %if \"&wifiv_skip_files_start_with_seq\" ne \"\" or\n            \"&wifiv_skip_files_end_with_seq\" ne \"\" %then\n        %do;\n            %let wifiv_skip_files_start_count = %wordcnt(&wifiv_skip_files_start_with_seq, \"#\");\n            %let wifiv_skip_files_end_count = %wordcnt(&wifiv_skip_files_end_with_seq, \"#\");\n\n\n\n            data &overview_ds.;\n                set &overview_ds;\n                length_name = klength(file_name);\n                drop length_name;\n                %do wifiv_skip_counter = 1 %to &wifiv_skip_files_start_count;\n                    %let wifiv_skip_files_start_with = %scan(&wifiv_skip_files_start_with_seq, &wifiv_skip_counter, \"#\");\n                    %let wifiv_skip_files_start_length = %length(&wifiv_skip_files_start_with);\n                    if length_name >= &wifiv_skip_files_start_length then\n                    do;\n                        if kupcase(ksubstr(file_name, 1, &wifiv_skip_files_start_length)) = %upcase(\"&wifiv_skip_files_start_with\") then delete;\n                    end;\n                %end;\n                %do wifiv_skip_counter = 1 %to &wifiv_skip_files_end_count;\n                    %let wifiv_skip_files_end_with = %scan(&wifiv_skip_files_end_with_seq, &wifiv_skip_counter, \"#\");\n                    %let wifiv_skip_files_end_length = %length(&wifiv_skip_files_end_with);\n                    if length_name >= &wifiv_skip_files_end_length then\n                    do;\n                        if kupcase(ksubstr(file_name, length_name - &wifiv_skip_files_end_length + 1, &wifiv_skip_files_end_length)) = %upcase(\"&wifiv_skip_files_end_with\") then delete;\n                    end;\n                %end;\n            run;\n        %end;\n\n        %if &fixed_file_width_def_count ne 0 %then\n        %do;\n            %do fixed_file_width_def_counter = 1 %to &fixed_file_width_def_count;\n                %let diap_fixed_width_file_def = %scan(&diap_fixed_width_file_def_seq, &fixed_file_width_def_counter, '#');\n                proc import\n                    datafile=\"&diap_fixed_width_file_def\"\n                    out=work._fixed_file_definition_&fixed_file_width_def_counter\n                    dbms=dlm replace;\n                    delimiter = \",\" ;\n                    datarow = 2;\n                    guessingrows = 200;\n                    getnames=yes;\n                quit;\n            %end;\n            %let fixed_file_ds_name_4_processing = work._fixed_file_definition_all_comb;\n            data &fixed_file_ds_name_4_processing;\n                set\n                %do fixed_file_width_def_counter = 1 %to &fixed_file_width_def_count;\n                    work._fixed_file_definition_&fixed_file_width_def_counter\n                %end;\n                ;\n            run;\n\n            proc sort\n                data = &fixed_file_ds_name_4_processing nodupkey;\n                by\n                    filename\n                    directory\n                    variable_name\n                    ;\n            quit;\n\n            data work._fixed_file_definition_red;\n                set &fixed_file_ds_name_4_processing;\n                by filename directory;\n                if first.directory;\n            run;\n            %let ind_fn_4_fixed_width_seq = ;\n            %let is_full_fn_indicator_seq = ;\n            %let ind_dir_4_fixed_width_seq = ;\n\n            proc sql;\n                select\n                    filename,\n                    directory\n                into\n                    :ind_fn_4_fixed_width_seq separated by ' #',\n                    :ind_dir_4_fixed_width_seq separated by ' #'\n                from\n                    work._fixed_file_definition_red\n                ;\n            quit;\n            %let fixed_filename_count = %wordcnt(&ind_fn_4_fixed_width_seq, '#');\n/****\nnow check for how many fixed file are occuring\n*****/\n            %if &wifiv_debug_mode = 1 %then\n            %do;\n                data &overview_ds._fxd_backup;\n                    set &overview_ds;\n                run;\n            %end;\n            data &overview_ds._fixed_width\n                &overview_ds (drop = filename_as_in_fixed_width_def);\n                length\n                    filename_as_in_fixed_width_def $100.;\n                set &overview_ds;\n                drop switch;\n                switch = 0;\n                %do fixed_filename_counter = 1 %to &fixed_filename_count;\n                    %let filename = %scan(&ind_fn_4_fixed_width_seq, &fixed_filename_counter, '#' );\n                    %let fixed_file_dir = %scan(&ind_dir_4_fixed_width_seq, &fixed_filename_counter, '#' );\n                    %let filename_length = %length(%trim(%left(&filename)));\n                    if ksubstr(kupcase(file_name), 1, &filename_length) = \"%trim(%left(%upcase(&filename)))\" and\n                        trim(left(kupcase(directory_path))) = \"%trim(%left(%upcase(&fixed_file_dir)))\" then\n                    do;\n                        filename_as_in_fixed_width_def = \"%trim(%left(&filename))\";\n                        switch = 1;\n                    end;\n                %end;\n                if switch then\n                    output &overview_ds._fixed_width;\n                else\n                    output &overview_ds;\n            run;\n\n\n\n\n            proc sort\n                data = &fixed_file_ds_name_4_processing nodupkey;\n                by\n                    filename\n                    directory\n                    variable_start_position\n                    variable_name\n                    ;\n            quit;\n\n\n            data work._loop_overview_ds_fwf;\n                set &overview_ds._fixed_width;\n                unique_id = _n_;\n            run;\n\n            %let number_of_rows_fwf = 0;\n            proc sql noprint;\n                select\n                    nobs\n                into\n                    :number_of_rows_fwf\n                from\n                    dictionary.tables\n                where\n                    libname = \"WORK\" and\n                    memname = \"_LOOP_OVERVIEW_DS_FWF\";\n            quit;\n\n            %if &number_of_rows_fwf ne 0 %then\n            %do;\n\n                %let mod_fwf = %sysfunc(mod(&number_of_rows_fwf,&batchsize));\n                %let loop_size_fwf = %eval(&number_of_rows_fwf / &batchsize);\n\n                %do batch_counter_fwf = 0 %to &loop_size_fwf;\n                    %let full_filename_path_seq_fwf = ;\n                    %let directory_path_seq_fwf = ;\n                    %let fn_as_in_fixed_width_def_seq = ;\n                    proc sql noprint;\n                        select\n                            full_file_name,\n                            directory_path,\n                            filename_as_in_fixed_width_def\n                        into\n                            :full_filename_path_seq_fwf separated by \"# \",\n                            :directory_path_seq_fwf separated by \"# \",\n                            :fn_as_in_fixed_width_def_seq separated by \"# \"\n                        from\n                            work._loop_overview_ds_fwf\n                        where\n                            unique_id gt %eval(&batch_counter_fwf*&batchsize) and\n                            unique_id le %eval(%eval(&batch_counter_fwf +1)*&batchsize);\n                    quit;\n\n                    %if &wifiv_clean_up_worklib_inbetween = 1 %then\n                    %do;\n                        proc datasets lib = work nolist;\n                            delete\n                                varnames_:\n                                get_table_info_:\n                                ;\n                        quit;\n                    %end;\n\n                    %put INFORMATION GENERAL: This is batch # &batch_counter_fwf &=full_filename_path_seq_fwf;\n                    %put INFORMATION GENERAL: This is batch # &batch_counter_fwf &=directory_path_seq_fwf;\n                    %write_out_files_2_libname(\n                        &full_filename_path_seq_fwf,\n                        &target_libname,\n                        &fn_as_in_fixed_width_def_seq,\n                        wof2l_directory_path_seq = &directory_path_seq_fwf,\n                        wof2l_upload_log_ds = &upload_log_ds,\n                        wof2l_shp_enrich_with_zip = &shp_enrich_with_zip,\n                        wof2l_variable_dict_dataset = &variable_dict_ds,\n                        wof2l_debug_mode = &debug_mode,\n                        wof2l_max_name_length = &max_table_name_length,\n                        wof2l_substitute_string_seq = &substitute_string_seq,\n                        wof2l_fixed_file_definition_ds = &fixed_file_ds_name_4_processing ,\n                        wof2l_do_profiling = &wifiv_do_profiling,\n                        wof2l_profile_dict_location = &wifiv_profiling_dict_location,\n                        wof2l_path_2_python_shape_script = &wifiv_path_2_python_shape_script,\n                        wof2l_drop_missing_vars = &wifiv_drop_missing_vars,\n                        wof2l_stringseq_2_cutout_from_fn = &wifiv_stringseq_2_cutout_from_fn,\n                        wof2l_stringseq_2_cutout_from_vn = &wifiv_stringseq_2_cutout_from_vn,\n                        wof2l_prefix_4_suspicious_src_fl = &wifiv_prefix_4_suspicious_src_fl,\n                        wof2l_max_lgth_of_suspicious_str = &wifiv_max_lgth_of_suspicious_str,\n                        wof2l_check_csv_4_num = &wifiv_check_csv_4_num,\n                        wof2l_viyaversion = &wifiv_viyaversion,\n                        wof2l_chck_txt_fl_4_spcl_chrct = &wifiv_chck_txt_fl_4_spcl_chrct,\n                        wof2l_spcl_chrctr_sq2chck_in_hex = &wifiv_spcl_chrctr_sq2chck_in_hex,\n                        wof2l_spcl_chrct_chck_rplcmnt_hx = &wifiv_spcl_chrct_chck_rplcmnt_hx,\n                        wof2l_make_imported_data_prsstnt = &wifiv_make_imported_data_prsstnt,\n                        wof2l_force_upload_of_all_files = &wifiv_force_upload_of_all_files,\n                        wof2l_skip_files_start_with_seq = &wifiv_skip_files_start_with_seq ,\n                        wof2l_skip_files_end_with_seq = &wifiv_skip_files_end_with_seq,\n                        wof2l_fnl_tblname_from_sheetonly = &wifiv_fnl_tblname_from_sheetonly,\n                        wof2l_create_unique_target_tblnm = &wifiv_create_unique_target_tblnm,\n                        wof2l_delimiter = &wifiv_delimiter,\n                        wof2l_chck_4_spcl_char_in_vars = &wifiv_chck_4_spcl_char_in_vars,\n                        wof2l_fnl_ds_name_4_all_extfiles = &wifiv_fnl_ds_name_4_all_extfiles,\n                        wof2l_diap_guided_automation = &wifiv_diap_guided_automation,\n                        wof2l_gddauto_upd_fls_del_seq = &wifiv_gddauto_upd_fls_del_seq,\n                        wof2l_gddauto_upd_fls_sht_seq = &wifiv_gddauto_upd_fls_sht_seq,\n                        wof2l_gddauto_upd_fls_cntt_flg = &wifiv_gddauto_upd_fls_cntt_flg,\n                        wof2l_gddauto_upd_fls_hdr_seq = &wifiv_gddauto_upd_fls_hdr_seq,\n                        wof2l_gddauto_upd_fls_tgt_seq = &wifiv_gddauto_upd_fls_tgt_seq\n                        );\n                %end;\n            %end;\n            %else\n                %put INFORMATION ALERT: Did NOT find any matching definitions in the Special File Definition;\n                %let fixed_file_ds_name_4_processing = ;\n        %end; /* end of Fixed width check/processing */\n\n\n\n        data work._loop_overview_ds;\n            set &overview_ds;\n            unique_id = _n_;\n        run;\n\n        %let number_of_rows = 0;\n        proc sql noprint;\n            select\n                nobs\n            into\n                :number_of_rows\n            from\n                dictionary.tables\n            where\n                libname = \"WORK\" and\n                memname = \"_LOOP_OVERVIEW_DS\";\n        quit;\n\n        %let mod = %sysfunc(mod(&number_of_rows,&batchsize));\n        %let loop_size = %eval(&number_of_rows / &batchsize);\n        %do batch_counter = 0 %to &loop_size;\n            %let full_filename_path_seq = ;\n            %let directory_path_seq = ;\n            proc sql noprint;\n                select\n                    full_file_name,\n                    is_in_SAS_Content_flag,\n                    %if &wifiv_diap_guided_automation = 1 %then\n                    %do;\n                        sheet_xml_json_tablename,\n                        %if &wifiv_temp_count ne 0 %then\n                        %do;\n                            delimiter_for_text_files,\n                        %end;\n                        %if &wifiv_temp_header_flag_count ne 0 %then\n                        %do;\n                            column_names_in_first_row,\n                        %end;\n                        %if &wifiv_temp_target_count ne 0 %then\n                        %do;\n                            target_table_name,\n                        %end;\n                    %end;\n                    directory_path\n                into\n                    :full_filename_path_seq separated by \"# \",\n                    :wifiv_gddauto_upd_fls_cntt_flg separated by \" #\" ,\n                    %if &wifiv_diap_guided_automation = 1 %then\n                    %do;\n                        :wifiv_gddauto_upd_fls_sht_seq separated by \" #\" ,\n                        %if &wifiv_temp_count ne 0 %then\n                        %do;\n                            :wifiv_gddauto_upd_fls_del_seq separated by \" #\",\n                        %end;\n                        %if &wifiv_temp_header_flag_count ne 0 %then\n                        %do;\n                            :wifiv_gddauto_upd_fls_hdr_seq separated by \" #\",\n                        %end;\n                        %if &wifiv_temp_target_count ne 0 %then\n                        %do;\n                            :wifiv_gddauto_upd_fls_tgt_seq separated by \" #\",\n                        %end;\n                    %end;\n                    :directory_path_seq separated by \"# \"\n                from\n                    work._loop_overview_ds\n                where\n                    unique_id gt %eval(&batch_counter*&batchsize) and\n                    unique_id le %eval(%eval(&batch_counter +1)*&batchsize);\n            quit;\n\n            %put INFORMATION GENERAL: This is batch # &batch_Counter &=full_filename_path_seq;\n            %put INFORMATION GENERAL: This is batch # &batch_Counter &=directory_path_seq;\n            %if &wifiv_clean_up_worklib_inbetween = 1 %then\n            %do;\n                proc datasets lib = work nolist;\n                    delete\n                        varnames_:\n                        get_table_info_:\n                        ;\n                quit;\n            %end;\n            %write_out_files_2_libname(\n                &full_filename_path_seq,\n                &target_libname,\n                ,\n                wof2l_directory_path_seq = &directory_path_seq,\n                wof2l_upload_log_ds = &upload_log_ds,\n                wof2l_debug_mode = &debug_mode,\n                wof2l_shp_enrich_with_zip = &shp_enrich_with_zip,\n                wof2l_variable_dict_dataset = &variable_dict_ds,\n                wof2l_max_name_length = &max_table_name_length,\n                wof2l_substitute_string_seq = &substitute_string_seq,\n                wof2l_do_profiling = &wifiv_do_profiling,\n                wof2l_profile_dict_location = &wifiv_profiling_dict_location,\n                wof2l_path_2_python_shape_script = &wifiv_path_2_python_shape_script,\n                wof2l_csv_big_data_mode = &wifiv_csv_big_data_mode,\n                wof2l_drop_missing_vars = &wifiv_drop_missing_vars,\n                wof2l_stringseq_2_cutout_from_fn = &wifiv_stringseq_2_cutout_from_fn,\n                wof2l_stringseq_2_cutout_from_vn = &wifiv_stringseq_2_cutout_from_vn,\n                wof2l_prefix_4_suspicious_src_fl = &wifiv_prefix_4_suspicious_src_fl,\n                wof2l_max_lgth_of_suspicious_str = &wifiv_max_lgth_of_suspicious_str,\n                wof2l_check_csv_4_num = &wifiv_check_csv_4_num,\n                wof2l_viyaversion = &wifiv_viyaversion,\n                wof2l_chck_txt_fl_4_spcl_chrct = &wifiv_chck_txt_fl_4_spcl_chrct,\n                wof2l_spcl_chrctr_sq2chck_in_hex = &wifiv_spcl_chrctr_sq2chck_in_hex,\n                wof2l_spcl_chrct_chck_rplcmnt_hx = &wifiv_spcl_chrct_chck_rplcmnt_hx,\n                wof2l_make_imported_data_prsstnt = &wifiv_make_imported_data_prsstnt,\n                wof2l_force_upload_of_all_files = &wifiv_force_upload_of_all_files,\n                wof2l_skip_files_start_with_seq = &wifiv_skip_files_start_with_seq ,\n                wof2l_skip_files_end_with_seq = &wifiv_skip_files_end_with_seq,\n                wof2l_fnl_tblname_from_sheetonly = &wifiv_fnl_tblname_from_sheetonly,\n                wof2l_create_unique_target_tblnm = &wifiv_create_unique_target_tblnm,\n                wof2l_delimiter = &wifiv_delimiter,\n                wof2l_chck_4_spcl_char_in_vars = &wifiv_chck_4_spcl_char_in_vars,\n                wof2l_fnl_ds_name_4_all_extfiles = &wifiv_fnl_ds_name_4_all_extfiles,\n                wof2l_diap_guided_automation = &wifiv_diap_guided_automation,\n                wof2l_gddauto_upd_fls_del_seq = &wifiv_gddauto_upd_fls_del_seq,\n                wof2l_gddauto_upd_fls_sht_seq = &wifiv_gddauto_upd_fls_sht_seq,\n                wof2l_gddauto_upd_fls_cntt_flg = &wifiv_gddauto_upd_fls_cntt_flg,\n                wof2l_gddauto_upd_fls_hdr_seq = &wifiv_gddauto_upd_fls_hdr_seq,\n                wof2l_gddauto_upd_fls_tgt_seq = &wifiv_gddauto_upd_fls_tgt_seq\n                );\n        %end;\n    %end; %else\n    %do;\n        %put INFORMATION ALERT: Directory does NOT exist!;\n    %end;\n    %if &wifiv_write_log_into_file = 1 %then\n    %do;\n        proc printto;\n        quit;\n    %end;\n/*    %if \"%upcase(&wifiv_target_environment)\" eq \"CAS1\" %then*/\n/*    %do;*/\n/*        cas DIAP_PRC disconnect ;*/\n/*        cas DIAP_PRC terminate ;*/\n/*    %end;*/\n%mend wrapper_import_files_into_viya;\n\n/** FOR TESTING ***\noption mprint source notes;\n%include \"/mnt/downloads/production_code/wrapper/development_wrapper/00_all_code_pieces_import_files_into_viya_4_execution.sas\";\n    OPTIONS cashost=\"&_CASHOST_\" casport=&_CASPORT_;\n    cas;\n    caslib _all_ assign;\n\n%let root_directory = /mnt/downloads/ZZ_Testing/top_folder/;\n%let extension = *;\n%let target_libname = work;\n%let substitute_string_seq = aeiouAEIOU;\n%let meta_centralized = 0;\n%let libname_meta_centralized = work;\n%let max_table_name_length = 27;\n%let shp_enrich_with_zip = 0;\n%let debug_mode = 1;\n%let profiling_execution_option = NO;\n%let prfl_dict_lctn_in_content_area = ;\n%let prfl_cd_lctn_in_content_area = ;\n\n    %wrapper_import_files_into_viya(\n        wifiv_inRootDir        = &root_directory,\n        wifiv_inExtension   = &extension,\n        wifiv_inTargetLib        = &target_libname,\n        wifiv_inUpldLogDS = _NONE_,\n        wifiv_inSbstStrgSeq        = &substitute_string_seq,\n        wifiv_meta_centralized = &meta_centralized,\n        wifiv_libname_meta_centralized = &libname_meta_centralized,\n        wifiv_max_table_name_length = &max_table_name_length,\n        wifiv_debug_mode = &debug_mode,\n        wifiv_shp_enrich_with_zip = &shp_enrich_with_zip,\n        wifiv_do_profiling = &profiling_execution_option,\n        wifiv_profiling_dict_location = &prfl_dict_lctn_in_content_area,\n        wifiv_profiling_code_location = &prfl_cd_lctn_in_content_area\n        );\n\n\n*********************/\n/******************************************************************************\n\n                                    %DIAP_handling_missings_vars\n                                            ________\n\n\ndeletes completely missing variables from datasets\n\n______________________________________________________________________________\n\n\nUSAGE:                         see testing section on the bottom of this code\n\n______________________________________________________________________________\n\nDESCRIPTION:\n\n  This macro checks all the variables of a provided dataset for completely missing\n    variables. There are 2 modes for dropping of those variables, either all of them, or\nonly the ones that contains a certain string in their variable name.\n______________________________________________________________________________\n\n\nINPUT PARAMETERS AND KEYWORDS:\n\n      dhm_missing_handling_option:\n        1: drop any variable that contains only missing values\n        2: drop only those variables that contain a certain string\n        as provided in parameter dhm_stg_2_chk_var_b4_drop\n    dhm_dataset_2_check\n        provide the dataset name that needs to be checked for missing variables\n      dhm_dataset_2_write_out_results\n        provide dataset name where the results of the missing variables is stored\n    dhm_stg_2_chk_var_b4_drop\n        checks the variable name for this string sequence before dropping\n        default: ZZ_MISSING_VARNAME_\n______________________________________________________________________________\n\nNOTES: (Initials, date, summary)\n\nStephan Weigandt    20200909  First officially Released Version\n______________________________________________________________________________\n\n*******************************************************************************/\n%macro DIAP_handling_missings_vars(\n    dhm_missing_handling_option = 1,\n    dhm_dataset_2_check = ,\n    dhm_dataset_2_check_output = ,\n    dhm_dataset_2_write_out_results = ,\n    dhm_stg_2_chk_var_b4_drop = ZZ_MISSING_VARNAME_\n    );\n\n    %local\n        dhm_drop_seq\n        dhm_count_num\n        dhm_count_char\n        ;\n    %let dhm_drop_seq = ;\n    %let dhm_count_num = 0;\n    %let dhm_count_char = 0;\n    proc sql noprint;\n        select\n            count(type)\n        into\n            :dhm_count_num\n        from\n            dictionary.columns\n        where\n            kupcase(libname) = \"%upcase(%trim(%left(%scan(&dhm_dataset_2_check, 1, '.'))))\" and\n            kupcase(memname) = \"%upcase(%trim(%left(%scan(&dhm_dataset_2_check, 2, '.'))))\" and\n            kupcase(type) = \"NUM\"\n        ;\n        select\n            count(type)\n        into\n            :dhm_count_char\n        from\n            dictionary.columns\n        where\n            kupcase(libname) = \"%upcase(%trim(%left(%scan(&dhm_dataset_2_check, 1, '.'))))\" and\n            kupcase(memname) = \"%upcase(%trim(%left(%scan(&dhm_dataset_2_check, 2, '.'))))\" and\n            kupcase(type) = \"CHAR\"\n        ;\n    quit;\n    %let dhm_count_char = %trim(%left(&dhm_count_char));\n    %let dhm_count_num = %trim(%left(&dhm_count_num));\n\n    proc iml;\n        use &dhm_dataset_2_check;\n        %if &dhm_count_num > 0 %then\n        %do;\n            read all var _NUM_ into x[colname=nNames];\n            n = countn(x,\"col\");\n            nmiss = countmiss(x,\"col\");\n        %end;\n        %if &dhm_count_char > 0 %then\n        %do;\n            read all var _CHAR_ into x[colname=cNames];\n            c = countn(x,\"col\");\n            cmiss = countmiss(x,\"col\");\n        %end;\n        close &dhm_dataset_2_check;\n        %if &dhm_count_num > 0  and\n            &dhm_count_char > 0 %then\n        %do;\n            /* combine results for num and char into a single table */\n            Names = cNames || nNames;\n            rNames = {\"Missing\", \"Not_Missing\"};\n            cnt = (cmiss // c) || (nmiss // n);\n            print cnt[r=rNames c=Names label=\"\"];\n\n            create &dhm_dataset_2_write_out_results\n                from cnt[r=rNames c=Names];\n                append from cnt[r=rNames];\n            close;\n        %end;\n        %if &dhm_count_num = 0  and\n            &dhm_count_char > 0 %then\n        %do;\n            /* combine results for num and char into a single table */\n            Names = cNames ;\n            rNames = {\"Missing\", \"Not_Missing\"};\n            cnt = (cmiss // c) ;\n            print cnt[r=rNames c=Names label=\"\"];\n\n            create &dhm_dataset_2_write_out_results\n                from cnt[r=rNames c=Names];\n                append from cnt[r=rNames];\n            close;\n        %end;\n        %if &dhm_count_num > 0  and\n            &dhm_count_char = 0 %then\n        %do;\n            /* combine results for num and char into a single table */\n            Names = nNames;\n            rNames = {\"Missing\", \"Not_Missing\"};\n            cnt = (nmiss // n);\n            print cnt[r=rNames c=Names label=\"\"];\n\n            create &dhm_dataset_2_write_out_results\n                from cnt[r=rNames c=Names];\n                append from cnt[r=rNames];\n            close;\n        %end;\n    quit;\n    proc transpose\n        data = &dhm_dataset_2_write_out_results\n        out = &dhm_dataset_2_write_out_results._t;\n        id  rnames;\n    quit;\n\n    %if &dhm_missing_handling_option = 1 %then\n    %do;\n/****\ndelete all occuring missing vars\n****/\n        proc sql;\n            select\n                _NAME_\n            into\n                :dhm_drop_seq separated by \" \"\n            from\n                &dhm_dataset_2_write_out_results._t\n            where\n                Missing > 1 and\n                Not_Missing = 0\n            ;\n        quit;\n\n    %end;\n    %if &dhm_missing_handling_option = 2 %then\n    %do;\n/****\ndelete occuring missing vars that originally also have a missing variable name\n****/\n        proc sql;\n            select\n                _NAME_\n            into\n                :dhm_drop_seq separated by \" \"\n            from\n                &dhm_dataset_2_write_out_results._t\n            where\n                Missing > 1 and\n                Not_Missing = 0 and\n                kupcase(_NAME_) contains (\"%upcase(&dhm_stg_2_chk_var_b4_drop)\")\n            ;\n        quit;\n\n    %end;\n    %let dhm_missing_var_count = 0;\n    %let dhm_missing_var_count = %wordcnt(&dhm_drop_seq, ' ');\n    data &dhm_dataset_2_check_output;\n        set &dhm_dataset_2_check;\n        %if &dhm_missing_var_count ne 0 %then\n        %do;\n            drop &dhm_drop_seq;\n        %end;\n    run;\n\n%mend DIAP_handling_missings_vars;\n\n/** FOR TESTING ***\noption mprint source notes;\n%include \"/mnt/downloads/production_code/macros/wordcnt.sas\";\ndata one;\n  input ZZ_MISSING_VARNAME_ $ b $ cothervar $ d e;\ncards;\n. . . 1 3\n. b . 2 4\n. a . . 5\n. . . 3 5\n. a . . 6\n. a . . 7\n. a . 2 8\n;\nrun;\n\n%let ebla_cas_target_libname = ZZ_Tstng;\n%let missing_handling_option = 1;\n%let dataset_2_check = work.one;\n%let dataset_2_check_output = work.two;\n%let dataset_2_write_out_results =  work._missing_var_results_;\n%let stg_2_chk_var_b4_drop = ZZ_MISSING_VARNAME_;\n\n\n%DIAP_handling_missings_vars(\n    dhm_missing_handling_option = &missing_handling_option,\n    dhm_dataset_2_check = &dataset_2_check,\n    dhm_dataset_2_check_output = &dataset_2_check_output,\n    dhm_dataset_2_write_out_results = &dataset_2_write_out_results,\n    dhm_stg_2_chk_var_b4_drop = &stg_2_chk_var_b4_drop\n    );\n\n\n*********************/\n\n%macro execute_all();\n%put     &=chck_4_spcl_char_in_vars_ui    ;\n%put      &=check_csv_4_num_ui    ;\n%put     &=check_txt_file_4_special_chrctui    ;\n%put     &=csv_big_data_mode_ui    ;\n%put     &=debug_mode_ui    ;\n%put     &=diap_create_unique_target_tblnm2    ;\n%put     &=diap_fnl_tblname_from_sheetonly2    ;\n%put     &=diap_traverse_directories_ui    ;\n%put     &=drop_missing_vars_ui    ;\n%put     &=extension_ui    ;\n%put     &=fnl_ds_name_4_all_extfiles_ui    ;\n%put     &=force_upload_of_all_files_ui    ;\n%put     &=libname_meta_centralized_ui    ;\n%put     &=make_imported_data_persistent_ui    ;\n%put     &=max_lgth_of_suspicious_str_ui    ;\n%put     &=max_table_length_ui    ;\n%put     &=meta_centralized_ui    ;\n%put     &=prefix_4_suspicious_src_fl_ui    ;\n%put     &=root_directory_ui    ;\n%put    &=log_file_path_ui;\n%put &=root_directory_overwrite_ui;\n%put     &=skip_files_ending_with_seq_ui    ;\n%put     &=skip_files_starting_with_seq_ui    ;\n%put     &=spcl_chrctr_check_rplcmnt_inhex2    ;\n%put     &=special_chrctr_seq_2_chck_inhex2    ;\n%put     &=stringseq_2_cutout_from_fn_ui    ;\n%put     &=stringseq_2_cutout_from_vn_ui    ;\n%put     &=substitute_string_seq_ui    ;\n%put     &=target_libname_ui    ;\n%put     &=write_log_into_file_ui    ;\n%let root_directory = &root_directory_ui;\n\n%put &=root_directory;\n\n%let     chck_4_spcl_char_in_vars    =    &chck_4_spcl_char_in_vars_ui    ;\n%let     check_csv_4_num    =    &check_csv_4_num_ui    ;\n%let     check_txt_file_4_special_chrct    =    &check_txt_file_4_special_chrctui    ;\n%let     csv_big_data_mode    =    &csv_big_data_mode_ui    ;\n%let     debug_mode    =    &debug_mode_ui    ;\n%let     diap_create_unique_target_tblnm    =    &diap_create_unique_target_tblnm2    ;\n%let     diap_fnl_tblname_from_sheetonly    =    &diap_fnl_tblname_from_sheetonly2    ;\n%let     diap_traverse_directories    =    &diap_traverse_directories_ui    ;\n%let     drop_missing_vars    =    &drop_missing_vars_ui    ;\n%let     extension    =    &extension_ui    ;\n%let     fnl_ds_name_4_all_extfiles    =    &fnl_ds_name_4_all_extfiles_ui    ;\n%let     force_upload_of_all_files    =    &force_upload_of_all_files_ui    ;\n%let     libname_meta_centralized    =    &libname_meta_centralized_ui    ;\n%let     make_imported_data_persistent    =    &make_imported_data_persistent_ui    ;\n%let     max_lgth_of_suspicious_str    =    &max_lgth_of_suspicious_str_ui    ;\n%let     max_table_length    =    &max_table_length_ui    ;\n%let     meta_centralized    =    &meta_centralized_ui    ;\n%let     prefix_4_suspicious_src_fl    =    &prefix_4_suspicious_src_fl_ui    ;\n\n%if \"&root_directory_overwrite_ui\" ne \"\" %then\n%do;\n    %let root_directory_source_ow = %upcase(%scan(&root_directory_overwrite_ui, 1, \":\"));\n    %if \"&root_directory_source_ow\"    ne \"SASSERVER\" and\n        \"&root_directory_source_ow\"    ne \"SASCONTENT\" %then\n    %do;\n        %let root_directory = SASSERVER:&root_directory_overwrite_ui;\n    %end; %else\n    %do;\n        %let root_directory = &root_directory_overwrite_ui;\n    %end;\n%end;\n%let     skip_files_ending_with_seq    =    &skip_files_ending_with_seq_ui    ;\n%let     skip_files_starting_with_seq    =    &skip_files_starting_with_seq_ui    ;\n%let     spcl_chrctr_check_rplcmnt_in_hex    =    &spcl_chrctr_check_rplcmnt_inhex2    ;\n%let     special_chrctr_seq_2_chck_in_hex    =    &special_chrctr_seq_2_chck_inhex2    ;\n%let     stringseq_2_cutout_from_fn    =    &stringseq_2_cutout_from_fn_ui    ;\n%let     stringseq_2_cutout_from_vn    =    &stringseq_2_cutout_from_vn_ui    ;\n%let     substitute_string_seq    =    &substitute_string_seq_ui    ;\n%let     target_libname    =    &target_libname_ui    ;\n%let     write_log_into_file    =    &write_log_into_file_ui    ;\n\n%let DIAP_viyaversion = 4;\n\n%let provide_default_log_path = ;\n%let log_file_directory_source_ui = ;\n%if \"&log_file_path_ui\" ne \"\" %then\n%do;\n    %let provide_default_log_path = %scan(&log_file_path_ui, 2, \":\")/;\n    %let log_file_directory_source_ui = %scan(&log_file_path_ui, 1, \":\");\n%end;\n%if \"%upcase(&log_file_directory_source_ui)\" eq \"SASSERVER\" %then\n%do;\n    %let install_mode_in_SAS_Content = 0;\n%end; %else\n%do;\n    %let install_mode_in_SAS_Content = 1;\n%end;\n%if &DIAP_mode_selection_ui = 1 %then\n%do;\n    %let diap_guided_automation_fl_loc = ;\n%end; %else\n%do;\n    %let diap_guided_automation_fl_loc = &diap_guided_auto_fl_loc_ui;\n%end;\n\n%if &do_processing = 1 %then\n%do;\n\n    %put INFORMATION: &=profiling_execution_option ;\n    %wrapper_import_files_into_viya(\n        wifiv_inRootDir        = &root_directory,\n        wifiv_inExtension   = &extension,\n        wifiv_inTargetLib        = &target_libname,\n        wifiv_inUpldLogDS = _NONE_,\n        wifiv_inSbstStrgSeq        = &substitute_string_seq,\n        wifiv_meta_centralized = &meta_centralized,\n        wifiv_libname_meta_centralized = &libname_meta_centralized,\n        wifiv_max_table_name_length = &max_table_name_length,\n        wifiv_debug_mode = &debug_mode,\n        wifiv_shp_enrich_with_zip = &shp_enrich_with_zip,\n        wifiv_do_profiling = &profiling_execution_option,\n        wifiv_profiling_dict_location = &prfl_dict_lctn_in_content_area,\n        wifiv_profiling_code_location = &prfl_cd_lctn_in_content_area,\n        wifiv_path_2_python_shape_script = &path_2_python_shape_script,\n        wifiv_csv_big_data_mode = &csv_big_data_mode,\n        wifiv_write_log_into_file = &write_log_into_file,\n        wifiv_provide_default_log_path = &provide_default_log_path,\n        wifiv_drop_missing_vars = &drop_missing_vars,\n        wifiv_stringseq_2_cutout_from_fn = &stringseq_2_cutout_from_fn,\n        wifiv_stringseq_2_cutout_from_vn = &stringseq_2_cutout_from_vn,\n        wifiv_prefix_4_suspicious_src_fl = &prefix_4_suspicious_src_fl,\n        wifiv_max_lgth_of_suspicious_str = &max_lgth_of_suspicious_str,\n        wifiv_check_csv_4_num = &check_csv_4_num,\n        wifiv_macro_varname_cashost = &_CASHOST_,\n        wifiv_macro_varname_casport = &_CASPORT_,\n        wifiv_viyaversion = &DIAP_viyaversion,\n        wifiv_install_mode_in_SASContent = &install_mode_in_SAS_Content,\n        wifiv_chck_txt_fl_4_spcl_chrct = &check_txt_file_4_special_chrct,\n        wifiv_spcl_chrctr_sq2chck_in_hex = &special_chrctr_seq_2_chck_in_hex,\n        wifiv_spcl_chrct_chck_rplcmnt_hx = &spcl_chrctr_check_rplcmnt_in_hex,\n        wifiv_make_imported_data_prsstnt = &make_imported_data_persistent,\n        wifiv_force_upload_of_all_files = &force_upload_of_all_files,\n        wifiv_traverse_directories = &diap_traverse_directories,\n        wifiv_skip_files_start_with_seq = &skip_files_starting_with_seq,\n        wifiv_skip_files_end_with_seq = &skip_files_ending_with_seq,\n        wifiv_fnl_tblname_from_sheetonly = &diap_fnl_tblname_from_sheetonly,\n        wifiv_create_unique_target_tblnm = &diap_create_unique_target_tblnm,\n        wifiv_delimiter = &diap_delimiter.,\n        wifiv_chck_4_spcl_char_in_vars = &chck_4_spcl_char_in_vars,\n        wifiv_fnl_ds_name_4_all_extfiles = &fnl_ds_name_4_all_extfiles,\n        wifiv_diap_guided_auto_fl_loc = &diap_guided_automation_fl_loc\n        );\n%end;\n\n%mend execute_all;\n%if &DIAP_mode_selection_ui = 4 %then\n%do;\n    filename temp_fix temp;\n        data _null_;\n            file temp_fix delimiter = \",\";\n            infile datalines delimiter = \",\" truncover;\n            length\n              directory $256.\n              filename $128.\n              include_fn_in_table_output 8\n              file_type $3.\n              variable_name $32.\n              variable_label $256.\n              variable_type $4.\n              variable_length 8\n              variable_format $32.\n              variable_informat $32.\n              variable_start_position 8\n              variable_end_position 8;\n\n            input\n                directory $\n                filename $\n                include_fn_in_table_output\n                file_type $\n                variable_name $\n                variable_label $\n                variable_type $\n                variable_length\n                variable_start_position\n                variable_end_position;\n            variable_format = \"\";\n            variable_informat = \"\";\n            if _n_ = 1 then\n            do;\n            put\n              \"directory,\"\n              \"filename,\"\n              \"include_fn_in_table_output,\"\n              \"file_type,\"\n              \"variable_name,\"\n              \"variable_label,\"\n              \"variable_type,\"\n              \"variable_length,\"\n              \"variable_start_position,\"\n              \"variable_end_position,\"\n              \"variable_format,\"\n              \"variable_informat\"\n                ;\n\n            end;\n            put\n                directory $\n                filename $\n                include_fn_in_table_output\n                file_type $\n                variable_name $\n                variable_label $\n                variable_type $\n                variable_length\n                variable_start_position\n                variable_end_position\n                variable_format\n                variable_informat    ;\n\n              datalines;\n    /mnt/downloads/climate/,climdiv,1,fix,state_code,state_code,char,3,1,3\n    /mnt/downloads/climate/,climdiv,1,fix,division_number,division_number,num,8,4,4\n    /mnt/downloads/climate/,climdiv,1,fix,element_code,element_code,char,1,5,6\n    /mnt/downloads/climate/,climdiv,1,fix,year,year,num,8,7,10\n    /mnt/downloads/ZZ_Testing/top_folder/xml/,first_blast.xml,1,xml,hit_num,hit_num,num,8,1,1\n    /mnt/downloads/ZZ_Testing/top_folder/xml/,first_blast.xml,1,xml,hit_id,hit_id,char,32,2,2\n    /mnt/downloads/ZZ_Testing/top_folder/xml/,first_blast.xml,1,xml,hit_def,hit_def,char,512,3,3\n    /mnt/downloads/ZZ_Testing/top_folder/xml/,first_blast.xml,1,xml,hit_accession,hit_accession,num,8,4,4\n    /mnt/downloads/ZZ_Testing/top_folder/xml/,first_blast.xml,1,xml,hit_len,hit_len,num,8,5,5\n    /mnt/downloads/ZZ_Testing/top_folder/xml/,first_blast.xml,1,xml,hsp_midline,hsp_midline,char,32000,6,6\n            ;\n        run;\n%end;\n%if &DIAP_mode_selection_ui = 3 %then\n%do;\n    filename temp_gdd temp;\n        data _null_;\n            file temp_gdd delimiter = \",\";\n            infile datalines delimiter = \",\" truncover;\n            length\n                full_file_name $256.\n                sheet_xml_json_tablename $128.\n                is_in_SAS_Content_flag $32.\n                column_names_in_first_row $32.\n                delimiter_for_text_files $32.\n                target_table_name $32.\n                ;\n\n            input\n                full_file_name $\n                sheet_xml_json_tablename $\n                is_in_SAS_Content_flag\n                column_names_in_first_row\n                delimiter_for_text_files $\n                target_table_name $\n                ;\n\n            if _n_ = 1 then\n            do;\n            put\n                \"full_file_name,\"\n                \"sheet_xml_json_tablename,\"\n                \"is_in_SAS_Content_flag,\"\n                \"column_names_in_first_row,\"\n                \"delimiter_for_text_files,\"\n                \"target_table_name\"\n                ;\n\n            end;\n            put\n                full_file_name $\n                sheet_xml_json_tablename $\n                is_in_SAS_Content_flag\n                column_names_in_first_row\n                delimiter_for_text_files $\n                target_table_name $\n                ;\n            datalines;\n/mnt/dir/where/excel/files/test_excel.xlsx,name_of_sheet_2_read_in,0,1, ,excel_sheet2\n/public/dir/where/csv/files/test_detect_delimiter_automatically.csv, ,1,1, ,auto_detect_delimiter\n/public/dir/where/csv/files/test_comma_delimited.csv, ,1,1,comma,\n/public/dir/where/csv/files/test_tab_delimited.csv, ,1,1,tab,tab_del_from_sasContent\n/public/dir/where/csv/files/test_blank_space_delimited.csv, ,1,1,blank,\n/public/dir/where/csv/files/test_semicolon_delimited.csv, ,1,1,semicolon,semi_del_table\n/public/dir/where/csv/files/test_pipe_delimited.csv, ,1,1,pipe,\n/mnt/dir/where/more/excel/files/test_target_table_name_auto_created.xlsx,another_name_of_sheet_2_read_in,0,1, ,\n            ;\n        run;\n%end;\n\n\n%macro check_4_admin_tasks();\n\n%let do_processing = 1;\n%let controlfile_target_location = %scan(&controlfile_target_location_ui, 2, \":\")/;\n%let control_trgt_location_source = %scan(&controlfile_target_location_ui, 1, \":\");\n\n%put &=controlfile_target_location;\n%put &=do_processing;\n\n%if (&DIAP_mode_selection_ui = 3 or &DIAP_mode_selection_ui = 4) and\n    &do_processing = 1 %then\n%do;\n    %if &DIAP_mode_selection_ui = 4 %then\n    %do;\n        %if %upcase(\"&control_trgt_location_source\") eq \"SASSERVER\" %then\n        %do;\n            filename out \"&controlfile_target_location._DIAP_Special_File_Definition.csv\";\n        %end; %else\n        %do;\n            filename out\n                    filesrvc\n                    folderpath     = \"&controlfile_target_location\"\n                    filename    = \"_DIAP_Special_File_Definition.csv\";\n        %end;\n        %put &=controlfile_target_location;\n        data _null_;\n            file out delimiter = \",\";\n            infile temp_fix delimiter = \",\" truncover;\n            length\n              directory $256.\n              filename $128.\n              include_fn_in_table_output $32.\n              file_type $32.\n              variable_name $32.\n              variable_label $256.\n              variable_type $32.\n              variable_length $32.\n              variable_format $32.\n              variable_informat $32.\n              variable_start_position $32.\n              variable_end_position $32.;\n            input\n              directory $\n              filename $\n              include_fn_in_table_output $\n              file_type $\n              variable_name $\n              variable_label $\n              variable_type $\n              variable_length $\n              variable_start_position $\n              variable_end_position $\n              variable_format $\n              variable_informat $\n              ;\n\n            put\n              directory $\n              filename $\n              include_fn_in_table_output $\n              file_type $\n              variable_name $\n              variable_label $\n              variable_type $\n              variable_length $\n              variable_start_position $\n              variable_end_position $\n              variable_format $\n              variable_informat $\n              ;\n        run;\n    %end;\n\n\n    %if &DIAP_mode_selection_ui = 3 %then\n    %do;\n        %if %upcase(\"&control_trgt_location_source\") eq \"SASSERVER\" %then\n        %do;\n            filename out \"&controlfile_target_location._DIAP_guided_execution.csv\";\n        %end; %else\n        %do;\n            filename out\n                    filesrvc\n                    folderpath     = \"&controlfile_target_location\"\n                    filename    = \"_DIAP_guided_execution.csv\";\n        %end;\n        data _null_;\n            file out delimiter = \",\";\n            infile temp_gdd delimiter = \",\" truncover;\n            length\n                full_file_name $256.\n                sheet_xml_json_tablename $128.\n                is_in_SAS_Content_flag $32.\n                column_names_in_first_row $32.\n                delimiter_for_text_files $32.\n                target_table_name $32.\n                ;\n\n            input\n                full_file_name $\n                sheet_xml_json_tablename $\n                is_in_SAS_Content_flag $\n                column_names_in_first_row $\n                delimiter_for_text_files $\n                target_table_name $\n                ;\n\n            put\n                full_file_name $\n                sheet_xml_json_tablename $\n                is_in_SAS_Content_flag $\n                column_names_in_first_row $\n                delimiter_for_text_files $\n                target_table_name $\n                ;\n        run;\n    %end;\n%end; %else\n%do;\n    %execute_all();\n%end;\n\n/**\nRestore original SAS options settings\n**/\n\n%adjust_option_setings_controlled(\n    aosc_running_mode = RESET\n    );\n\n%if &debug_mode_ui ne 1 %then\n%do;\n    proc datasets lib=work;\n        delete\n            _diap_:\n            _file_:\n            _laf_:\n            _loop_:\n            _temp_:\n            columns_:\n            get_table_info:\n            ld4um_combined:\n            original_overview_ds\n            original_var_overview_ds\n            overview_new_:\n            varnames_:\n            wof2l_:\n            zz_ld4um_:\n            _fixed_file_def:\n            _aosc:\n            ;\n    quit;\n%end;\n\n%mend check_4_admin_tasks;\n%check_4_admin_tasks();\n"}}